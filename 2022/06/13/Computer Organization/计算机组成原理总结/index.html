<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link href="https://fonts.proxy.ustclug.org/css2?family=Noto+Serif+SC&display=swap" rel="stylesheet"><link rel="apple-touch-icon" sizes="76x76" href="/img/ai.png"><link rel="icon" href="/img/ai.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="DoubleS"><meta name="keywords" content="DoubleS, Blog, AI"><meta name="description" content="计组知识点梳理+经典例题"><meta property="og:type" content="article"><meta property="og:title" content="计算机组成原理总结"><meta property="og:url" content="http://example.com/2022/06/13/Computer%20Organization/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/index.html"><meta property="og:site_name" content="DoubleS的博客"><meta property="og:description" content="计组知识点梳理+经典例题"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220611223126533.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220611230635419.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220611230157632.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220612132839610.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220612135854845.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220612140718846.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220612154236274.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220612154522722.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220612160251989.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220612160342131.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220612165649007.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220612170122513.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220612170830900.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220612171813605.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220612173014025.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220612202424634.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220613145631942.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220613150436155.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220613151148160.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220613151509451.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220613152833736.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220613153249758.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220613153545524.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220613162014659.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220613162027991.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220613163639128.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220613165100857.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220613165952869.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220613173331388.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220613173438979.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220613173721774.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220613171233031.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220613191830028.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220613215031120.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220613222618197.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220613223102575.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220613234228378.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220614094034974.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220614094536313.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220614094615872.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220614094859172.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220614095118548.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220614100806017.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220614100926907.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220614101148667.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220614104935448.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220614105024291.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220614110111824.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220614112535466.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220614113655358.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220614132504643.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220614172401604.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220614174103535.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220614175950535.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220614180530921.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220614180926538.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220614191145355.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220614192543008.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220614194719675.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220614200251576.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220614195001314.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220610130907749.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220610140146676.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220610155402568.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220610172526467.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220610191339605.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220610192255974.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220611105929919.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220611105952996.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220611113837252.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220611115057767.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220611114950237.png"><meta property="og:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220611131554004.png"><meta property="article:published_time" content="2022-06-13T10:53:55.000Z"><meta property="article:modified_time" content="2022-10-10T15:04:45.227Z"><meta property="article:author" content="DoubleS"><meta property="article:tag" content="计算机组成原理"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="c:/Users/Double%20S/AppData/Roaming/Typora/typora-user-images/image-20220611223126533.png"><title>计算机组成原理总结 - DoubleS的博客</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/ui.css"><link rel="stylesheet" href="/css/broadcast.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"example.com",root:"/",version:"1.9.2",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"NcNQRIcBWvqj7ntDBXjylaqX-gzGzoHsz",app_key:"p4VvmmJCEwjuBQGhG2McbRwj",server_url:"https://ncnqricb.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.2.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>DoubleS&#39; Blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-books"></i> 文章</a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档 </a><a class="dropdown-item" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类 </a><a class="dropdown-item" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></div></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-userfill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="计算机组成原理总结"></span></div><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> DoubleS </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-06-13 18:53" pubdate>2022年6月13日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 35k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 295 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">计算机组成原理总结</h1><div class="markdown-body"><h2 id="计算机组成原理总结"><a href="#计算机组成原理总结" class="headerlink" title="计算机组成原理总结"></a>计算机组成原理总结</h2><ul><li>本急救包由崔金钟老师所发复习重点进行填充整理</li></ul><p>[TOC]</p><h3 id="第一章-计算机系统概述"><a href="#第一章-计算机系统概述" class="headerlink" title="第一章 计算机系统概述"></a>第一章 计算机系统概述</h3><p><strong>一、计算机发展历史</strong></p><ol><li><p>从第一代到第四代计算机各自的主要特点</p><ul><li>第一代采用电子管元件</li><li>第二代采用晶体管元件，磁芯作内存，磁鼓、磁带作外存等</li><li>第三代采用中小规模集成电路，半导体存储器作内存，出现了微程序控制，Cache，虚拟存<br>储器，流水线等技术<ul><li>IBM公司提出了“兼容机”的概念<br>(兼容机的好处：可以向后兼容；关键：相同或相似的指令集或操作系统)</li><li>DEC公司提出了总线结构</li></ul></li><li>第四代采用大规模&#x2F;超大规模集成电路（LSI&#x2F;VLSI&#x2F;ULSI），出现了半导体存储器、微处理器，出现了共享存储器，分布式存储器及大规模并行处理系统等技术</li></ul></li><li><p>冯诺依曼结构要点；存储程序思想</p><ul><li><p>存储程序思想：任何要计算机完成的工作都要事先被编写成程序，然后将程序和原始数据送入主存并启动执行。一旦程序被启动，计算机应能在不许操作人员的干预下，自动完成逐条取出指令和执行指令的任务</p></li><li><p>普林斯顿高等研究院开始设计“存储程序”计算机，被称为IAS计算机（并非第一台存储程序计算机，最早是1949年英国剑桥大学完成的EDSAC）</p></li><li><p>冯·诺伊曼结构的主要思想</p><ul><li><p>计算机应由运算器、控制器、存储器、输入设备和输出设备五个基本部件组成</p></li><li><p>各部件功能</p><ul><li><strong>存储器</strong>不仅能存放数据，而且能存放指令，形式上二者没有区别，但计算机应能区分数据还是指令</li><li><strong>控制器</strong>应能自动取出并执行指令，对指令译码生成控制信号</li><li><strong>运算器</strong>应能进行加&#x2F;减&#x2F;乘&#x2F;除四种基本算术运算，并且能进行一些逻辑运算和附加运算</li><li>操作人员可以通过<strong>输入设备</strong>、<strong>输出设备</strong>和主机进行通信</li></ul></li><li><p>内部以<strong>二进制表示</strong>指令和数据</p><p>每条指令由操作码和地址码两部分组成，操作码指出操作类型，地址码指出操作数的地址</p><p>由一串指令组成程序</p></li><li><p>采用<strong>“存储程序”</strong>工作方式</p></li></ul></li></ul></li></ol><p><strong>二、计算机系统的基本组成</strong></p><ol><li><p>现代计算机结构模型的基本构成以及执行程序（指令序列）的步骤</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220611223126533.png" srcset="/img/loading.gif" lazyload alt="image-20220611223126533" style="zoom:50%"><ul><li><p>执行程序（指令序列）的步骤</p><ul><li><p>程序在执行前</p><p>数据和指令事先存放在存储器中，每条指令和每个数据都有地址，指令按序存放，指令由OP、ADDR字段组成，程序起始地址置PC</p></li><li><p>开始执行程序</p><p>第一步：根据PC取指令</p><p>第二步：指令译码</p><p>第三步：取操作数</p><p>第四步：指令执行</p><p>第五步：回写结果</p><p>第六步：修改PC的值</p><p>继续执行下一条指令</p></li></ul></li></ul></li><li><p>指令和数据</p><ul><li><p>程序启动前，指令和数据都存放在存储器中，形式上没有差别，都是0&#x2F;1序列</p></li><li><p>采用“存储程序”工作方式：程序由指令组成，程序被启动后，计算机能自动取出一条一条指令执行，在执行过程中无需人的干预</p></li><li><p>指令执行过程中，指令和数据从存储器被取到CPU，存放在CPU内的寄存器中：指令在IR中，数据在GPR中</p></li><li><p>指令中需给出的信息</p><ul><li>操作性质（操作码）</li><li>源操作数1或&#x2F;和操作数2（立即数、寄存器编号、存储地址）</li><li>目的操作数地址（寄存器编号、存储地址）</li></ul><p>存储地址的描述与操作数的数据结构有关</p></li></ul></li><li><p>软件与硬件的接口界面——ISA指令集体系结构</p><p>只有符合ISA规范的机器语言（由指令代码构成）才能被硬件直接执行</p></li><li><p>系统软件与应用软件的概念</p><ul><li><p>System software(系统软件)——简化编程，并使硬件资源被有效利用</p><ul><li><p>操作系统(Operating System)：硬件资源管理，用户接口</p></li><li><p>语言处理系统：翻译程序+Linker,Debug,etc…</p><p>翻译程序有三类</p><ul><li>汇编程序：汇编语言源程序-&gt;机器目标程序</li><li>编译程序：高级语言源程序-&gt;汇编&#x2F;机器目标程序</li><li>解释程序：将高级语言语句逐条翻译成机器指令并立即执行，不生成目标文件</li></ul></li><li><p>其他实用程序：如磁盘碎片整理程序、备份程序等</p></li></ul></li><li><p>Application software(应用软件)——解决具体应用问题&#x2F;完成具体应用</p><ul><li>各类媒体处理程序：Word&#x2F;Image&#x2F;Graphics</li><li>管理信息系统(MIS)</li><li>Game……</li></ul></li></ul></li></ol><p><strong>三、计算机系统的层次结构</strong></p><ol><li><p>现代计算机系统从硬件、ISA，到操作系统、语言处理系统和应用程序的层次结构</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220611230635419.png" srcset="/img/loading.gif" lazyload alt="image-20220611230635419" style="zoom:50%"></li><li><p>最终用户、应用程序员、系统管理员、系统程序员分别工作的层面</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220611230157632.png" srcset="/img/loading.gif" lazyload alt="image-20220611230157632" style="zoom:50%"></li><li><p>ISA涉及的主要内容（Instruction Set Architecture，指令集体系结构）</p><ul><li>ISA是一种规约，它规定了<strong>如何使用硬件</strong><ul><li>可执行的指令的集合，包括<strong>指令格式</strong>、<strong>操作种类</strong>以及每种操作对应的操作数的响应规定</li><li>指令可以接受的<strong>操作数类型</strong></li><li>操作数所能存放的寄存器组的结构，包括每个<strong>寄存器的名称、编号、长度和用途</strong></li><li>操作数所能存放的<strong>存储空间的大小和编址方式</strong></li><li>操作数在存储空间存放时按照<strong>大端还是小端方式存放</strong></li><li>指令获取操作数的方式，即<strong>寻址方式</strong></li><li>指令执行过程的控制方式，包括<strong>程序计数器、条件码定义</strong>等</li></ul></li></ul></li></ol><p><strong>四、计算机系统性能评价</strong></p><ol><li><p>一些概念</p><ul><li><p>响应时间（执行时间或等待时间）：指从作业提交开始到作业完成所用的时间</p></li><li><p>吞吐率（带宽）：指单位时间内所完成的工作量</p></li><li><p>基本的性能评价标准：CPU执行时间：执行程序中全部指令的时间</p></li><li><p>CPU时间：CPU真正花在程序执行上的时间</p><ul><li>用户CPU时间：用来运行用户代码的时间</li><li>系统CPU时间：为了执行用户程序而需要运行操作系统程序的时间</li></ul></li><li><p>MIPS：指每秒执行多少百万条指令（定点数指令）Million Instruction Per Second</p><p>$MIPS&#x3D;Instruction<del>Count&#x2F;(Second\times 10^6)&#x3D;Clock</del>Rate&#x2F;(CPI\times 10^6)$</p></li><li><p>MFLOPS：每秒执行的浮点运算有多少百万次，反映机器对浮点数处理的速度</p><p>Million Float-point Operations Per Second</p><p>$MFLOPS&#x3D;FP~Operations&#x2F;(Second\times10^6)$</p><ul><li>GFLOPS（$10^9$次&#x2F;秒）</li><li>TFLOPS（$10^{12}$次&#x2F;秒）</li><li>PFLOPS（$10^{15}$次&#x2F;秒）</li></ul></li></ul></li><li><p>CPI的计算</p><ul><li><p>CPI：Cycle Per Instruction 每条指令执行的时钟周期数</p></li><li><p>对于一条指令而言，其CPI是一个确定的值</p><p>对于某一个程序或一台机器而言，其CPI是一个平均值，表示该程序或该机器指令集中每条指令执行时平均需要多少时钟周期</p></li><li><p>CPI 一般用来衡量指令集体系结构（ISA）及其ISA的具体实现（Organization &amp; Technology）的综合性能</p></li><li><p>$CPI&#x3D;CPU时钟周期数(程序)\div 指令条数(程序)$</p><p>$CPU时钟周期数(程序)&#x3D;指令条数(程序)\times CPI$</p><p>$CPU执行时间&#x3D;CPU时钟周期数(程序)\times 时钟周期&#x3D;CPU时钟周期数(程序)\div 时钟频率&#x3D;指令条数(程序)\times CPI\times 时钟周期$</p></li><li><p>假定$CPI_i$和$C_i$分别为第$i$类指令和指令条数，则程序的总时钟数为$\sum\limits_{i&#x3D;1}^nCPI_i\times C_i$</p><p>因此CPU时间为$时钟周期\times\sum\limits_{i&#x3D;1}^nCPI_i\times C_i$</p></li><li><p>假定$CPI_i$和$F_i$是个指令的CPI和在程序中出现的频率，则程序综合CPI为$\sum\limits_{i&#x3D;1}^nCPI_i\times F_i$</p><p>其中$F_i&#x3D;\frac{C_i}{Instruction_Count}$</p></li><li><p>已知CPU时间、时钟频率、总时钟数、指令条数，则综合程序CPI为：$CPI&#x3D;(CPU时间\times时钟频率)&#x2F;指令条数&#x3D;总时钟周期数&#x2F;指令条数$</p></li></ul><blockquote><p>例题：程序P在机器A上运行需10s，机器A的时钟频率为400MHz。 现在要设计一台机器B，希望该程序在B上运行只需6s。</p><p>机器B时钟频率的提高导致了其CPI的增加，使得程序P在机器B上时钟周期数是在机器A上的1.2倍。机器B的时钟频率达到A的多少倍才能使程序P在B上执行速度是A上的10&#x2F;6&#x3D;1.67倍？</p><blockquote><p>$时钟周期数A&#x3D;CPU时间A\times时钟频率A&#x3D;10s\times 400MHz&#x3D;4000M个$</p><p>$因此时钟周期数B&#x3D;1.2\times 4000M个$</p><p>$时钟频率B&#x3D;时钟周期数B&#x2F;CPU时间B&#x3D;1.2\times4000M&#x2F;6s&#x3D;800MHz$</p><p>$故机器B的时钟频率达到A的2倍$</p></blockquote></blockquote></li><li><p>性能评价的工具——基准程序(Benchmarks)</p><ul><li><p>基准测试程序是专门用来进行性能评价的一组程序<br>不同用户使用的计算机用相同的基准程序<br>基准程序通过运行实际负载来反映计算机的性能<br>最好的基准程序是用户实际使用的程序或典型的简单程序</p></li><li><p>一个公用的基准程序：SPEC</p></li><li><p>综合性能评价</p><ul><li>算术平均</li><li>几何平均</li></ul></li></ul></li></ol><h3 id="第二章-数据的机器级表示"><a href="#第二章-数据的机器级表示" class="headerlink" title="第二章 数据的机器级表示"></a>第二章 数据的机器级表示</h3><p><strong>一、数值数据的表示</strong></p><ol><li><p>定点数的表示</p><ul><li><p>带符号数的表示</p><ul><li><p>原码：一个二进制数，用0-1代码表示符号，数值位不变</p><p>$+1001010\rightarrow01001010$ $-1001010\rightarrow11001010$</p><p>字长为8的原码，有两种0的表示形式，表示范围-127~+127</p><p>因其0表示不唯一、加减运算不统一、符号位额外处理、a&lt;b时不易实现a-b，故不用原码表示整数</p></li><li><p>补码：定点整数（假定补码有n位）则$[X]_补&#x3D;2^n+X\quad(-2^n\le X&lt;2^n,mod~2^n)$</p><ul><li><p>对于正数（字长8位）$[X]_补&#x3D;[X]_原\quad X\ge0$</p></li><li><p>对于负数（字长8位）符号位仍为1 其余位按位取反，末位加1</p><p>$[X]_补&#x3D;[X]_反+1\quad X&lt;0$</p></li><li><p>字长8位的补码表示范围-128~+127</p></li><li><p>求补（变补），已知$[X]_补$，求$[-X]_补$</p><p>$[X]_补$的代码连同符号位一起变反，末位再加1，即得到$[-X]_补$</p></li></ul></li><li><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220612132839610.png" srcset="/img/loading.gif" lazyload alt="image-20220612132839610" style="zoom:50%"></li><li><p>移码表示：将每一个数值加上一个偏置常数，当编码位数为n时，bias取$2^{n-1}$</p><p>移码和补码仅第一位不同，其余位相同</p><p>移码主要用来表示浮点数阶码：便于浮点数加减运算时的对阶操作</p></li></ul></li><li><p>带符号整数与无符号数比较</p><ul><li><p>扩充操作差别</p><p>无符号数（0拓展）</p><p>带符号数（符号拓展）</p><blockquote><p>例题：在32位机器上输出si, usi, i, ui的十进制（真值）和十六进制值（机器数）是什么？</p><p>short si &#x3D; -32768;</p><p>unsigned short usi &#x3D; si;</p><p>int i &#x3D; si;</p><p>unsingned ui &#x3D; usi;</p><p>提示：$32768&#x3D;2^{15}&#x3D;1000<del>0000</del>0000~0000B$</p><blockquote><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220612135854845.png" srcset="/img/loading.gif" lazyload alt="image-20220612135854845" style="zoom:50%"></blockquote></blockquote></li><li><p>数的比较有差别</p><p>无符号数：MSB为1的数比MSB为0的数大</p><p>带符号整数：MSB为1的数比MSB为0的数小</p></li><li><p>溢出判断有差异：无符号数根据最高位是否有进位判断溢出，通常不判</p></li></ul></li></ul></li><li><p>浮点数表示IEEE754标准</p><ul><li><p>单精度32位和双精度64位的格式与偏置常数的取值</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220612140718846.png" srcset="/img/loading.gif" lazyload alt="image-20220612140718846" style="zoom:50%"><ul><li><p>Sign bit：1表示negative；0表示positive</p></li><li><p>Exponent（阶码&#x2F;指数）</p><p>SP规格化数阶码范围0000 0001(-126)~1111 1110(127)</p><p>偏置bias为$2^7-1&#x3D;127(single)$ $2^10-1&#x3D;1023(double)$</p></li><li><p>Significand（尾数）</p><p>规格化尾数最高位总是1，所以隐含表示，省1位</p><p>$1+23bits(single)$ $1+52bits(double)$</p></li><li><p>SP：$(-1)^S\times(1+Significand)\times2^{(Exponent-127)}$</p><p>DP：$(-1)^S\times(1+Significand)\times2^{(Exponent-1023)}$</p></li></ul></li><li><p>IEEE754浮点数几个特殊数据的表示形式</p><ul><li><p>0</p><p>阶码全0，尾数全0，符号位0&#x2F;1均有效</p></li><li><p>$+\infin&#x2F;-\infin$</p><p>阶码全1，尾数全0，符号位为0为$+\infin$，符号位为1为$-\infin$</p><p>浮点数除0结果是无穷，整数除0为异常</p></li><li><p>非数NaN</p><p>阶码全1，尾数非0</p></li><li><p>非规格化数</p><p>阶码全0，尾数非0 $(-1)^S\times0.aa\ldots a\times2^{-126}$</p></li></ul></li><li><p>十进制数的表示</p><ul><li><p>用ASCII码表示十进制数：前分隔数字串和后嵌入数字串两种格式表示正负号</p><p>0-9分别对应30H-39H，一位十进制数对应8位二进制数</p><ul><li><p>前分隔数字串</p><p>符号位单独用一个字节表示，位于数字串之前</p><p>正号用“+”的ASCII码(2BH)表示；负号用“-”的ASCII码(2DH)表示</p></li><li><p>后嵌入数字串</p><p>符号位嵌入最低为数字的ASCII码高4位中，比前分隔方式省一个字节</p><p>嵌入式方法：正数不变；负数变为0111</p></li><li><p>ASCII码缺点：占用空间大，且需转换成二进制数或BCD码才能计算</p></li></ul></li><li><p>用BCD码表示十进制数：正负数的表示方法，<strong>位数不等于8Bit的整数倍时需补0</strong></p><p>0000~1001表示0~9，4位权值分别为8、4、2、1</p><p>符号位的表示 “+”1100 “-”1101</p></li></ul></li></ul></li></ol><p><strong>二、非数值数据的表示</strong></p><ol><li><p>西文字符常用编码为7位ASCII码</p><p>48为0 65为A 97为a</p></li><li><p>汉字的编码</p><ul><li><p>输入码：对汉字用相应按键进行编码表示，用于输入</p></li><li><p>内码：用于在系统中进行存储、查找、传送等处理（2个字节）</p></li><li><p>字模点阵或轮廓描述：描述汉字字模点阵或轮廓，用于显示&#x2F;打印</p></li></ul></li></ol><p><strong>三、数据的宽度，存储和排列顺序</strong></p><ol><li><p>数据的基本宽度</p><ul><li><p>比特bit是计算机中处理、存储、传输信息的最小单元</p></li><li><p>二进制信息的计量单位是“字节”Byte</p><ul><li>现代计算机中，存储器按字节编址</li><li>字节是最小可寻址单元</li><li>如果以字节为一个排列单位，则LSB表示最低有效字节，MSB表示最高有效字节</li></ul></li><li><p>字：表示被处理信息的单位，用来度量数据类型的宽度</p><p>字长：某特定机器定点运算时数据通路的宽度（CPU总线宽度等）</p><p>IA-32中1个字&#x3D;2个字节，1个字长&#x3D;4个字节</p></li></ul></li><li><p>数据按字节存储时，多字节数据的地址涉及到数据是大端方式还是小端方式</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220612154236274.png" srcset="/img/loading.gif" lazyload alt="image-20220612154236274" style="zoom:33%"></li><li><p>指令存放时大端和小端只影响指令中的多字节常数，不影响其他字段的存放顺序</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220612154522722.png" srcset="/img/loading.gif" lazyload alt="image-20220612154522722" style="zoom:33%"></li><li><p>数据存储时存在边界对齐和不对齐问题，它们在存储空间和访问速度上存在差异</p><p>对齐：要求数据的地址是相应的边界地址</p><p>不同数据存放时两种处理方式</p><ul><li>按边界对齐（假定存储字的宽度为32位，按字节编址）<ul><li>字地址：4的倍数（低两位为0）</li><li>半字地址：2的倍数（低位为0）</li><li>字节地址：任意</li></ul></li><li>不按边界对齐：可能会增加访存次数</li></ul><p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220612160251989.png" srcset="/img/loading.gif" lazyload alt="image-20220612160251989" style="zoom:25%"><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220612160342131.png" srcset="/img/loading.gif" lazyload alt="image-20220612160342131" style="zoom:25%"></p></li></ol><p><strong>四、数据的检错与纠错</strong></p><ol><li>基本原理：大多采用“冗余校验”思想，即除原数据信息外，还增加若干位编码，这些新增的代码被称为校验位。</li><li>常见数据校验编码<ul><li>奇偶校验码（不具有纠错能力）<ul><li>基本思想：增加一位奇（偶）校验位并一起存储或传送，根据终部件得到的相应数据和校验位，再求出新校验位，最后根据新校验位确定是否发生了错误</li><li>若新旧校验位不等，表示终部件有<strong>奇数位错</strong></li><li>若新旧校验位相等，表示终部件<strong>数据正确</strong>或有<strong>偶数位错</strong></li></ul></li><li>海明校验码</li><li>循环冗余校验码</li></ul></li></ol><h3 id="第三章-运算方法和运算部件"><a href="#第三章-运算方法和运算部件" class="headerlink" title="第三章 运算方法和运算部件"></a>第三章 运算方法和运算部件</h3><p><strong>一、串行进位加法器与并行进位加法器</strong></p><ol><li><p>并行进位加法器比串行进位加法器速度快的原因</p><ul><li><p>串行进位加法器</p><p>$CarryOut&#x3D;(B\and CarryIn)\or (A\and CarryIn) \or (A\and B)$</p><p>$Sum&#x3D;A\oplus B\oplus CarryIn$</p><p>缺点：进位按串行方式传递，速度慢</p><p>采用串行逐级传递进位，电路延迟与位数成正比关系</p></li><li><p>并行进位加法器</p><p>采用先行进位方式，令进位生成函数$G_i&#x3D;A_iB_i$，进位传递函数$P_i&#x3D;A_i+B_i$</p><p>全加逻辑方程：$S_i&#x3D;A_i\oplus B_i\oplus C_i$ $C_{i+1}&#x3D;G_i+P_iC_i$</p><p><strong>各进位之间无等待，相互独立并同时产生</strong></p></li></ul></li><li><p>全先行进位加法器、局部先行进位加法器和多级先行进位加法器的区别</p><ul><li><p>全先行进位加法器，把所有进位一同并行计算，成本过高（高位逻辑方程过于复杂）</p></li><li><p>局部先行进位加法器，连接一些N位先行加法器，形成一个大加法器，传递进位，但高位依赖低位传递的进位，仍有较长延迟</p><p>组内并行，组间串行</p></li><li><p>多级先行进位加法器，引入组进位生成&#x2F;传递函数（新G、P，$C_{i+1}&#x3D;G_i^*+P_i^*C_0$）实现”组内并行，组间并行“的进位方式</p></li></ul></li></ol><p><strong>二、ALU的构成</strong></p><ol><li><p>整数加减运算器的基本构成（关键:如何实现减法运算）</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220612165649007.png" srcset="/img/loading.gif" lazyload alt="image-20220612165649007" style="zoom:50%"><p>$[A+B]_补&#x3D;[A]_补+[B]_补(mod<del>2^n)$ $[A-B]_补&#x3D;[A]_补+[-B]_补(mod</del>2^n)$ $[-B]_补&#x3D;\overline{[B]}_补+1$</p><p>Sub为1，做减法；sub为0，做加法</p></li><li><p>ALU如何控制实现加、减、与、或等等各种功能</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220612170122513.png" srcset="/img/loading.gif" lazyload alt="image-20220612170122513" style="zoom:50%"><p>算术逻辑部件ALU</p><ul><li><p>进行基本算术运算与逻辑运算</p><ul><li>无符号整数加、减</li><li>带符号整数加、减</li><li>与、或、非、异或等逻辑运算</li></ul></li><li><p>输出除和&#x2F;差等，还有标志信息</p></li><li><p>有一个操作控制端（ALUop）来决定ALU所执行的处理功能</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220612170830900.png" srcset="/img/loading.gif" lazyload alt="image-20220612170830900" style="zoom:50%"></li></ul></li><li><p>ALU的OF、SF、CF和ZF等标志信息如何产生</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220612171813605.png" srcset="/img/loading.gif" lazyload alt="image-20220612171813605" style="zoom:50%"><ul><li>溢出标志OF：$OF&#x3D;C_n\oplus C_{n-1}$或A与B’同号但与Sum不同号，则OF&#x3D;1</li><li>符号标志SF：$SF&#x3D;F_{n-1}$</li><li>零标志ZF：$ZF&#x3D;1当且仅当F&#x3D;0$</li><li>进位&#x2F;借位标志CF：$CF&#x3D;Cout\oplus Cin(sub)$</li></ul></li><li><p>如何判断无符号数和带符号数加减运算时发生溢出</p><ul><li><p>加法</p><ul><li>无符号数加溢出条件：$CF&#x3D;1$</li><li>有符号数加溢出条件：$OF&#x3D;1$或A与B’同号但与Sum不同号</li></ul><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220612173014025.png" srcset="/img/loading.gif" lazyload alt="image-20220612173014025" style="zoom:33%"></li><li><p>减法</p><ul><li><p>无符号数减溢出：差为负数，即借位$CF&#x3D;1$</p></li><li><p>带符号数减溢出：$OF&#x3D;1$或A与B’同号但与Sum不同号</p></li><li><p>比较大小规则</p><ul><li>无符号数：$CF&#x3D;0\and ZF&#x3D;0$，大于</li><li>有符号数：$OF&#x3D;SF\and ZF&#x3D;0$，大于</li><li>$ZF&#x3D;1$，等于</li></ul></li></ul></li></ul></li></ol><p><strong>三、定点数的加减乘法运算方法</strong></p><ol><li><p>补码、原码、移码的加减运算方法</p><ul><li><p>原码加&#x2F;减运算：用于浮点数尾数运算，符号位和数值部分分开处理</p><ul><li><p>比较两数符号，对加法执行”同号求和，异号求差“，对减法进行”异号求和，同号求差“</p></li><li><p>求和：数值位相加，和的符号取被加数（或被减数）的符号</p><p>若最高位产生进位，则结果溢出</p></li><li><p>求差：加数（或减数）求补后与被加数（被减数）相加</p><ul><li><p>最高位产生进位（Cout&#x3D;1）则无借位（CF&#x3D;0），表示够减结果为正，该结果即为差的数值位的原码</p></li><li><p>最高位无进位（Cout&#x3D;0）则CF&#x3D;1，结果为负，它是差的数值位的补码形式，需对结果求补，还原为原码形式的数值位</p></li><li><p>差的符号位：对于第一种情况，符号位取被加数（被减数）的符号</p><p>对于第二种情况，符号位取相反符号</p></li></ul></li></ul><blockquote><p>例题：已知$[X]_原&#x3D;1.0011,[Y]_原&#x3D;1.1010,计算[X+Y]_原与[X-Y]_原$</p><blockquote><p>(1)同号相加，则求和</p><p>和的数值位：0011+1010&#x3D;1101</p><p>和的符号位：1</p><p>$[X+Y]_原&#x3D;1.1101$</p><p>(2)同号相减，则求差</p><p>差的数值位：0011+0110&#x3D;1001</p><p>无进位，加法结果为负，需对1001求补为0111</p><p>差的符号位为被减数X取反后的符号为0</p><p>$[X-Y]_原&#x3D;0.0111$</p></blockquote></blockquote></li><li><p>移码加&#x2F;减运算：用于浮点数阶码运算，符号位和数值位可以一起处理</p><ul><li>加法：直接将$[E1]_移$与$[E2]_移$进行模$2^n$加，对结果符号取反</li><li>减法：先将减数$[E2]_移$求补，然后与被减数$[E1]_移$进行模$2^n$相加，最后对结果的符号取反</li><li>溢出判断，若模$2^n$相加时，两个加数符号相同并且与和数的符号也相同，则发生溢出</li></ul><blockquote><p>例题：用四位移码计算-3+6与-3-5的值</p><blockquote><p>(1)$[-3]_移+[6]_移&#x3D;0101+1110&#x3D;1011(符号取反后)$，故真值为+3</p><p>(2)$[-3]_移-[5]_移&#x3D;0101+0011&#x3D;0000(符号取反后)$，故真值为-8</p></blockquote></blockquote></li></ul></li><li><p>无符号数乘法的机器实现基本步骤</p><p>递推公式：$P_{i+1}&#x3D;2^{-1}(x\cdot y_{n-i}+P_{i})$，其中$Y&#x3D;y_1y_2\ldots y_n$</p><p>思想：$P_0&#x3D;0$，部分积右移后与$x\cdot y_i$相加</p><p>对乘数中为“1”的位执行加法和右移，对为“0”的位只执行右移，而不执行加法运算</p></li><li><p>无符号数乘法的硬件逻辑结构</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220612202424634.png" srcset="/img/loading.gif" lazyload alt="image-20220612202424634" style="zoom:33%"><ul><li>快速乘法器可考虑流水线方式或硬件叠加方式</li></ul></li><li><p>原码一位乘法机器实现的基本原理</p><p>用于浮点数尾数乘运算，符号与数值分开处理：积符由异或得到，数值用无符号乘法运算</p><blockquote><p>例题：设$[x]_原&#x3D;0.1110，[y]_原&#x3D;1.110$，计算$[x\times y]_原$</p><blockquote><p>数值部分用无符号乘法算法计算：$1110\times 1101&#x3D;1011~0110$</p><p>符号位：$0\oplus 1&#x3D;1$，故$[x\times y]_原&#x3D;1.10110110$</p></blockquote></blockquote></li></ol><p><strong>四、浮点数运算</strong></p><ol><li><p>浮点数加减运算（假定$M_x、M_y$分别是X和Y的尾数，$E_x、E_y$分别是X和Y的阶码）</p><ul><li><p><strong>对阶操作</strong>：目的是使两数阶码相等，小阶向大阶看齐，右移位数等于两个阶码差的绝对值</p><p>IEEE 754尾数右移时，要将隐含的“1”移到小数部分，高位补0，移出的低位保留到特定的“附加位”上</p><ul><li><p>求阶差</p><p>$[\Delta E]_补&#x3D;[E_x-E_y]_补&#x3D;[E_x]_移+[-[E_y]_移]_补(mod~2^n)$</p><p>通过符号可判断$\Delta E&gt;0$还是$\Delta E\le 0$</p></li><li><p>对阶</p><ul><li>若$\Delta E\le0$，则$E_x\leftarrow E_y，M_x\leftarrow M_x\times 2^{E_x-E_y}，E_b\leftarrow E_y$</li><li>若$\Delta E&gt;0$，则$E_y\leftarrow E_x，M_y\leftarrow M_y\times 2^{E_y-E_x}，E_b\leftarrow E_x$</li></ul></li></ul></li><li><p><strong>尾数相减</strong>：使用原码加减法，计算包含隐含位与右移附加位</p></li><li><p><strong>尾数规格化</strong></p><ul><li>±1x .xx……x形式时，则右规：尾数右移1位，阶码加1</li><li>±0.0…01x…x 形式时，则左规：尾数左移k位，阶码减k</li></ul></li><li><p><strong>尾数舍入处理</strong>：去除附加位</p><ul><li><p>就近舍入：舍入为最近可表示的数</p><p>若为非中间值：0舍1入；</p><p>若为中间值：强迫结果为偶数</p></li><li><p>朝$+\infin$方向舍入：舍入为右边最近可表示数(正向舍入)</p></li><li><p>朝$-\infin$方向舍入：舍入为左边最近可表示数 (负向舍入)</p></li><li><p>朝0方向舍入：直接截取所需位，后面的位丢弃</p></li></ul></li><li><p><strong>溢出判断</strong>：若上溢，置无穷；若下溢，置零</p><ul><li>左规（阶码 - 1）时：先判断阶码是否为全0，若是，则直接置阶码下溢；否则，阶码减1后判断阶码是否为全0，若是，则阶码下溢</li><li>右规（阶码 +1）时：先判断阶码是否为全1，若是，则直接置阶码上溢；否则，阶码加1后判断阶码是否为全1，若是，则阶码上溢</li></ul></li><li><p>![image-20220612231600791](C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220612231600791.png)</p></li><li><blockquote><p>例题：已知x&#x3D;0.5，y&#x3D;-0.4375，求x+y&#x3D;?(用IEEE754标准单精度格式计算)</p><blockquote><p>$x&#x3D;0.5&#x3D;1&#x2F;2&#x3D;(0.100\ldots0)_2&#x3D;(1.00\ldots0)_2\times2^{-1}$</p><p>$y&#x3D;-0.4325&#x3D;(-0.01110\ldots0)_2&#x3D;(-1.110\ldots0)_2\times2^{-2}$</p><p>$[x]_浮&#x3D;0~01111110,00\ldots0$</p><p>$[y]_浮&#x3D;1~01111101，110\ldots0$</p><p>对阶：$[\Delta E]_补&#x3D;01111110+10000011&#x3D;00000001$ $\Delta E&#x3D;1$</p><p>对y进行对阶$[y]_浮&#x3D;1~01111110，1110\ldots0$（高位补隐藏位1）</p><p>尾数相加：$01.0000\ldots0+(10.1110\ldots0)&#x3D;00.0010\ldots0$</p><p>（原码加法，最左边一位为符号位，符号位单独处理）</p><p>需要左归：$+(0.0010\ldots)_2\times2^{-1}&#x3D;+(1.0\ldots0)_2\times2^{-4}$，无溢出</p><p>故$[x+y]_浮&#x3D;0~011111011,0\ldots0$</p><p>故$x+y&#x3D;(1.0)_2\times2^{-4}&#x3D;\frac{1}{16}&#x3D;0.0625$</p></blockquote></blockquote></li></ul></li><li><p>求阶码的和、差</p><ul><li>阶码加法公式$[E_x+E_y]_移&#x3D;E_b&#x3D;E_x+E_y+129(mod~2^8)$</li><li>阶码减法公式$[E_x-E_y]_移&#x3D;E_b&#x3D;E_x+[-E_y]_补+127(mod~2^8)$</li></ul></li></ol><h3 id="第四章-指令系统"><a href="#第四章-指令系统" class="headerlink" title="第四章 指令系统"></a>第四章 指令系统</h3><p><strong>一、指令系统设计</strong></p><ol><li><p>指令中应该包括哪些字段？提供操作数或操作数地址有哪些方式？</p><ul><li><p>指令包含信息</p><ul><li>操作码：指定操作类型（长度：固定&#x2F;可变）</li><li>源操作数及其地址：一个或多个源操作数所在的地址（操作数来源：主存&#x2F;寄存器&#x2F;I&#x2F;O端口）</li><li>结果的地址：产生的结果存放何处（目的操作数）（结果地址：主存&#x2F;寄存器&#x2F;I&#x2F;O端口）</li><li>下一条指令的地址：下条指令存放何处（主存，正常情况下隐含在PC中，改变顺序由指令给出）</li></ul></li><li><p>指令提供操作数方式</p><ul><li><p>零地址指令</p><table><thead><tr><th>OP</th></tr></thead></table><ul><li>无需操作数，如：空操作&#x2F;停机等</li><li>所需操作数为默认位置，如：堆栈&#x2F;累加器等</li></ul></li><li><p>一地址指令</p><p>其地址既是操作数的地址，也是结果的地址</p><table><thead><tr><th>OP</th><th>A1</th></tr></thead></table><ul><li>单目运算，如：取反&#x2F;取负等</li><li>双目运算：另一操作数是默认的，如：累加器等</li></ul></li><li><p>二地址指令（CISC中最常用）</p><p>分别存放双目运算中两个操作数，并将其中一个地址作为结果的地址</p><table><thead><tr><th>OP</th><th>A1</th><th>A2</th></tr></thead></table></li><li><p>三地址指令（RISC风格）</p><p>分别作为双目运算中两个源操作数的地址和一个结果的地址</p><table><thead><tr><th>OP</th><th>A1</th><th>A2</th><th>A3</th></tr></thead></table></li><li><p>多地址指令</p><p>用于成批数据处理的指令，如：向量&#x2F;矩阵等运算的SIMD指令</p></li></ul></li></ul></li><li><p>明白指令格式设计的几个基本原则</p><ul><li>应尽量短</li><li>要有足够的操作码位数</li><li>指令编码必须有唯一的解释，否则是不合法的指令</li><li>指令字长应是字节的整数倍</li><li>合理地选择地址字段的个数</li><li>指令尽量规整</li></ul></li><li><p>掌握一般计算机中8种基本寻址方式产生操作数的过程</p><p>假设 A：地址字段值，R：寄存器编号，EA：有效地址，(X)：X中的内容</p><table><thead><tr><th>方式</th><th>算法</th><th>主要优点</th><th>主要缺点</th></tr></thead><tbody><tr><td>立即</td><td>操作数&#x3D;A</td><td>指令执行速度快</td><td>操作数幅值有限</td></tr><tr><td>直接</td><td>EA&#x3D;A</td><td>有效地址计算简单</td><td>地址范围有限</td></tr><tr><td>间接</td><td>EA&#x3D;(A)</td><td>有效地址范围大</td><td>多次存储器访问</td></tr><tr><td>寄存器</td><td>操作数&#x3D;(R)</td><td>指令执行快，指令短</td><td>地址范围有限</td></tr><tr><td>寄存器间接</td><td>EA&#x3D;(R)</td><td>地址范围大</td><td>额外存储器访问</td></tr><tr><td>偏移</td><td>EA&#x3D;A+(R)</td><td>灵活</td><td>复杂</td></tr><tr><td>堆栈</td><td>EA&#x3D;栈顶</td><td>指令短</td><td>应用有限</td></tr></tbody></table><ul><li>偏移方式有相对&#x2F;基址&#x2F;变址三种<ul><li>相对寻址：EA&#x3D;A+(PC) Beq</li><li>基址寻址：EA&#x3D;A+(B) lw&#x2F;sw</li><li>变址寻址：EA&#x3D;A+(I)</li></ul></li></ul></li><li><p>掌握变长操作码编码方法的基本原理</p><ul><li><p>基本思想：将操作码的编码长度分成几种固定长的格式</p></li><li><p>种类</p><ul><li>等长拓展法：4-8-12；3-6-9……</li><li>不等长拓展法</li></ul></li><li><blockquote><p>例题：设某指令系统指令字是16位，每个地址码为6位。若二地址指令15条，一地址指令34条，则剩下零地址指令最多有多少条？</p><blockquote><p>操作码由短到长进行拓展编码</p><p>二地址指令：操作码4位(0000~1110：15条)</p><p>一地址指令：操作码10位11110(00000~11111：32条)；11111(00000~00001：2条)</p><p>零地址指令：操作码16位11111(00010~11111：30)(000000~111111：64)</p><p>故零地址指令最多由$30\times64&#x3D;1920条$</p></blockquote></blockquote></li></ul></li><li><p>条件码的产生；条件码的应用：无符号数的大小比较方法和带符号数的比较方法</p><ul><li><p>条件转移指令通常根据Condition Codes (条件码CC&#x2F;状态位&#x2F;标志位)转移</p></li><li><p>常用标志（条件码）</p><ul><li>SF-negative</li><li>OF-overflow</li><li>CF-进位&#x2F;借位</li><li>ZF-zero</li></ul></li><li><p>标志可存放于标志寄存器&#x2F;条件码寄存器&#x2F;状态寄存器&#x2F;程序状态寄存器</p></li><li><p>例如sub r1, r2, r3;r2和r3相减,结果在r1中，并生成标志位ZF、CF等</p><p>bz label;标志位ZF&#x3D;1时转到label处执行；否则顺序执行</p></li><li><p>无符号数：$CF&#x3D;0\and ZF&#x3D;0$，大于</p><p>有符号数：$OF&#x3D;SF\and ZF&#x3D;0$​，大于</p></li></ul></li><li><p>了解堆栈型、累加器型、通用寄存器型和装入&#x2F;存储型四种指令格式风格操作过程和特点</p><p>掌握CISC和RISC两类指令的特点</p><p>了解CISC指令系统的2&#x2F;8规律</p><ul><li><p>四种指令格式风格</p><ul><li><p>累加器型</p><p>特点：其中一个操作数（源操作数1）和目的操作数总在累加器中</p><table><thead><tr><th>1 address</th><th>add A</th><th>acc$\leftarrow$acc+mem[A]</th></tr></thead><tbody><tr><td>1(+x) address</td><td>add x A</td><td>acc$\leftarrow$acc+mem[A+x]</td></tr></tbody></table></li><li><p>堆栈型</p><p>特点：总是将栈顶两个操作数进行运算，指令无需指定操作数地址</p><table><thead><tr><th>0 address</th><th>add</th><th>tos$\leftarrow$tos+next</th></tr></thead></table></li><li><p>通用寄存器型</p><p>特点：操作数可以是寄存器或存储器数据（即A、B和C可以是寄存器或存储单元）</p><table><thead><tr><th>2 address</th><th>add A B</th><th>EA(A)$\leftarrow$EA(A)+EA(B)</th></tr></thead><tbody><tr><td>3 address</td><td>add A B C</td><td>EA(A)$\leftarrow$EA(B)+EA(C)</td></tr></tbody></table></li><li><p>装入&#x2F;存储型</p><p>特点：运算指令的操作数只能是寄存器数据，只有load&#x2F;store能访问存储器</p><table><thead><tr><th>3 address</th><th>add Ra Rb Rc</th><th>Ra$\leftarrow$Rb+Rc</th></tr></thead><tbody><tr><td>2 address</td><td>load Ra Rb</td><td>Ra$\leftarrow$mem[Rb]</td></tr><tr><td>2 address</td><td>store Ra Rb</td><td>mem[Rb]$\leftarrow$Ra</td></tr></tbody></table></li></ul></li><li><p>指令格式复杂度</p><ul><li>复杂指令集计算机CISC<ul><li>指令系统复杂：变长操作码&#x2F;变长指令字&#x2F;指令多&#x2F;寻址方式多&#x2F;指令格式多</li><li>指令周期长：绝大多数指令需要多个时钟周期才能完成</li><li>各种指令都能访问存储器：除了专门的存储器读写指令外，运算指令也能访问存储器</li><li>采用微程序控制</li><li>有专用寄存器</li><li>难以进行编译优化来生成高校目标代码</li></ul></li><li>精简指令集计算机RISC（MIPS）<ul><li>简化的指令系统：指令少&#x2F;寻址方式少&#x2F;指令格式少&#x2F;指令长度一般</li><li>以RR方式工作：除Load&#x2F;Store指令可访问存储器外，其余指令只能访问寄存器</li><li>指令周期短：以流水线方式工作，因而除Load&#x2F;Store指令外，其他简单指令都只需一个或一个不到时钟周期</li><li>采用大量通用寄存器，减少访存次数</li><li>采用硬连线控制器控制，不用或少用微程序控制</li><li>采用优化的编译系统，力求有效地支持高级语言程序</li></ul></li></ul></li><li><p>CISC指令系统的2&#x2F;8规律</p><p>在程序中各种指令出现的频率悬殊很大，最常使用的是一些简单指令，这些指令占程序的80%，但只占指令系统的20%</p><p>在微程序控制的计算机中，占指令总数20%的复杂指令占用了控制存储器容量的80%</p></li></ul></li></ol><p><strong>二、程序的机器级表示</strong></p><ol><li><p>MIPS指令有哪些寻址方式？有哪些特有的寻址方式？掌握MIPS的基本汇编指令表示</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220613145631942.png" srcset="/img/loading.gif" lazyload alt="image-20220613145631942" style="zoom:33%"><ul><li><p>汇编形式</p><ul><li><p>R型：指令(sub) rd, rs, rt</p></li><li><p>I型</p><p>运算指令：指令(ori) rt, rs, imm16</p><p>Load&#x2F;Store：指令(lw&#x2F;sw) rt, rs, imm16</p><p>条件分支指令：指令(beq) rs, rt, imm16</p></li><li><p>J型：指令(j) target</p></li></ul></li></ul></li><li><p>掌握MIPS计算机的R型、I型和J型三种指令格式</p><ul><li><p>R型指令</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220613150436155.png" srcset="/img/loading.gif" lazyload alt="image-20220613150436155" style="zoom:33%"><ul><li><p>参与操作的3个操作数都是寄存器操作数</p></li><li><p>R型指令的op全为0，具体功能由func部分决定</p></li><li><p>rs：第一个源操作数</p><p>rt：第二个源操作数</p><p>rd：目的寄存器</p><p>shamt：对非移位指令为00000，移位指令为移位次数</p></li><li><table><thead><tr><th>指令</th><th>[31:26]</th><th>[25:21]</th><th>[20:16]</th><th>[15:11]</th><th>[10:6]</th><th>[5:0]</th><th>功能</th></tr></thead><tbody><tr><td>add</td><td>000000</td><td>rs</td><td>rt</td><td>rd</td><td>00000</td><td>100000</td><td>寄存器加</td></tr><tr><td>sub</td><td>000000</td><td>rs</td><td>rt</td><td>rd</td><td>00000</td><td>100010</td><td>寄存器减</td></tr><tr><td>and</td><td>000000</td><td>rs</td><td>rt</td><td>rd</td><td>00000</td><td>100100</td><td>寄存器与</td></tr><tr><td>or</td><td>000000</td><td>rs</td><td>rt</td><td>rd</td><td>00000</td><td>100101</td><td>寄存器或</td></tr><tr><td>xor</td><td>000000</td><td>rs</td><td>rt</td><td>rd</td><td>00000</td><td>100110</td><td>寄存器异或</td></tr><tr><td>sll</td><td>000000</td><td>00000</td><td>rt</td><td>rd</td><td>sa</td><td>000000</td><td>左移</td></tr><tr><td>srl</td><td>000000</td><td>00000</td><td>rt</td><td>rd</td><td>sa</td><td>000010</td><td>逻辑右移</td></tr><tr><td>sra</td><td>000000</td><td>00000</td><td>rt</td><td>rd</td><td>sa</td><td>000011</td><td>算术右移</td></tr><tr><td>jr</td><td>000000</td><td>rs</td><td>00000</td><td>00000</td><td>00000</td><td>001000</td><td>寄存器跳转</td></tr></tbody></table></li></ul></li><li><p>I型指令</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220613151148160.png" srcset="/img/loading.gif" lazyload alt="image-20220613151148160" style="zoom:33%"><ul><li><p>指令中包含1个立即数，它可能是1个操作数，或存储器的偏移地址</p></li><li><p>op：确定指令功能</p><p>rs：一个源操作数，是寄存器操作数；或者在存取指令中用于偏移寻址方式中的基地址寄存器</p><p>rt：目的寄存器</p><p>Immediate：立即数，可以是第2个源操作数，或者是偏移寻址中的偏移量</p></li><li><table><thead><tr><th>指令</th><th>[31:26]</th><th>[25:21]</th><th>[20:16]</th><th>[15:0]</th><th>功能</th></tr></thead><tbody><tr><td>addi</td><td>001000</td><td>rs</td><td>rt</td><td>immediate</td><td>立即数加</td></tr><tr><td>andi</td><td>001100</td><td>rs</td><td>rt</td><td>immediate</td><td>立即数与</td></tr><tr><td>ori</td><td>001101</td><td>rs</td><td>rt</td><td>immediate</td><td>立即数或</td></tr><tr><td>xori</td><td>001110</td><td>rs</td><td>rt</td><td>immediate</td><td>立即数异或</td></tr><tr><td>lw</td><td>100011</td><td>rs</td><td>rt</td><td>immediate</td><td>取字数据</td></tr><tr><td>sw</td><td>101011</td><td>rs</td><td>rt</td><td>immediate</td><td>存字数据</td></tr><tr><td>beq</td><td>000100</td><td>rs</td><td>rt</td><td>immediate</td><td>相等转移</td></tr><tr><td>bne</td><td>000101</td><td>rs</td><td>rt</td><td>immediate</td><td>不等转移</td></tr><tr><td>lui</td><td>001111</td><td>00000</td><td>rt</td><td>immediate</td><td>设置高位</td></tr></tbody></table></li></ul></li><li><p>J型指令</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220613151509451.png" srcset="/img/loading.gif" lazyload alt="image-20220613151509451" style="zoom:33%"><ul><li><p>op：确定指令功能</p><p>address：转移地址</p></li><li><p>PC高4位不变，将target左移两位，送入PC的低28位</p></li><li><table><thead><tr><th>指令</th><th>[31:26]</th><th>[25:0]</th><th>功能</th></tr></thead><tbody><tr><td>j</td><td>000010</td><td>address</td><td>跳转</td></tr><tr><td>jal</td><td>001100</td><td>address</td><td>调用</td></tr></tbody></table></li></ul></li></ul></li><li><p>高级语言与汇编指令之间的转换：掌握基本的高级语言中的运算表达式 ，If语句，循环，数组访问的汇编语言实现<strong>（理解即可）</strong></p><ul><li><p>算术运算</p><blockquote><p>E.g. f&#x3D; (g+h) - (i+j)</p><p>assuming f, g, h, i, j be assigned to $1, $2, $3, $4, $5</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220613152833736.png" srcset="/img/loading.gif" lazyload alt="image-20220613152833736" style="zoom:50%"></blockquote></li><li><p>if语句</p><blockquote><p>if (i&#x3D; &#x3D; j)</p><p>​ f &#x3D; g+h ;</p><p>else</p><p>​ f &#x3D; g-h ;</p><p>Assuming variables i, j, f, g, h, ~ $1, $2, $3, $4, $5</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220613153249758.png" srcset="/img/loading.gif" lazyload alt="image-20220613153249758" style="zoom:33%"></blockquote></li><li><p>循环</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220613153545524.png" srcset="/img/loading.gif" lazyload alt="image-20220613153545524" style="zoom:33%"></li></ul></li></ol><h3 id="第五章-中央处理器"><a href="#第五章-中央处理器" class="headerlink" title="第五章 中央处理器"></a>第五章 中央处理器</h3><p><strong>一、单周期数据通路的设计</strong></p><ul><li>数据通路：由“操作元件”和“存储元件”通过总线方式或分散方式连接而成，进行数据传送、处理和存储</li></ul><ol><li><p>操作元件和存储元件的概念</p><ul><li><p>每条指令功能可由以下四种基本操作实现</p><ul><li>读取某一主存单元的内容，并将其装入某个寄存器（取指， 取数）</li><li>把一个数据从某个寄存器存入给定的主存单元中（存结果）</li><li>把一个数据从某个寄存器送到另一个寄存器或者ALU（取数，存结果）</li><li>进行算术或逻辑运算（PC+1，计算地址，运算）</li></ul></li><li><p>操作元件（组合逻辑元件）</p><ul><li><p>特点：其输出只取决于当前的输入且无时钟信号定时</p></li><li><p>加法器Adder</p><p>多路选择器MUX</p><p>算术逻辑单元ALU</p><p>译码器Decoder</p></li></ul></li><li><p>存储元件（时序逻辑元件）</p><ul><li><p>特点：具有存储功能，在时钟控制下输入被写到电路中，直到下个时钟到达</p><p>输入端状态由时钟决定何时被写入，输出端状态随时可以读出</p></li><li><p>定时方式：规定信号何时写入状态元件或何时从状态元件读出</p><ul><li>边沿触发方式：上升沿&#x2F;下降沿</li></ul></li><li><p>寄存器和寄存器组</p></li><li><p>理想存储器</p></li></ul></li></ul></li><li><p>寄存器和寄存器组、理想存储器的读过程和写过程，以及它们的区别</p><ul><li><p>寄存器</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220613162014659.png" srcset="/img/loading.gif" lazyload alt="image-20220613162014659" style="zoom:33%"><ul><li>有一个写使能（WE）信号<ul><li>WE&#x3D;0：时钟边沿到来时，输出不变</li><li>WE&#x3D;1：时钟边沿到来时，输出变为输入</li></ul></li><li>若每个时钟边沿都写入，则不需WE信号</li></ul></li><li><p>寄存器组：32个寄存器</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220613162027991.png" srcset="/img/loading.gif" lazyload alt="image-20220613162027991" style="zoom:33%"><ul><li><p>两个读口（组合逻辑操作）：busA和busB分别由RA和RB给出地址</p><p>地址RA或RB有效后，经一个取数时间（AccessTime），busA和busB有效</p></li><li><p>一个写口（时序逻辑操作）：写使能为1的情况下，时钟边沿到来时，busW上的值开始被写入RW指定的寄存器中</p></li></ul></li><li><p>理想存储器</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220613163639128.png" srcset="/img/loading.gif" lazyload alt="image-20220613163639128" style="zoom:33%"><ul><li><p>Data Out：32位读出数据</p></li><li><p>Data In：32位写入数据</p></li><li><p>Address：读写公用一个32位地址</p></li><li><p>读操作（组合逻辑操作）</p><p>地址Address有效后，经一个”取数时间AccessTime”，Data Out上数据有效</p></li><li><p>写操作（时序逻辑操作）</p><p>写使能为1的情况下，时钟Clk边沿到来时，Data In传来的值开始被写入Address指定的存储单元中</p></li></ul></li></ul></li><li><p>熟练掌握课件中的最基本的7条指令执行时数据通路中信息的流动过程，以及在取指令部件中的信息处理，包括元件的连接和所需要的各种控制信号的取值等</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220613165100857.png" srcset="/img/loading.gif" lazyload alt="image-20220613165100857" style="zoom:50%"> <img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220613165952869.png" srcset="/img/loading.gif" lazyload alt="image-20220613165952869" style="zoom:50%"><ul><li><p>PS：其中lw与sw的运算方式为addu，不需要判断溢出</p><p>R型指令需要判断溢出，故overflow与RegWr控制信号经过与门后决定是否写入寄存器</p></li><li><p>R型指令：$R[rd]\leftarrow R[rs]+&#x2F;-R[rt]$</p><p>ori指令：$R[rt]\leftarrow R[rs]<del>or</del>ZeroExt[imm16]$</p><p>lw指令：$R[rt]\leftarrow Data~Memory{R[rs]+SignExt[imm16]}$</p><p>sw指令：$M{R[rs]+SignExt[imm16]}\leftarrow R[rt]$</p><p>beq指令：if $(R[rs]-R[rt]&#x3D;&#x3D;0)$ then $Zero\leftarrow 1$；else $Zero\leftarrow 0$</p></li></ul></li></ol><p><strong>二、单周期控制器的设计</strong></p><ol><li><p>运算器的功能是如何控制的？掌握指令译码的基本原理，OP和func字段如何与指令功能对应（参考上图布尔式）</p><ul><li><p>ALU的设计</p><ul><li><p>add：有溢出判断的加法</p><p>sub：有溢出判断的减法</p><p>addu：无溢出判断的加法，即加法器的溢出标志位不输出</p><p>subu：无溢出判断的减法，即加法器的溢出标志位不输出</p><p>or：按位逻辑或运算</p><p>slt：带符号数的大小比较，用两数相减的符合和溢出标志来判断（PPT未考虑）</p><p>sltu：无符号数的大小比较，用两数相减的借位标志来判断（PPT未考虑）</p></li><li><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220613173331388.png" srcset="/img/loading.gif" lazyload alt="image-20220613173331388" style="zoom:33%"></li><li><p>ALUop的编码</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220613173438979.png" srcset="/img/loading.gif" lazyload alt="image-20220613173438979" style="zoom:50%"></li><li><p>ALU局部控制器</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220613173721774.png" srcset="/img/loading.gif" lazyload alt="image-20220613173721774" style="zoom:50%"></li></ul></li></ul></li><li><p>单周期CPU的周期长度是由什么指令、哪些因素决定的</p><ul><li><p>关键路径时长&#x3D;PC的Clk-to-Q时间+指令存储器的取数时间+寄存器组的取数时间+ALU加法延时+数据存储器的取数时间+写寄存器的建立时间+时钟偏移</p></li><li><p>lw指令的执行时间最长,它所花时间作为时钟周期</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220613171233031.png" srcset="/img/loading.gif" lazyload alt="image-20220613171233031" style="zoom:33%"></li></ul></li></ol><p><strong>三、微程序控制原理</strong></p><ol><li><p>微程序控制器的基本思想</p><ul><li>仿照程序设计的方法，编制每条指令对应的微程序</li><li>每个微程序由若干条微指令构成，各微指令包含若干条微命令</li><li>所有指令对应的微程序放在只读存储器中，执行某条指令就是取出对应微程序中的各条微指令，对微指令译码产生对应的微命令(即控制信号)</li><li>这个只读存储器称为控制存储器（Control Storage），简称控存CS</li></ul></li><li><p>比较硬连线控制器和微程序控制器的优缺点</p><ul><li><p>硬连线控制器</p><ul><li><p>优点：速度快，适合于简单或规整的指令系统，例如，MIPS指令集</p></li><li><p>缺点：它是一个多输入&#x2F;多输出的巨大逻辑网络</p><p>对于复杂指令系统来说，结构庞杂，实现困难；修改、维护不易；灵活性差，甚至无法用有限状态机描述</p></li></ul></li><li><p>微程序控制器</p><p>具有规整性、可维护性和灵活性，但速度慢</p></li></ul></li><li><p>指令、微程序、微指令、微命令、微操作它们之间的关系</p><ul><li><p>将指令的执行转换为微程序的执行</p><p>微程序是一个微指令序列</p><p>每条微指令是一个0&#x2F;1序列，其中包含若干个微命令（即：控制信号）</p><p>微命令控制数据通路的执行</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220613191830028.png" srcset="/img/loading.gif" lazyload alt="image-20220613191830028" style="zoom:33%"></li></ul></li><li><p>了解水平型微指令和垂直型微指令的概念</p><ul><li>水平型微指令<ul><li>基本思想：相容微命令尽量多地安排在一条微指令中</li><li>优点：微程序短，并行性高，适合于较高速度的场合</li><li>缺点：微指令长，编码空间利用率较低，并且编制困难</li></ul></li><li>垂直型微指令<ul><li>基本思想：一条微指令只控制一、二个微命令</li><li>优点：微指令短，编码效率高，格式与机器指令类似，故编制容易</li><li>缺点：微程序长，一条指令只能控制一、二个操作，无并行，速度慢</li></ul></li></ul></li></ol><p><strong>四、异常和中断处理</strong>（第八章也有说明）</p><ol><li><p>异常和中断（外部）的区别</p><ul><li><p>内部“异常”：在CPU内部发生的意外事件或特殊事件</p><ul><li><p>按发生原因分类</p><ul><li>硬故障中断：如电源掉电，硬件线路故障等</li><li>程序性中断：执行某条指令时发生的”例外“，如溢出、缺页、越界、越权、非法指令、除数为0、堆栈溢出、访问超时、断点设置、单步、系统调用等</li></ul></li><li><p>按处理方式分类</p><ul><li><p>故障：执行指令引起的异常事件，如溢出、缺页、堆栈溢出、访问超时</p><p>”断点“为发生故障指令的地址</p></li><li><p>自陷：预先安排的事件，如单步跟踪、系统调用，是一种自愿中断</p><p>”断点“为发生下条指令的地址</p></li><li><p>终止：硬故障时间，此时机器将终止，调出中断服务程序来重启操作系统</p><p>”断点“无所谓</p></li></ul></li></ul></li><li><p>外部”中断“：在CPU外部发生的特殊事件，通过”中断请求“信号向CPU请求处理</p><p>如实时钟、控制台、打印机缺纸、外设准备好、采样计时到、DMA传输结束等</p></li></ul></li><li><p>掌握计算机中对异常&#x2F;中断的软件识别（MIPS计算机）和硬件识别这两种不同方式的基本过程</p><ul><li><p>检测到异常时，处理器必须进行如下处理：</p><ul><li><p>关中断（”中断&#x2F;异常允许“状态位清0）：使处理器处于”禁止中断“状态，以防止新异常（或中断）破坏断点、程序状态和现场（现场指通用寄存器的值）</p></li><li><p>保护断点和程序状态：将断点和程序状态保存到堆栈或特殊寄存器中</p><p>PC$\rightarrow$堆栈或EPC（专门存放断点的寄存器）</p><p>PSWR$\rightarrow$堆栈或EPSWR（专门保存程序状态的寄存器）</p><p>PSW：程序状态字，包括条件码、中断码、状态位等</p><p>PSWR：用于存放程序状态字的寄存器</p></li><li><p>识别异常事件</p><ul><li><p>软件识别（MIPS采用）</p><p>设置一个异常状态寄存器（MIPS中为Cause寄存器），用于记录异常原因。操作系统使用一个统一的异常处理程序，该程序按优先级顺序查询异常状态寄存器的各位，识别出异常事件</p></li><li><p>硬件识别（向量中断方式）（80x86采用）</p><p>用专门的硬件查询电路按优先级顺序识别异常，得到“中断类型号”，根据此号，到中断向量表中读取对应的中断服务程序的入口地址</p></li></ul></li></ul></li></ul></li></ol><h3 id="第六章-指令流水线"><a href="#第六章-指令流水线" class="headerlink" title="第六章 指令流水线"></a>第六章 指令流水线</h3><p><strong>一、流水线数据通路和控制</strong></p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220613215031120.png" srcset="/img/loading.gif" lazyload alt="image-20220613215031120" style="zoom:100%"><ul><li>Ifetch（取指）：取指令并计算PC+4，指令存储器、Adder</li><li>Reg&#x2F;Dec（取数和译码）：取数同时译码，寄存器堆读口、指令译码器</li><li>Exec（执行）：计算内存单元地址，扩展器，ALU</li><li>Mem（读存储器）：从数据存储器中读，数据存储器</li><li>Wr（写寄存器）：将数据写到寄存器中，寄存器堆写口</li></ul><ol><li><p>单周期指令模型与流水模型的性能比较</p><ul><li>假定以下每步操作所花时间为<ul><li>取值：2ns</li><li>寄存器读：1ns</li><li>ALU操作：2ns</li><li>存储器读：2ns</li><li>寄存器写：1ns</li><li>Load指令执行时间总计为8ns（假定控制单元、PC访问、信号传递无延迟）</li></ul></li><li>单周期模型<ul><li>每条指令在一个时钟周期完成</li><li>时钟周期等于最长的lw指令的执行时间，即8ns</li><li>串行执行时，N条指令的执行时间为8Nns</li></ul></li><li>流水线性能<ul><li>时钟周期等于最长阶段所花时间2ns</li><li>每条指令执行时间为2ns×5&#x3D;10ns</li><li>N条指令执行时间为(4+N)×2ns</li><li>在N很大时，比串行方式提高至4倍</li><li>若各阶段操作均衡（例如均为2ns），则提高至5倍</li></ul></li><li>流水线方式下，单条指令执行时间不能缩短，但能大大提高指令吞吐率</li></ul></li><li><p>具有哪些特征的指令集有利于流水线执行（四个特征）</p><ul><li><p>长度尽量一致，有利于简化取指令和指令译码操作</p><p>MIPS指令32位，下址计算方便：PC+4</p></li><li><p>格式少，且源寄存器位置相同，有利于在指令未知时就可取操作数</p><p>MIPS指令的rs与rt位置一定，在指令译码时可读rs和rt的值</p></li><li><p>Load&#x2F;Store指令才能访问存储器，有利于减少操作步骤，规整流水线</p></li><li><p>内存中“对齐”存放，有利于减少访存次数和流水线的规整</p></li></ul></li><li><p>能对常见的7条指令的各个流水阶段的划分及其所使用的功能部件情况进行分析</p><ul><li><p>R-type</p><p>若含Load指令，4个阶段的R-type会发生结构冒险（同时使用写口）</p><p>改进R-type，使其每条指令有相同多个阶段</p><p>![image-20220613222311688](C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220613222311688.png)</p><p>加一个NOP阶段以延迟“写”操作</p></li><li><p>Store</p><p>![image-20220613222354290](C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220613222354290.png)</p><ul><li>Ifetch：取指令并计算PC+4</li><li>Reg&#x2F;Dec：从寄存器取数，同时指令在译码器进行译码</li><li>Exec：16位立即数符号拓展后与寄存器值相加，计算主存地址</li><li>Mem：将寄存器读出的数据写到主存</li><li>Wr：加一个空的写阶段，使流水线更规整</li></ul></li><li><p>Beq</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220613222618197.png" srcset="/img/loading.gif" lazyload alt="image-20220613222618197" style="zoom:80%"><ul><li><p>Ifetch：取指令并计算PC+4</p></li><li><p>Reg&#x2F;Dec：从寄存器取数，同时指令在译码器进行译码</p></li><li><p>Exec：执行阶段</p><p>ALU中比较两个寄存器的大小（做减法）</p><p>Adder中计算转移地址</p></li><li><p>Mem：如果比较相等，则转移目标地址写到PC</p></li><li><p>Wrap：加一个空写阶段，使流水线更规整</p></li></ul></li></ul></li><li><p>对于五阶段流水线数据通路，能分析7条指令执行时的各流水段寄存器存储了哪些信息</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220613223102575.png" srcset="/img/loading.gif" lazyload alt="image-20220613223102575" style="zoom:67%"><ul><li>IF&#x2F;ID：PC+4，指令</li><li>ID&#x2F;Ex：R[Rs]，R[Rt]，Rt，Rd，imm16，func，PC+4</li><li>Ex&#x2F;Mem：转移目标地址、Zero、Over、ALUout、Rw</li><li>Mem&#x2F;Wr：ReadData、ALUout、Rw</li></ul></li></ol><p><strong>二、流水线冒险处理</strong></p><ol><li><p>什么是流水线冒险，它分为哪些类型</p><ul><li>流水线冒险：在指令流水线中，当遇到某些情况使得流水线无法正确执行后续指令，而引起流水线阻塞或停顿</li><li>冒险原因不同<ul><li>结构冒险</li><li>数据冒险</li><li>控制冒险</li></ul></li></ul></li><li><p>结构冒险的现象是什么？如何处理结构冒险</p><ul><li>现象：同一个部件同时被不同指令所用，即使用硬件资源时发生了冲突</li><li>解决方法<ul><li>每个部件安排在特定阶段使用</li><li>将Instruction Memory和Data Memory分开</li><li>将寄存器读口与写口独立开来</li></ul></li></ul></li><li><p>数据冒险的现象是什么？分析何时数据冒险，并给出解决方法</p><ul><li><p>现象：后面指令用到前面指令结果时，前面指令的结果还没产生</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220613234228378.png" srcset="/img/loading.gif" lazyload alt="image-20220613234228378" style="zoom:50%"></li><li><p>解决方法</p><ul><li>硬件阻塞（stall）</li><li>软件插入”Nop“指令（浪费空间和时间，无需改数据通路）</li><li>合理实现寄存器组的读&#x2F;写操作：前半时钟周期写，后半时钟周期读</li><li>转发技术：把数据从流水段寄存器中直接取到ALU的输入端，称为转发或旁路</li><li>编译优化——调整指令顺序（不能解决所有数据冒险）</li></ul></li><li><p>Load-use数据冒险：DM读出内容不能直接转发，需要被阻塞一个时钟或加NOP指令</p></li></ul></li><li><p>控制冒险的现象是什么？了解常见的四种处理方法</p><p>PPT省去了对于异常或中断控制冒险的处理，仅考虑分支指令的控制冒险</p><ul><li><p>现象：当遇到改变指令执行顺序的转移指令（调用、返回等）、异常和中断情况时，在形成转移目的地址之前，流水线中已取了后续指令并在执行，这时就需要清除流水线中的部分指令的执行</p></li><li><p>延迟损失时间片C：发生转移时，给流水线带来的延迟损失</p></li><li><p>处理方法</p><ul><li><p>硬件上阻塞（stall）分支指令后续若干指令的执行</p><p>指令清0或操作信号清0，即插入气泡</p></li><li><p>软件上插入“NOP”指令</p></li><li><p>分支预测（Predict）</p><ul><li><p>简单（静态）预测：</p><ul><li><p>总是预测条件不满足，即继续执行分支指令后续指令</p></li><li><p>可加启发式规则：在特定情况下总是预测满足，其他情况总是预测不满足</p><p>如：循环顶部分总是预测为不满足，则能达65%-85%的预测准确率</p></li></ul></li><li><p>动态预测：根据程序执行的历史情况进行动态预测调整，能达90%预测准确率</p></li></ul></li><li><p>延迟分支：把分支指令前面与分支指令无关的指令调到分支指令后进行</p></li></ul></li></ul></li></ol><h3 id="第七章-存储器分层体系结构"><a href="#第七章-存储器分层体系结构" class="headerlink" title="第七章 存储器分层体系结构"></a>第七章 存储器分层体系结构</h3><p><strong>一、存储器概述和存储器芯片</strong></p><ol><li><p>熟悉随机存取存储器、顺序存取存储器、直接存取存储器、相联存储器、只读存储器、读写存储器、非易失（不挥发）性存储器、易失（挥发）性存储器、静态存储器、动态存储器这些名称的含义</p><ul><li><p>按工作方式&#x2F;存取方式分类</p><ul><li><p>随机存取存储器 RAM</p><p>每个单元读写时间一样，且与各单元所在位置无关，如：内存</p><p>（目前的DRAM芯片采用行缓冲，可能因位置不同而使访问时间有所差别）</p></li><li><p>顺序存取存储器 SAM</p><p>数据按顺序从存储载体的始端读出或写入，因而存取时间的长短与信息所在位置有关，如：磁带</p></li><li><p>直接存取存储器 DAM</p><p>直接定位到读写读写数据块，在读写数据块时按顺序进行，如：磁盘</p></li><li><p>相联存储器 AM或CAM</p><p>按内容检索到存储位置进行读写，如：快表</p></li></ul></li><li><p>按信息的可更改性分类</p><ul><li><p>读写存储器（Read&#x2F;Write Memory）：可读可写</p><ul><li>静态存储器SRAM（用作Cache）<ul><li>每个存储单元由6个晶体管组成</li><li>只要加上电源，信息就能一直保持</li><li>对电器干扰相对不敏感</li><li>比DRAM更快，也更贵</li></ul></li><li>动态存储器DRAM（用作主存储器）<ul><li>每个存储单元由1个电容和1个晶体管组成</li><li>每隔一段时间必须刷新一次</li><li>对电器干扰比较敏感</li><li>比SRAM慢，但便宜</li></ul></li></ul></li><li><p>只读存储器（Read Only Memory）：只能读不能写</p><ul><li>不可改写内容的ROM</li><li>闪存（Flash Rom）（用作BIOS）</li></ul></li></ul></li><li><p>按断电后信息的可保存性分类</p><ul><li><p>非易失（不挥发）性存储器</p><p>信息可一直保留，不需电源维持，如：ROM、磁表面存储器、光存储器等</p></li><li><p>易失（挥发）性存储器</p><p>电源关闭时信息自动丢失，如：RAM、Cache</p></li></ul></li></ul></li><li><p>层次结构存储系统中的寄存器、高速缓存、内存(主存)、外存它们所在的位置、工作速度、存储容量、成本等的相对大小和大致的数量级以及这些存储器和前述各类存储器之间的对应关DRAM的集中刷新、分散刷新和异步刷新的刷新操作与正常访存分别是如何安排的</p><ul><li><p>按功能&#x2F;容量&#x2F;速度&#x2F;所在位置分类</p><ul><li><p>寄存器（Register）</p><ul><li><p>封装在CPU内，用于存放当前执行的指令和使用的数据</p></li><li><p>用触发器实现，速度快，容量小（几~几十个KB）</p></li></ul></li><li><p>高速缓存（Cache）</p><ul><li>位于CPU内部或附近，用来存放当前要执行的局部程序段或数据</li><li>用SRAM实现，速度可与CPU匹配，容量小（几MB）</li></ul></li><li><p>内存储器MM（主存储器，Main Memory）</p><ul><li>位于CPU之外，用来存放已被启动的程序及所用的数据</li><li>用DRAM实现，速度较快，容量较大（几GB）</li></ul></li><li><p>外存储器AM （辅助存储器，Auxiliary Storage）</p><ul><li>位于主机之外，用来存放暂不运行的程序、数据或存档文件</li><li>用磁表面或光存储器实现，容量大而速度慢</li></ul></li></ul></li><li><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614094034974.png" srcset="/img/loading.gif" lazyload alt="image-20220614094034974" style="zoom:50%"></li></ul></li><li><p>静态存储器和动态存储器的基本工作机制；动态存储器刷新的概念，按行刷新的含义。最大刷新周期的确定的依据是什么</p><ul><li><p>六管静态MOS管电路</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614094536313.png" srcset="/img/loading.gif" lazyload alt="image-20220614094536313" style="zoom:50%"></li><li><p>动态单管记忆单元电路</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614094615872.png" srcset="/img/loading.gif" lazyload alt="image-20220614094615872" style="zoom:50%"></li><li><p>SRAM：字片式存储体阵列组织</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614094859172.png" srcset="/img/loading.gif" lazyload alt="image-20220614094859172" style="zoom:50%"><ul><li>单方向译码，一维地址驱动</li><li>存储体每一行构成多位的一个存储字，一起被读写</li><li>每列由相同位构成，共用一个读写电路，有多个读写电路</li><li>在位方向上便于扩充</li></ul></li><li><p>DRAM：位片式存储体阵列组织</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614095118548.png" srcset="/img/loading.gif" lazyload alt="image-20220614095118548" style="zoom:50%"><ul><li>双方向译码，二维地址驱动</li><li>芯片阵列由行和列排列而成，每次只能读写行、列交叉处的一位数据</li><li>每个芯片只有一位读写电路</li><li>在字和位上都能扩充，但需有片选信号</li></ul></li><li><p>DRAM芯片的刷新</p><ul><li><p>原因：动态存储器依靠电容电荷存储信息，无电源供电，时间一长电容电荷会泄漏，需定期向电容补充电荷，以保持信息不变</p></li><li><p>含义：定期向电容补充电荷，即刷新</p></li><li><p>刷新周期：从上次对整个存储器刷新结束到下次对整个存储器全部刷新一遍为止的时间间隔，也就是相邻两次对某个特定行进行刷新的时间间隔</p><p>刷新周期取电容上数据有效保存时间的上限，一般为10ms～100ms，目前多数情况下是64ms</p></li></ul></li><li><p>DRAM的刷新方式</p><ul><li><p>集中刷新：在刷新周期内集中安排所有行的刷新</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614100806017.png" srcset="/img/loading.gif" lazyload alt="image-20220614100806017" style="zoom:50%"></li><li><p>分散刷新：各行的刷新分散安排在每个存取周期中</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614100926907.png" srcset="/img/loading.gif" lazyload alt="image-20220614100926907" style="zoom:50%"></li><li><p>异步刷新：各行刷新分散安排在一个刷新周期内，每隔一段时间刷新一行</p><p>例如：64ms&#x2F;4096行≈15.6微秒，平均15.6us提一次刷新请求刷新1行，64ms内刷新完片内所有行</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614101148667.png" srcset="/img/loading.gif" lazyload alt="image-20220614101148667" style="zoom:50%"></li></ul></li><li><p>CPU与存储器之间的通信方式</p><ul><li>异步方式过程（需握手信号）（读操作为例，写操作类似）<ul><li>CPU送地址到地址线，主存进行地址译码</li><li>CPU发读命令，然后等待存储器发回“完成”信号</li><li>主存收到读命令后开始读数，完成后发“完成”信号给CPU</li><li>CPU接收到“完成”信号，从数据线取数</li></ul></li><li>同步方式<ul><li>CPU和主存由统一时钟信号控制，无需应答信号（如“完成”）</li><li>主存总是在确定的时间内准备好数据</li><li>CPU送出地址和读命令后，总是在确定的时间取数据</li><li>存储器芯片必须支持同步方式，如<strong>SDRAM</strong>芯片</li></ul></li></ul></li></ul></li><li><p>了解SDRAM芯片中的突发传输方式</p><ul><li><p>SDRAM芯片技术</p><ul><li><p>SDRAM芯片是同步存储芯片</p></li><li><p>每步操作都在系统时钟控制下进行</p></li><li><p>有确定的等待时间（读命令开始到数据线的有效时间）CL</p><p>例如CL&#x3D;2clks</p></li><li><p>利用总线时钟上升沿与下降沿同步传送</p></li><li><p>多体（缓冲器）交叉存取</p></li><li><p>一个时钟连续传送多个数据（突发传输方式）</p><p>可为1，2，4，8个，分别对应SDRAM、DDR SDRAM、DDR2 SDRAM和DDR3 SDRAM</p></li></ul></li></ul></li></ol><p><strong>二、存储器容量的扩展及其与CPU的连接</strong></p><ol><li><p>位扩展、字扩展、字位扩展方式，系统存储容量的计算，芯片数的计算；这几种扩展方式下的芯片(组)与片选信号的地址线分配；各芯片(组)的地址范围的计算、划分。片选信号用地址信号表示的逻辑表达式。</p><ul><li><p>字扩展（位数不变，扩充容量）</p><blockquote><p>例题：用16K×8位芯片扩成64K×8位存储器需几个芯片？地址范围各为什么？</p><blockquote><p>字方向拓展4倍，需4个芯片，每个芯片有14位地址</p><p>$64KB&#x3D;2^{16}$，故地址共需16位</p><p>地址范围分别为：0000-3FFFFH，4000-7FFFH，8000-BFFFH，C000-FFFFH</p><p>地址高两位由外部译码器译码生成4个输出，分别连到4个芯片的片选信号端</p><p>地址的低14位连到各芯片作为片内地址</p><p>地址线、读&#x2F;写控制线等对应相接，片选信号连译码输出</p></blockquote></blockquote></li><li><p>位扩展（字数不变，位数扩展）（位扩展无需片选信号）</p><blockquote><p>例题：用4096×1位芯片构成4K×8位存储器需几个芯片？地址范围各是多少？</p><blockquote><p>位方向扩展8倍，字方向无需扩展</p><p>需要8个芯片，地址范围都一样：000-FFFH，地址共12位，全部作为片内地址</p><p>芯片的地址线及读&#x2F;写控制线对应相接，而数据线单独引出</p></blockquote></blockquote></li><li><p>字位同时扩展（字和位同时扩展）</p><blockquote><p>例题：16K×4位芯片构成64K×8位存储器需几个芯片，地址范围各是多少？</p><blockquote><p>字向4倍，位向2倍，8个芯片</p><p>各芯片地址范围：0000-3FFFFH，4000-7FFFFH，8000-BFFFFH，C000-FFFFH</p></blockquote></blockquote></li><li><p>存储器芯片扩展例题</p><blockquote><p>例题：用1K×4的芯片组成容量为4K×8的存储器。系统地址总线A15～A0（低）,双向数据总线D7～D0（低）,读&#x2F;写信号线R&#x2F;W。给出芯片内部地址分配与片选逻辑,并画出存储器框图。</p><ol><li><p>计算芯片数</p><p>先扩展位再扩展字</p><p>先扩展字再扩展位</p><p>均需8片</p></li><li><p>地址分配与片选逻辑</p><p>存储空间分配：4KB存储器可以在16位地址空间（64KB）中占据任意4KB的连续区间</p><p>$4KB&#x3D;2^{12}$，需12位地址，其中A11、A10为片选信号</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614104935448.png" srcset="/img/loading.gif" lazyload alt="image-20220614104935448" style="zoom:50%"><p>低位分配给芯片，高位地址形成片选逻辑</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614105024291.png" srcset="/img/loading.gif" lazyload alt="image-20220614105024291" style="zoom:67%"></li><li><p>线路连接</p><ul><li>扩展位数</li><li>扩展字数</li><li>连接控制线</li><li>片选逻辑电路</li></ul><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614110111824.png" srcset="/img/loading.gif" lazyload alt="image-20220614110111824" style="zoom:50%"></li></ol></blockquote></li></ul></li></ol><p><strong>三、高速缓冲存储器(Cache)</strong>(空间局部性、时间局部性)</p><ol><li><p>直接映射、全相联映射、组相联映射三种方式的映射关系；三种方式下的主存地址与cache的行、内容之间的对应关系；cache容量的计算方法，注意区分数据区、标记、有效位</p><ul><li><p>直接映射（模映射）</p><ul><li><p>把主存的每一块映射到一个固定的Cache行</p><p>Cache行号&#x3D;主存行号 mod Cache行数（块与行均从0开始编号）</p><p>例如4&#x3D;100 mod 16，即主存第100块应映射到Cache的第4行中</p></li><li><p>特点</p><ul><li>容易实现，命中时间短</li><li>无需考虑淘汰替换问题</li><li>但不够灵活，Cache存储空间得不到充分利用，命中率低</li></ul></li><li><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614112535466.png" srcset="/img/loading.gif" lazyload alt="image-20220614112535466" style="zoom:67%"><p><strong>tag为块群号</strong></p></li><li><p>Cache有效位</p><ul><li>1表示信息有效，0表示信息无效</li><li>开机或复位时，使所有行的有效位V&#x3D;0</li><li>某行被替换后使其V&#x3D;1</li><li>某行装入新块时使其V&#x3D;1</li><li>通过使V&#x3D;0来冲刷Cache</li><li>通常为操作系统设置“cache冲刷”指令，因此cache对操作系统程序员不是透明的</li></ul></li><li><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614113655358.png" srcset="/img/loading.gif" lazyload alt="image-20220614113655358" style="zoom:67%"></li><li><p>映射行计算</p><ul><li>地址&#x2F;块大小得到块数后mod行数</li><li>由地址，最后是块内地址，中间是Cache行数，前面是主存标记（所在主存块）</li></ul></li><li><p>Cache容量计算</p><p>容量&#x3D;行数×(1+块群数)+数据</p><p>​ &#x3D;行数×(1+块群数+块大小)</p><p>块群数&#x3D;主存地址数&#x2F;块大小&#x2F;行数（取商）</p></li></ul></li><li><p>全相联映射</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614132504643.png" srcset="/img/loading.gif" lazyload alt="image-20220614132504643" style="zoom:67%"><p><strong>tag为主存块号</strong></p><p>同时比较所有Cache行的标志</p><p>没有冲突缺失，只要有空闲的Cache行都不会发生冲突</p></li><li><p>组相联映射</p><p>将Cache所有行分组，每个主存块只能映射到Cache的某固定组，但可映射该组的任一行</p><p><strong>组间模映射，组内全映射</strong></p><p>Cache组号&#x3D;主存块号 mod Cache组数</p><p>每组的行数称为路，有2路组相连映射等</p><ul><li>特点<ul><li>结合直接映射和全相联映射的优点，当Cache组数为1时是全相联映射，当每组只有一行时，就是直接映射</li><li>每组2或4行较常用</li></ul></li></ul><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614172401604.png" srcset="/img/loading.gif" lazyload alt="image-20220614172401604" style="zoom:33%"><p><strong>tag为主存组群号</strong></p><ul><li><p>对于N路相联映射：N个全相联映射的行并行操作</p></li><li><p>Cache索引选择其中一个Cache组</p><p>对这个组的N个Cache行的Tag并行进行比较</p><p>根据比较结果确定信息在哪个行，或不在Cache中</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614174103535.png" srcset="/img/loading.gif" lazyload alt="image-20220614174103535" style="zoom:33%"></li><li><blockquote><p>例题：某计算机的Cache共有16块，采用2路组相联映射方式(即每组包括2块)，存储器按字节编址，每个主存块大小为32字节，那么129号主存单元所在的主存块应装入到的Cache组号是</p><blockquote><p>法一</p><p>129&#x2F;32&#x3D;4</p><p>4 mod 8 &#x3D; 4</p><p>法二（地址法）</p><p>129&#x3D;10000001&#x3D;0…0<strong>10000001</strong>(Cache索引为100)</p></blockquote></blockquote></li></ul></li></ul></li><li><p>CPU对cache的访问时，直接映射采用的是按地址进行查找的方法，而全相联映射采用的是用多个比较器进行同时比对查找到cache的行；组相联映射则结合了上述两种方法，即由地址查找到组，再对组内的各行“标记”用多个比较器进行同时比对。和相联存储器的概念有什么关系？</p></li><li><p>三种映射方式中哪些需要替换算法？了解“先进先出FIFO”和“最近最少用LRU”替换算法。了解写策略中的命中和未命中的处理方式。</p><ul><li><p><strong>组相联映射</strong>与<strong>全相联映射</strong>需考虑替换算法</p></li><li><p><strong>先进先出FIFO</strong></p><p>总是把最先进入的那一块淘汰掉</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614175950535.png" srcset="/img/loading.gif" lazyload alt="image-20220614175950535" style="zoom:33%"></li><li><p><strong>最近最少用LRU</strong></p><p>总是把最近最少用的那一块淘汰掉</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614180530921.png" srcset="/img/loading.gif" lazyload alt="image-20220614180530921" style="zoom:33%"><ul><li><p>具体实现：给每个Cache行设定一个计数器，根据计数值来记录这些主存块的使用情况，LRU位</p></li><li><p>计数器变化规则</p><ul><li>每组4行时，计数器有2位，计数值越小说明越常被使用</li><li>命中时，被访问行的计数器置0，比其原值小的计数器加1，其余不变</li><li>未命中且该组未满时，新行计数器置0，其余全加1</li><li>未命中且该组已满时，计数值为3的那一行中的主存块被替换，该行计数器置为0，其余加1</li></ul><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614180926538.png" srcset="/img/loading.gif" lazyload alt="image-20220614180926538" style="zoom:33%"></li></ul></li><li><p>写策略（Cache与主存一致性问题）</p><ul><li>写命中：要写的单元已经在Cache中<ul><li>Write Through（通过式写、写直达、直写）<ul><li>同时写Cache和主存单元</li><li>大大增加了写的开销</li><li>10%的存储指令使CPI增加得到1.0+100×10%&#x3D;11</li><li>采用写缓存法（Write Buffer），Cache和主存间加缓存</li></ul></li><li>Write Back（一次性写、写回、回写）<ul><li>只写Cache不写主存，缺失时一次写回，每行有个修改位（脏位），大大降低主存带宽需求，控制可能很复杂</li></ul></li></ul></li><li>写不命中：要写的单元不在Cache中<ul><li>Write Allocate（写分配）<ul><li>将主存块装入Cache，然后更新相应单元</li><li>视图利用空间局部性，但每次都要从主存读一个块</li></ul></li><li>Not Write Allocate（非写分配）<ul><li>直接写主存单元，不把主存块装入Cache</li></ul></li></ul></li></ul></li></ul></li></ol><p><strong>四、虚拟存储器</strong></p><ol><li><p>虚拟存储器的基本思想—分页的基本思想（还有分段式、段页式，考试不考）</p><ul><li><p>页（虚页、逻辑页）与页框（实页、物理页）的概念</p><ul><li>页、虚页、逻辑页：每个进程被划分为固定长的程序块</li><li>页框、实页、物理页：内存被分成固定长且比较小的存储块</li><li>程序块可装到内存中可用的存储块中</li><li>无需用连续页框来存放一个进程</li><li>操作系统为每个进程生成一个页表</li><li>通过页表实现逻辑地址向物理地址的转换</li></ul></li><li><p>逻辑地址（虚拟地址）与物理地址（实地址、主存地址）的概念</p><ul><li>逻辑地址：程序中指令所用的地址（进程所在地址空间），也称为虚拟地址（VA）</li><li>物理地址：存放指令或数据的之际内存地址</li></ul></li><li><p>虚拟存储器机制由硬件与操作系统共同协作实现</p><ul><li>逻辑地址转换为物理地址是由硬件(CPU中的存储管理部件)完成，其中虚页号到页框号的转换是通过查表（页表或快表）实现</li><li>当发生程序或数据访问缺页时，由操作系统在主存和磁盘之间进行信息交换</li><li>页表由操作系统管理维护</li></ul></li><li><p>页框与虚拟页之间采用全相联映射，为什么不采用其他映射方式，另外为什么页大小（2KB~64KB）比Cache中的块大小大得多</p><p>因为缺页的开销比Cache缺失开销大得多！缺页时需要访问磁盘（约几百万个时钟周期），而cache缺失时，访问主存仅需几十到几百个时钟周期！因此，页命中率比cache命中率更重要！<strong>“大页面”和“全相联”可提高页命中率</strong></p></li><li><p>在处理页框与虚拟页的一致性问题时采用回写（write back）方式，为什么不采用全写方式</p><p><strong>避免频繁的慢速磁盘访问操作</strong></p></li></ul></li><li><p>页表的基本结构</p><ul><li><p>页表项中的装入位、修改位、存放位置的含义。为什么页表项中没有虚页号</p><ul><li>装入位：用于指示该页是否已调入内存，供程序访问时参考</li><li>修改位：表示该页在调入内存后是否被修改过，供置换页面时参考</li><li>存放位置：用于指出该页在<strong>内存上的地址</strong>，通常是物理页号，供调入该页时参考</li></ul></li><li><p>如何区分未分配页、已分配的缓存页和已分配的未缓存页</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614191145355.png" srcset="/img/loading.gif" lazyload alt="image-20220614191145355" style="zoom:33%"></li></ul></li><li><p>快表——TLB</p><ul><li>快表存储在什么地方？采用快表的目的是什么？<ul><li>快表存储在Cache中</li><li>快表目的：减少到内存查页表次数</li><li><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614192543008.png" srcset="/img/loading.gif" lazyload alt="image-20220614192543008" style="zoom:33%"></li></ul></li><li>快表与页表之间一般采用组相联或全相联映射<ul><li>TLB全相联时，没有index，只有Tag，虚页号需与每个Tag比较</li><li>TLB组相联时，则虚页号高位为Tag，低位为index，用作组索引</li></ul></li><li>快表的表项由页表表项内容+标记(tag)，在全相联和组相联映射方式下标记字段分别是什么内容</li></ul></li><li><p>理解根据虚拟地址，通过TLB、页表、cache的访问过程</p><p>![image-20220614194349906](C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614194349906.png)</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614194719675.png" srcset="/img/loading.gif" lazyload alt="image-20220614194719675" style="zoom:33%"> <img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614200251576.png" srcset="/img/loading.gif" lazyload alt="image-20220614200251576" style="zoom:50%"><blockquote><p>例题：某计算机存储器按字节编址，虚拟(逻辑)地址空间大小为16MB，主存(物理)地址空间大小为1MB，页面大小为4KB;Cache采用直接映射方式，共8行;主存与Cache之间交换的块大小为32B。系统运行到某一时刻时，页表的部分内容和Cache的部分内容分别如图所示，图中页框号及标记字段的内容为十六进制形式。</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614195001314.png" srcset="/img/loading.gif" lazyload alt="image-20220614195001314" style="zoom:67%"><p>请回答下列问题。</p><p>(1)虚拟地址共有几位，哪几位表示虚页号?物理地址共有几位，哪几位表示页框号(物理页号)?</p><p>(2)使用物理地址访问Cache时，物理地址应划分成哪几个字段?要求说明每个字段的位数及在物理地址中的位置。</p><p>(3)虚拟地址001C60H所在的页面是否在主存中?若在主存中，则该虚拟地址对应的物理地址是什么?访问该地址时是否Cache命中?要求说明理由。</p><p>(4)假定为该机配置一个4路组相联的TLB，该TLB共可存放8个页表项，若其当前内容(十六进制)如题44-c图所示，则此时虚拟地址024BACH所在的页面是否在主存中?要求说明理由。</p><ul><li><p>虚拟空间16MB，因此虚拟地址有24位</p><p>物理地址1MB，因此物理地址有20位</p><p>页面4KB，因此页内地址有12位</p><p>因此在虚拟地址中，高12位为虚页号，低12位为页内地址</p><p>在物理地址中，高8位为页框号，低12位为页内地址</p></li><li><p>因为是直接映射方式，20位物理地址被划分为高12位为主存标记（块群号）后3位为Cache行号低5位为块内地址</p></li><li><p>虚拟地址001C60H&#x3D;0000 0000 0001 1100 0110 0000B，故虚页号0000 0000 0001B，查看001H处的页表项，其对应有效位为1，故其所在的页面在主存</p><p>页框号为04H，故其物理地址为0000 0100 1100 <strong>011</strong>0 0000B&#x3D;04C60H，所在主存块只能映射到第3行，由于该行有效位为1，标记值为105H≠04CH，故访问该地址Cache不命中</p></li><li><p>虚拟地址024BACH&#x3D;0000 0010 0100 1011 1010 1100B，故虚页号为0000 00100100B;由于TLB只有8&#x2F;4&#x3D;2个组，故虚页号中高11位为TLB标记，最低1位为TLB组号，它们的值分别为0000 0010 010B(即012H)和0B，因此，该虚拟地址所对应物理页面只可能映射到TLB的第0组，由于组0中存在有效位为1、标记为012H的项，所以访问TLB命中，即虚拟地址024BACH所在的页面在主存中</p></li></ul></blockquote></li></ol><h3 id="第八章-互连及输入输出组织"><a href="#第八章-互连及输入输出组织" class="headerlink" title="第八章 互连及输入输出组织"></a>第八章 互连及输入输出组织</h3><p><strong>一、I&#x2F;O系统与I&#x2F;O设备</strong></p><ol><li><p>I&#x2F;O系统性能能指标</p><ul><li>吞吐率(I&#x2F;O带宽)：单位时间从系统输入&#x2F;输出多少数据（或单位时间实现多少次输入&#x2F;输出操作）</li><li>响应时间：在多长时间内完成请求的任务</li></ul></li><li><p>外设的通用模型以及各部分作用</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220610130907749.png" srcset="/img/loading.gif" lazyload alt="image-20220610130907749" style="zoom:50%"><ul><li>通过<strong>电缆</strong>与计算机内部I&#x2F;O接口进行数据、状态和控制信息的传送</li><li><strong>控制逻辑</strong>根据控制信息控制设备的操作，并检测设备状态</li><li><strong>缓冲器</strong>用于保存交换的数据信息</li><li><strong>变换器</strong>用于实现电信号形式（内部数据）与其他形式的设备数据之间的转换</li><li>电缆线中三种控制信号：<strong>控制信号、状态信号、数据信号</strong></li></ul></li><li><p>磁盘上的数据定位（地址）：磁道号、磁头号、扇区号</p><p>磁盘数据的存取以块（扇区）为单位</p><p>磁盘操作：所有磁头同步寻道（磁道号）、选择磁头（磁头号）、旋转等待（扇区号）、读写</p><ul><li><p>磁道：磁盘表面被分为许多同心圆，每个同心圆称为一个磁道</p><p>每个磁道都有一个编号，最外面的是0磁道</p></li><li><p>扇区：每个磁道被划分为若干段（段又叫扇区）</p><p>每个扇区的存储容量为512字节，每个扇区都有一个编号（近几年有4096字节扇区）</p></li></ul></li><li><p>磁盘信息记录密度（高密度磁盘比低密度磁盘容量大很多）</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220610140146676.png" srcset="/img/loading.gif" lazyload alt="image-20220610140146676" style="zoom:50%"><ul><li><p>低密度磁盘：</p><p>各个磁道上的扇区数相同</p><p>每个磁道存储的数据量相同</p><p>内磁道的位密度比外磁道高</p></li><li><p>高密度磁盘：</p><p>各个磁道上的位密度相同</p><p>各磁道存储的数据量不同</p><p>外磁道的扇区数比内磁道多</p></li></ul></li><li><p>磁盘容量的计算（低密度存储方式）</p><ul><li><p>未格式化容量计算</p><p>$磁盘总容量&#x3D;记录面数\times 理论柱面数\times 内圆周长\times 位密度$</p><ul><li>$理论柱面数&#x3D;(有效记录区外径-有效记录区内径)\div2\times道密度$</li></ul></li><li><p>格式化容量计算</p><p>$磁盘实际数据容量&#x3D;2\times盘片数\times 磁道数&#x2F;面\times扇区数&#x2F;磁道\times512B&#x2F;扇区$</p><p>(根据实际记录面数）</p></li><li><blockquote><p>例题：假设一个有3个盘片的硬盘，共有4个记录面，转速为7200&#x2F;分钟，盘面有效记录区域的外直径为30cm，内直径为10cm，记录位密度为250bit&#x2F;mm，磁道密度为8道&#x2F;mm，每个磁道分16扇区，每扇区512字节。</p><blockquote><p>$总磁道数&#x3D;4*(30-10)<em>10&#x2F;2</em>8&#x3D;3200$<br>$非格式化容量&#x3D;3200*(3.14<em>10</em>10)<em>(250&#x2F;8)B&#x3D;29.95MB$<br>$格式化容量&#x3D;3200</em>16*512B&#x3D;25MB$</p></blockquote></blockquote></li></ul></li><li><p>硬盘的主要技术指标：平均存储时间$T$及其计算</p><ul><li><p>$T&#x3D;平均寻道时间+平均旋转等待时间+数据传输时间$</p></li><li><p>$磁盘响应时间&#x3D;平均存储时间T+磁盘控制器开销+排队时间$</p></li><li><blockquote><p>例题：假定每个扇区512字节，磁盘转速位5400RPM，声称寻道时间（最大寻道时间的一半）为12ms，数据传输率为4MB&#x2F;s，磁盘控制器开销为1ms，不考虑排队时间，则磁盘响应时间为多少？</p><blockquote><p>$磁盘相应时间&#x3D;12ms+0.5&#x2F;5400RPM*60+0.5KB&#x2F;(4MB&#x2F;s)+1ms+0ms&#x3D;18.6ms$</p></blockquote></blockquote></li></ul></li><li><p>冗余磁盘阵列RAID</p><ul><li><p>基本思想</p><ul><li>将多个独立操作的磁盘按照某种方式组织成磁盘阵列(Disk Array)，以<strong>增加容量</strong></li><li>利用类似于主存中的多体交叉技术，将数据存储在多个盘体上</li><li>通过这些盘并行工作来<strong>提高数据传输速度</strong></li><li>用冗余磁盘技术来进行错误恢复以<strong>提高系统可靠性</strong></li></ul></li><li><p>3个特性</p><ul><li>RAID是一组物理磁盘驱动器，在操作系统下被视为一个单逻辑驱动器</li><li>数据分布在一组物理磁盘上</li><li>冗余磁盘用于存储校验信息，保证磁盘万一损坏时能恢复数据</li></ul></li><li><p>冗余磁盘不同级别的含义</p><p>0-7级，并非简单地表示层次关系，而是表示具有上述3个共同特性的不同设计结构</p></li></ul></li></ol><p><strong>二、总线及系统互连、I&#x2F;O接口</strong></p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220610155402568.png" srcset="/img/loading.gif" lazyload alt="image-20220610155402568" style="zoom:50%"><ol><li><p>总线概述</p><ul><li><p><strong>总线</strong>：在各种层次上提供部件之间的连接和交换信息的通路（点对点、异步、串行）</p><ul><li><p>芯片内总线：在芯片内部各元件之间提供连接</p></li><li><p><strong>系统总线</strong>：在系统主要功能部件（CPU、MM和各种I&#x2F;O控制器）间提供连接</p><p>含处理器总线、存储器总线、I&#x2F;O总线</p><ul><li><p>单总线结构</p><p>将CPU、MM和各种I&#x2F;O适配卡通过底板总线互连，底板总线为标准总线</p></li><li><p>多总线结构</p><p>将CPU、Cache、MM和各种I&#x2F;O适配卡用局部总线、处理器-主存总线、高速I&#x2F;O总线、扩充I&#x2F;O总线等互连</p><ul><li>Processor-Memory Bus：短而快，仅需与内存匹配，使CPU-MM之间达最大带宽</li><li>I&#x2F;O Bus：长而慢，需适应多种设备，一侧连接到Processor-Memory Bus或Backplane Bus，另一侧连到I&#x2F;O控制器</li></ul></li><li><p><strong>系统总线</strong>通常由一组<strong>控制线</strong>、一组<strong>数据线</strong>和一组<strong>地址线</strong>构成</p><p>也有些总线没有单独的地址线，地址信息通过数据线来传送，这种情况称为<strong>数据&#x2F;地址复用</strong></p><ul><li><p>数据线（Data Bus）：承载在源和目的部件之间传输的信息。数据线的宽度反映一次能传送的数据的位数。</p></li><li><p>地址线（Address Bus）：给出源数据或目的数据所在的主存单元或I&#x2F;O端口的地址。地址线的宽度反映最大的寻址空间</p></li><li><p>控制线（Control Bus） ：控制对数据线和地址线的访问和使用。用来传输定时信号和命令信息。典型的控制信号包括：</p><blockquote><p>时钟（Clock）：用于总线同步</p><p>复位（Reset）：初始化所有设备</p><p>总线请求（Bus Request）：表明发出该请求信号的设备要使用总线</p><p>总线允许（Bus Grant）：表明接收到该允许信号的设备可以使用总线</p><p>中断请求（Interrupt Request）：表明某个中断正在请求</p><p>中断回答（Interrupt Acknowledge） ：表明某个中断请求已被接受</p><p>存储器读（memory read）：从指定的主存单元中读数据到数据总线上</p><p>存储器写（memory read）：将数据总线上的数据写到指定的主存单元中</p><p>I&#x2F;O读（I&#x2F;O read）：从指定的I&#x2F;O端口中读数据到数据总线上</p><p>I&#x2F;O写（I&#x2F;O Write） ：将数据总线上的数据写到指定的I&#x2F;O端口中</p><p>传输确认（transmission Acknowledge） ：表示数据已被接收或已送总线</p></blockquote></li></ul></li></ul></li><li><p>通信总线：在主机和I&#x2F;O设备之间或计算机系统之间提供连接（含IDE接口）</p></li><li><p>处理器总线</p><ul><li><p>前端总线FSB</p><blockquote><p>并行传输、同步定时方式</p><p>位于CPU与北桥芯片之间互连</p><p>quad pumped技术：每个总线时钟周期传送4次数据</p><p>即工作频率为实际时钟频率的4倍</p><p>后续随着QPI总线出现不再使用</p><p>例题：若工作频率为1333MHz（实际单位应是MT&#x2F;s，表示每秒传送1333M次数据，实际时钟工作频率为333MHz），总线宽度为64位，求总线带宽</p><blockquote><p>$总线带宽&#x3D;1333MT&#x2F;s\times8B&#x3D;10.5GB&#x2F;s$</p></blockquote></blockquote></li><li><p>QPI总线（目前使用）</p><blockquote><p>主存控制器集成到芯片，主存不需要通过北桥，直接与CPU相连</p><p>基于包交换的串行、高速点对点连接，每个QPI数据包长80位</p><p>发送方和接收方有各自时钟信号，总线有20条数据线</p><p>每条数据线为一个双向的串行传输通道，因此双方都有20个传输通道</p><p>一个时钟周期传两次，故一个方向每次可传20位，其中16位数据，4位校验位</p><p>$QPI总线带宽&#x3D;每秒传送次数\times 2B\times 2$(方向)</p><p>工作频率GT&#x2F;s，表示每秒传送G次</p><p>例题：时钟频率为2.4GHz，求QPI带宽</p><blockquote><p>$QPI带宽&#x3D;2.4GHz\times 2\times 2B\times2&#x3D;4.8GT&#x2F;s\times2B\times2&#x3D;19.2GB&#x2F;s$</p></blockquote></blockquote></li></ul></li><li><p>存储器总线：Core i7开始主存直接与CPU相连，3个存控</p><p>总线宽64位，速度为1333MT&#x2F;s</p><p>总带宽为$3\times8B\times1333M&#x3D;32GB&#x2F;s$</p></li><li><p>I&#x2F;O总线：用于为系统中的各种I&#x2F;O设备提供输入输出通道</p><p>在物理上可以是主板上的I&#x2F;O扩展槽，如PCI-Express</p><ul><li><p>PCI-Express</p><p>串行总线，主流总线</p><p>两个PCI-Express设备之间以一个链路（link）相连</p><p>每个链路包含多条通路（lane），可以是1,2,4,8,16或32条</p><p>PCI-Express×n表示一个具有n条通路的PCI-Express链路</p><p>每条通路可同时发送和接受，每个数据字节被转换为10位信息被传输</p><p>PCI-Express1.0下，每条通路的发送和接受速率都是2.5Gb&#x2F;s，故PCI-Express×n的带宽为：$2.5Gb&#x2F;s×2×n&#x2F;10&#x3D;0.5GB&#x2F;s×n$</p></li><li><p>I&#x2F;O设备通常是物理上相互独立的设备，一般通过通信总线与I&#x2F;O控制器相连</p><p>I&#x2F;O控制器（I&#x2F;O接口）通过扩充卡或者南桥芯片与I&#x2F;O总线连接</p><p>I&#x2F;O总线经过北桥芯片与内存、CPU相连</p></li></ul></li></ul></li><li><p>总线的性能指标</p><ul><li><p>总线宽度：总线中数据线的条数，决定了每次能同时传输的信息位数</p></li><li><p>总线的工作频率：现在的总线一个时钟周期可以传送2次或4次数据</p></li><li><p>总线带宽：总线的最大数据传输率</p><p>同步总线，总线带宽计算公式： $B&#x3D;W\times F\div N$</p><p>$W$-总线宽度，$F$-总线时钟频率，$N$-完成一次数据传送所用的时钟周期数</p><p>$F\div N$实际就是总线工作频率</p></li></ul></li></ul></li><li><p>I&#x2F;O接口：I&#x2F;O设备控制器及其插座（如网卡、显卡、键盘适配器、磁盘控制器）</p><ul><li><p>5大功能</p><ul><li><p>数据缓冲</p><p>提供数据缓冲寄存器，以达到主机和外设工作速度的匹配</p></li><li><p>错误或状态检测</p><p>提供状态寄存器，以保存各种错误或状态信息供CPU查用</p></li><li><p>控制和定时</p><p>提供控制和定时逻辑，以接收从系统总线来的控制定时信号</p></li><li><p>数据格式转换</p><p>提供数据格式转换部件，使通过外部接口得到的数据转换为内部接口需要的格式，或在相反的方向进行数据格式转换</p></li><li><p>与主机和设备通信</p><p>上述功能通过I&#x2F;O接口与主机之间、I&#x2F;O接口与设备之间的通信来完成</p></li></ul></li><li><p>通用结构</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220610172526467.png" srcset="/img/loading.gif" lazyload alt="image-20220610172526467" style="zoom:50%"><p>通过发送命令字到I&#x2F;O控制寄存器来向设备发送命令</p><p>通过从状态寄存器读取状态字来获取外设或I&#x2F;O控制器的状态信息</p><p>通过向I&#x2F;O控制器发送或读取数据来和外设进行数据交换</p><p>将I&#x2F;O控制器中CPU能够访问的各类寄存器称为I&#x2F;O端口</p><p>对外设的访问通过向I&#x2F;O端口发命令、读状态、读&#x2F;写数据来进行</p></li></ul></li><li><p>I&#x2F;O端口的编址方式</p><ul><li><p>统一编址方式（内存映射方式）</p><p>与主存空间统一编址，将主存空间分出一部分地址给I&#x2F;O端口进行编号</p><ul><li><p>CPU不直接通过读写控制信号$\overline{IOR}、\overline{IOW}$对I&#x2F;O端口读写，而是地址译码实现</p></li><li><p>地址线高位参与片选控制逻辑</p></li><li><p>无需设置专门I&#x2F;O指令，访存指令即可存取I&#x2F;O端口</p></li></ul></li><li><p>独立编址方式（使用专门I&#x2F;O指令方式）</p><p>不和主存单元一起编号，而是独立编号，成为一个独立的I&#x2F;O地址空间</p><ul><li><p>通过不同的读写控制信号$\overline{IOR}、\overline{IOW}$对I&#x2F;O端口读写</p></li><li><p>一般I&#x2F;O端口比存储器单元少，所以选择I&#x2F;O端口只需要少量地址线</p></li><li><p>指令系统必须设计专门的I&#x2F;O指令</p></li></ul></li></ul></li></ol><p><strong>三、I&#x2F;O数据传送控制方式</strong></p><ol><li><p>程序直接控制方式</p><ul><li><p>无条件传送：对简单外设定时（同步）进行数据传送</p></li><li><p>条件传送：Polling（轮询，查询），程序查询方式</p><p>I&#x2F;O设备将自己的状态放到一个状态寄存器</p><p>OS阶段性地查询状态寄存器中的特定状态，以决定下一步动作</p></li></ul><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220610191339605.png" srcset="/img/loading.gif" lazyload alt="image-20220610191339605" style="zoom:50%"><ul><li>特点<ul><li>简单、易控制、外围接口控制逻辑少</li><li>CPU与外设串行工作，效率低，速度慢，适用于慢速设备</li><li>查询开销极大（CPU在等待外设完成）</li></ul></li><li>工作方式：完全串行工作方式或部分串行，CPU用100%的时间为I&#x2F;O服务</li></ul></li><li><p>中断I&#x2F;O方式</p><ul><li>基本思想：当外设准备好时，便向CPU发中断请求，CPU响应后，中止现行程序的执行，转入一个“中断服务程序”进行输入&#x2F;出操作，实现主机和外设接口之间的数据传送，并启动外设工作。 “中断服务程序”执行完后，返回原被中止的程序断点处继续执行。此时，外设和CPU并行工作</li></ul><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220610192255974.png" srcset="/img/loading.gif" lazyload alt="image-20220610192255974" style="zoom:50%"><ul><li><p>外部“中断“：在CPU外部发生的特殊事件，通过“中断请求”信号向CPU请求处理</p><ul><li><p>与异常的区别</p><ul><li><p>产生源不相同，<strong>异常是由CPU产生的</strong>（非法指令，地址越界）</p><p><strong>中断是由硬件设备产生的</strong>（磁盘中断，打印机中断）</p></li><li><p>异常是CPU产生的，所以是时钟同步的</p><p>中断是异步的，这意味着中断可能随时到来</p></li><li><p>异常是由于执行了现行指令所引起的，由于系统调用引起的中断属于异常</p><p>中断则是由于系统中某事件引起的，该事件与现行指令无关，但在指令结束后响应</p></li></ul></li><li><p>中断过程：中断检测、中断响应和中断处理</p><ul><li><p>中断响应：调出相应的中断服务程序（处在禁止中断状态）</p><p>主机发现外部中断请求，中止现行程序的执行，到调出中断服务程序这一过程</p><ul><li><p>条件</p><p>① CPU处于开中断状态</p><p>② 在一条指令执行完</p><p>③至少要有一个未被屏蔽的中断请求</p></li><li><p>响应过程：执行一条隐指令，需完成一次总线操作，从总线上取中断类型号</p><p>①关中断（0–&gt;中断允许触发器）</p><p>②保护断点（PC、PSW–&gt;堆栈)</p><p>③识别中断源（中断服务程序首地址–&gt;PC，初始PSW–&gt;PSWR）</p><ul><li><p>中断向量表：从总线的数据线上取得中断类型号后得到中断服务程序首址（向量中断）</p><p>$向量地址&#x3D;中断类型号×4$</p><p>中断类型号由中断控制器中的“<strong>中断优先权编码器</strong>” 专门用来进行中断源识别</p></li><li><p>或直接转中断查询程序（软件查询）</p></li></ul></li></ul></li><li><p>中断处理：执行相应中断服务程序的过程</p><ul><li><p>不同的中断源其对应的中断服务程序不同</p></li><li><p>单重中断：不允许在中断处理时被新的中断打断，因而直到中断返回前才会开中断</p><p>单重中断系统无需设置中断屏蔽字</p></li><li><p>多重中断：在一个中断处理（执行中断服务程序）过程中，若有新的中断请求发生， 且新中断优先级高于正在执行的中断，则中止正在执行的中断服务程序，转去处理新的中断。这种情况为多重中断，也称中断嵌套。</p><ul><li>差别：一个允许被打断、一个不允许被打断；一个无屏蔽字，一个有屏蔽字</li></ul></li><li><p>中断处理过程：三个阶段</p><ul><li><p>先行段（准备阶段）（“禁止中断”状态）</p><p>保护现场及旧屏蔽字</p><p>查明原因（软件识别中断时）</p><p>设置新屏蔽字</p><p>开中断</p></li><li><p>本体段（具体的中断处理阶段）（处在“允许中断“状态，可被处理优先级更高的中断打断）</p></li><li><p>结束段（恢复阶段）</p><p>关中断</p><p>恢复现场及旧屏蔽字</p><p>清”中断请求“</p><p>开中断</p><p>中断返回</p></li></ul></li></ul></li></ul></li></ul></li><li><p>中断优先级</p><ul><li><p>中断响应优先级</p><p>由查询程序或硬联排队线路决定的优先权，反映多个中断同时请求时选择哪个响应</p></li><li><p>中断处理优先级</p><p>由各自的中断屏蔽字来动态设定，反应本中断与其他中断间的关系</p></li><li><p>中断优先权的动态分配</p><blockquote><p>例题：假定某中断系统有四个中断源，其响应优先级为1&gt;2&gt;3&gt;4。假定在用户程序时同时发生1、3和4级中断请求，执行3级中断服务程序时发生2级中断请求。分别写出处理优先级为1&gt;2&gt;3&gt;4和1&gt;4&gt;3&gt;2时各中断的屏蔽字及CPU完成中断处理的过程</p><blockquote><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220611105929919.png" srcset="/img/loading.gif" lazyload alt="image-20220611105929919" style="zoom:50%"> <img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220611105952996.png" srcset="/img/loading.gif" lazyload alt="image-20220611105952996" style="zoom:50%"></blockquote></blockquote></li></ul></li></ul></li><li><p>DMA方式：直接存储器存取（Direct Memory Access)</p><ul><li><p>引入DMA方式原因</p><p>程序直接控制方式受”踏步“现象限制，效率低下</p><p>中断控制方式对I&#x2F;O请求响应慢，数据传送速度慢</p></li><li><p>DMA方式的基本要点</p><ul><li><p>基本思想</p><p>在高速外设和主存间直接传送数据</p><p>由专门硬件（即DMA接口）控制总线进行传输</p></li><li><p>DMA方式适用场合</p><p>高速设备（磁盘光盘等）</p><p>成批数据交换，且数据间的间隔时间短，一旦启动数据连续读写</p></li><li><p>采用”请求-响应“方式</p><p>每当高速设备准备好数据，就进行一次”DMA请求“，DMA控制器接收到DMA请求后，申请总线使用权</p><p>DMA控制器总线使用优先级比CPU高（高速设备可能发生数据丢失）</p></li><li><p>与中断控制方式结合使用</p><p>DMA传送前，寻到旋转等操作结束时，通过中断告知CPU</p><p>在DMA控制器控制总线进行数据传送时，CPU执行其他程序</p><p>DMA传送结束后，要通过”DMA结束中断“告知CPU</p></li></ul></li><li><p>DMA数据传送方式</p><ul><li><p>CPU停止法（成组传送）</p><p>DMA传输时，CPU脱离总线，停止访问主存，直到DMA传完一块数据</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220611113837252.png" srcset="/img/loading.gif" lazyload alt="image-20220611113837252" style="zoom:50%"><ul><li><p>优点：控制简单、适用于传输率很高的外设实现成组数据传送</p></li><li><p>缺点：CPU工作受影响，DMA访问时CPU基本处于停止状态</p><p>主存周期没有被充分利用，即使I&#x2F;O设备高速运行，但两个数据之间准备间隔时间总大于一个周期</p></li><li><p>改进</p><ul><li><p>在DMA接口中引入缓冲器：设置一个小容量高速缓存，I&#x2F;O设备先和缓存交换数据，绕后缓存再使用总线与主存快速交换数据</p></li><li><p>采用周期挪用（窃取）法：DMA传输时，CPU让出一个总线事务周期，由DMA控制器控制总线来访问主存，传送完一个数据后立即释放总线</p><p>挪用一个存储周期进行外设和主存交换一个数据</p></li><li><p>采用时间交替法：每个存储周期分为两个时间片，一个给CPU，一个给DMA</p></li></ul></li></ul></li><li><p>周期挪用（窃取）法（单字传送）</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220611115057767.png" srcset="/img/loading.gif" lazyload alt="image-20220611115057767" style="zoom:50%"><ul><li><p>优点：既能及时响应 I&#x2F;O 请求，又能较好地发挥 CPU 和主存的效率</p><p>这种方式下，在下一数据的准备阶段，主存周期被 CPU 充分利用</p><p>因此适合于 I&#x2F;O 设备的读写周期大于主存周期的情况</p></li><li><p>缺点：每次 DMA 访存都要申请总线控制权、占用总线进行传送、释放总线，增加传输开销</p></li></ul></li><li><p>交替分时访问法</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220611114950237.png" srcset="/img/loading.gif" lazyload alt="image-20220611114950237" style="zoom:67%"><ul><li><p>特点：适用于 CPU 工作周期比主存存取周期更长的情况</p><p>不需要总线使用权的申请和释放</p></li></ul></li></ul></li><li><p>DMA控制器（DMA接口）的功能</p><ul><li>请求：能接收外设发来的”DMA请求“信号，并能向CPU发“总线请求”信号</li><li>响应：当CPU发出“总线响应“信号后，能接管对总线的控制</li><li>发主存地址并修改：能在地址线给出主存地址，并自动修改主存地址</li><li>识别传送方向：能识别传送方向以在控制线上给出正确的读写控制信息</li><li>确定传送数据个数</li><li>能发出DMA结束信号：引起一次DMA中断，进行数据校验等一些后处理</li></ul></li><li><p>DMA控制器的操作步骤</p><ul><li>DMA控制器的预置（初始化）——软件实现<ul><li>准备内存</li><li>设置参数</li><li>启动外设</li></ul></li><li>DMA数据传送——硬件实现<ul><li>DMA请求：选通-&gt;DMA请求-&gt;总线请求</li><li>DMA响应：总线响应（CPU让出总线）-&gt;DMA响应</li><li>DMA传送：DMA控制总线进行数据传送</li></ul></li><li>DMA结束处理——软件实现</li></ul><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220611131554004.png" srcset="/img/loading.gif" lazyload alt="image-20220611131554004" style="zoom:50%"><ul><li><p>传输过程总览</p><p>(1)当外设准备好数据(或准备好接收数据)时，发“<strong>选通</strong>”信号，使数据送数据缓冲寄存器，同时DMA请求触发器置“1”</p><p>(2)DMA请求触发器向控制&#x2F;状态端口发“<strong>Ready</strong>”信号，同时向DMA控制器发“<strong>DMA请求</strong>”信号</p><p>(3)DMA控制器向CPU发“<strong>总线请求</strong>”信号</p><p>(4)CPU完成现行机器周期后，发出”<strong>总线响应</strong>”信号</p><p>(5)DMA控制器向I&#x2F;O接口发“<strong>DMA响应</strong>”信号，使DMA请求触发器复位。此时，CPU浮动它的总线，让出总线控制权，由DMA控制器控制总线</p><p>(6)DMA控制器给出<strong>内存地址</strong>，并在其读&#x2F;写线上发出“<strong>读</strong>”或“<strong>写</strong>”命令，随后在数据总线上给出数据</p><p>(7)根据读写命令，将数据总线上的数据写入存储器中，或写入数据端口，并进行主存地址增量，计数值减1</p><p>若采用“CPU停止法”，则循环第6~7步，直到计数值为“0”</p><p>若采用“周期挪用法”，则释放总线（下次数据传送时再按过程(1)到(6)进行）</p></li></ul></li><li><p>DMA方式与中断方式区别</p><p>(1)DMA方式下数据传送由<strong>硬件</strong>(DMA控制器)完成；中断方式下，数据传送由<strong>软件</strong>（CPU执行中断服务程序）完成</p><p>(2)DMA请求的是<strong>对存储器访问</strong>，也即对总线控制权的请求，没有中止现行程序的必要；而中断请求要处理器转去执行中断服务程序，因此要<strong>中止现行程序</strong>，保存断点、现场等</p><p>(3)中断除了能完成外设和主机的数据交换，还能<strong>处理异常事件</strong>；而DMA方式下<strong>不能处理异常事件</strong></p><p>(4)中断响应在一个<strong>指令周期结束后</strong>；而DMA响应是在一个<strong>总线周期后</strong></p><p>(5)DMA方式用于<strong>高速设备</strong>；而中断方式用于<strong>慢速设备</strong></p><p>(6) DMA方式下，外设与CPU<strong>并行度高</strong>；而中断方式下，外设与CPU<strong>并行度低</strong>（体现在数据传送时的并行性）</p><blockquote><p>例题：设处理器按500MHz的速度执行，硬盘控制器中有一个16B的数据缓存器，磁盘传输速率为4MB&#x2F;Sec，在磁盘传输数据过程中，要求没有任何数据被错过，并假定CPU访存和DMA访存没有冲突</p><p>（1）若用中断驱动I&#x2F;O，每次传送的开销（包括用于中断响应和处理的时间）是500个时钟周期。如果硬盘仅用5%的时间进行传送，那么处理器用在硬盘I&#x2F;O操作上所花的时间百分比（主机占用率）为多少？</p><p>（2）若用DMA方式，处理器花1000个时钟进行DMA传送的初始化设置，并且在DMA完成后的中断处理需要500个时钟。如果每次DMA传送8000B的数据块，那么当硬盘进行传送的时间占100%（即：硬盘一直进行读写，并传输数据）时，处理器用在硬盘I&#x2F;O操作上的时间百分比（主机占用率）为多少？</p><blockquote><p>中断传送：</p><ul><li><p>硬盘每次中断，可以以16字节为单位进行传送，为保证没有任何数据被错过，应达到每秒$4MB &#x2F;16B&#x3D;250K$次中断的速度</p></li><li><p>每秒钟用于中断的时钟周期数为$250K\times500&#x3D;125\times10^6$</p></li><li><p>在一次数据传输中，处理器花费在I&#x2F;O上的时间的百分比为$125\times 10^6&#x2F;(500\times10^6)&#x3D;25%$</p></li><li><p>假定硬盘仅用其中$5%$的时间来传送数据，则处理器花费在硬盘I&#x2F;O方面的百分比为$25%\times 5%&#x3D;1.25%$</p></li></ul></blockquote><blockquote><p>DMA传送：</p><ul><li><p>每次DMA传送将花费$8000B&#x2F;(4MB&#x2F;s)≈2\times10^{-3}$秒</p></li><li><p>一秒钟内有$1&#x2F;(2\times10^{-3} )&#x3D;500$次DMA传送</p></li><li><p>如果硬盘一直在传送数据的话，处理器必须每秒钟花$(1000+500)\times500&#x3D;750\times10^3$个时钟周期来为硬盘I&#x2F;O操作服务</p></li><li><p>在硬盘I&#x2F;O操作上处理器花费的时间占$750\times10^3&#x2F;(500\times10^6)&#x3D;1.5\times10^{-3}&#x3D;0.15%$</p></li></ul></blockquote></blockquote></li></ul></li></ol><h3 id="祝君考试顺利"><a href="#祝君考试顺利" class="headerlink" title="祝君考试顺利"></a>祝君考试顺利</h3><p><strong>Double S 2022.6.14</strong></p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" class="category-chain-item">计算机组成原理</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">#计算机组成原理</a></div></div><div class="license-box my-3"><div class="license-title"><div>计算机组成原理总结</div><div>http://example.com/2022/06/13/Computer Organization/计算机组成原理总结/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>DoubleS</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2022年6月13日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i> </span></a><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="NC - 非商业性使用"><i class="iconfont icon-nc"></i> </span></a><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="SA - 相同方式共享"><i class="iconfont icon-sa"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2022/06/19/Python/%E3%80%90Python%E3%80%911.%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%85%83%E7%B4%A0/" title="【Python】1. 基本语法元素"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">【Python】1. 基本语法元素</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2022/05/25/Database/%E5%A4%87%E8%80%83%E9%80%9F%E8%AE%B0/" title="数据库总结"><span class="hidden-mobile">数据库总结</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a><div style="font-size:.85rem"><span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span><script src="/js/duration.js"></script></div><link rel="stylesheet" href="/dist/APlayer.min.css"><div id="aplayer"></div><script type="text/javascript" src="/dist/APlayer.min.js"></script><script type="text/javascript" src="/js/music.js"></script></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@1.2.0/dist/Meting.min.js"></script></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init({tocSelector:"#toc-body",contentSelector:".markdown-body",headingSelector:CONFIG.toc.headingSelector||"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:CONFIG.toc.collapseDepth||0,scrollSmooth:!0,headingsOffset:-t}),0<o.find(".toc-list-item").length&&o.css("visibility","visible"))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="/js/leancloud.js"></script><script src="/js/music.js"></script><script src="//at.alicdn.com/t/font_2976433_lwk9d9c1g38.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript><div class="aplayer" data-id="7505773247" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false" data-order="list" data-volume="0.5" data-theme="#1da496" data-preload="auto"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body></html><script type="text/javascript">var titleTime,OriginTitile=document.title;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="w(ﾟДﾟ)w 不要⾛！再看看嘛！",clearTimeout(titleTime)):(document.title="♪(^∇^*)欢迎回来！"+OriginTitile,titleTime=setTimeout(function(){document.title=OriginTitile},2e3))})</script>