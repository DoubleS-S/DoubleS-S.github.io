<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【Python】2. 基本数据类型</title>
    <link href="/2022/06/20/Python/%E3%80%90Python%E3%80%912.%20%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2022/06/20/Python/%E3%80%90Python%E3%80%912.%20%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h1 id="2-1-数字类型"><a href="#2-1-数字类型" class="headerlink" title="2.1 数字类型"></a>2.1 数字类型</h1><h2 id="2-1-1-数字类型的组成"><a href="#2-1-1-数字类型的组成" class="headerlink" title="2.1.1 数字类型的组成"></a>2.1.1 数字类型的组成</h2><h3 id="1-整数——不同进制的转换"><a href="#1-整数——不同进制的转换" class="headerlink" title="1 整数——不同进制的转换"></a>1 整数——不同进制的转换</h3><ul><li>默认输入十进制</li><li>二进制0b、八进制0o、十六进制0x<blockquote><p>16 &#x3D;&#x3D; 0b10000 &#x3D;&#x3D; 0o20 &#x3D;&#x3D; 0x10</p></blockquote></li><li>十进制与其他进制的转换</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-built_in">bin</span>(<span class="hljs-number">16</span>)  <span class="hljs-comment"># 转二进制</span><br>b = <span class="hljs-built_in">oct</span>(<span class="hljs-number">16</span>)  <span class="hljs-comment"># 转八进制</span><br>c = <span class="hljs-built_in">hex</span>(<span class="hljs-number">16</span>)  <span class="hljs-comment"># 转十六进制</span><br><span class="hljs-built_in">print</span>(a, b, c)<br></code></pre></td></tr></table></figure><blockquote><p>0b10000 0o20 0x10</p></blockquote><p><strong>注意：上述转换结果为字符串类型</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(a))<br></code></pre></td></tr></table></figure><blockquote><p>&lt;class ‘str’&gt;</p></blockquote><ul><li>其他进制转十进制</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">d = <span class="hljs-built_in">int</span>(a, <span class="hljs-number">2</span>)<br>e = <span class="hljs-built_in">int</span>(b, <span class="hljs-number">8</span>)<br>f = <span class="hljs-built_in">int</span>(c, <span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span>(d, e, f)<br></code></pre></td></tr></table></figure><blockquote><p>16 16 16</p></blockquote><h3 id="2-浮点数——不确定性"><a href="#2-浮点数——不确定性" class="headerlink" title="2 浮点数——不确定性"></a>2 浮点数——不确定性</h3><ul><li>不确定小数问题</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>((<span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>) == <span class="hljs-number">0.3</span>)<br></code></pre></td></tr></table></figure><blockquote><p>False</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>)<br></code></pre></td></tr></table></figure><blockquote><p>0.30000000000000004</p></blockquote><p><strong>计算机采用二进制小数来表示浮点数的小数部分</strong></p><ul><li>部分小数不能用二进制完全表示</li></ul><blockquote><p>二进制 0.1<br>十进制 0.5</p></blockquote><ul><li>通常情况霞不会影响计算精度</li><li>四舍五入获得精确解<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">3</span>*<span class="hljs-number">0.1</span><br><span class="hljs-built_in">print</span>(a)<br>b = <span class="hljs-built_in">round</span>(a, <span class="hljs-number">1</span>)  <span class="hljs-comment"># 第二个参数为保留小数位数</span><br><span class="hljs-built_in">print</span>(b)<br></code></pre></td></tr></table></figure><blockquote><p>0.30000000000000004<br>0.3</p></blockquote></li></ul><h3 id="3-复数——a-bj"><a href="#3-复数——a-bj" class="headerlink" title="3 复数——a+bj"></a>3 复数——a+bj</h3><ul><li>大写J或小写j均可<blockquote><p>3+4j<br>2+5J</p></blockquote></li><li>虚部系数为1时，需要显性写出<blockquote><p>2+1j</p></blockquote></li></ul><h2 id="2-1-2-数字运算操作符（a-操作符-b"><a href="#2-1-2-数字运算操作符（a-操作符-b" class="headerlink" title="2.1.2 数字运算操作符（a 操作符 b)"></a>2.1.2 数字运算操作符（a 操作符 b)</h2><ul><li>加减乘除运算 + - * &#x2F;</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>((<span class="hljs-number">1</span>+<span class="hljs-number">3</span>-<span class="hljs-number">4</span>*<span class="hljs-number">2</span>)/<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><blockquote><p>-0.8</p></blockquote><ul><li>取反 -</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">x = <span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(-x)<br></code></pre></td></tr></table></figure><blockquote><p>-1</p></blockquote><ul><li>乘方运算 **</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-number">2</span>**<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><blockquote><p>8</p></blockquote><ul><li>整数商 &#x2F;&#x2F; 和 模运算%</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-number">13</span> // <span class="hljs-number">5</span>)  <span class="hljs-comment"># 整数商 x/y 向下取整数</span><br><span class="hljs-built_in">print</span>(<span class="hljs-number">13</span> % <span class="hljs-number">5</span>)  <span class="hljs-comment"># 模运算 余数 13=2*5+3</span><br></code></pre></td></tr></table></figure><blockquote><p>2<br>3</p></blockquote><p><strong>几点说明</strong></p><ul><li>整数与浮点数运算结果是浮点数</li><li>除法运算结果是浮点数</li></ul><h2 id="2-1-3-数学运算操作函数-function-x-…"><a href="#2-1-3-数学运算操作函数-function-x-…" class="headerlink" title="2.1.3 数学运算操作函数 function(x,…)"></a>2.1.3 数学运算操作函数 function(x,…)</h2><ul><li>求绝对值 abs()</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">abs</span>(<span class="hljs-number">3</span> + <span class="hljs-number">4j</span>))  <span class="hljs-comment"># 模运算</span><br></code></pre></td></tr></table></figure><blockquote><p>5.0</p></blockquote><ul><li>幂次方 pow(x,n)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>))  <span class="hljs-comment"># pow(x, n)x的n次方 等价于x**n</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>))  <span class="hljs-comment"># 2^5%3 更快速</span><br></code></pre></td></tr></table></figure><blockquote><p>32<br>2</p></blockquote><ul><li>四舍五入 round(x,n)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">1.618</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">round</span>(a))  <span class="hljs-comment"># 默认四舍五入为整数</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">round</span>(a, <span class="hljs-number">2</span>))  <span class="hljs-comment"># 参数2表示四舍五入保留2位有效小数</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">round</span>(a, <span class="hljs-number">5</span>))  <span class="hljs-comment"># 位数不足，无需补齐</span><br></code></pre></td></tr></table></figure><blockquote><p>2<br>1.62<br>1.618</p></blockquote><ul><li>整数商和模运算 divmod(x,y)<br>等价于返回二元元组(x&#x2F;&#x2F;y,x%y)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">divmod</span>(<span class="hljs-number">13</span>, <span class="hljs-number">5</span>))  <span class="hljs-comment"># 较(x//y, x%y)更快，只执行了一次x/y</span><br></code></pre></td></tr></table></figure><blockquote><p>(2, 3)</p></blockquote><ul><li>序列最大&#x2F;最小值 max() min()</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">max</span>(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>))<br></code></pre></td></tr></table></figure><blockquote><p>9</p></blockquote><ul><li>求和 sum(x)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">sum</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]))  <span class="hljs-comment"># sum括号内为列表</span><br></code></pre></td></tr></table></figure><blockquote><p>15</p></blockquote><ul><li>借助科学计算库 math\scipy\numpy</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><span class="hljs-built_in">print</span>(math.exp(<span class="hljs-number">1</span>))  <span class="hljs-comment"># 指数运算 e^x</span><br><span class="hljs-built_in">print</span>(math.log2(<span class="hljs-number">2</span>))  <span class="hljs-comment"># 对数运算</span><br><span class="hljs-built_in">print</span>(math.sqrt(<span class="hljs-number">4</span>))  <span class="hljs-comment"># 开平方运算 等价于 4^0.5</span><br></code></pre></td></tr></table></figure><blockquote><p>2.718281828459045<br>1.0<br>2.0</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><span class="hljs-built_in">print</span>(np.mean(a))  <span class="hljs-comment"># 求均值</span><br><span class="hljs-built_in">print</span>(np.median(a))  <span class="hljs-comment"># 求中位数</span><br><span class="hljs-built_in">print</span>(np.std(a))  <span class="hljs-comment"># 求标准差</span><br></code></pre></td></tr></table></figure><blockquote><p>3.0<br>3.0<br>1.4142135623730951</p></blockquote><h1 id="2-2-字符串类型"><a href="#2-2-字符串类型" class="headerlink" title="2.2 字符串类型"></a>2.2 字符串类型</h1><h2 id="2-2-1-字符串的表达"><a href="#2-2-1-字符串的表达" class="headerlink" title="2.2.1 字符串的表达"></a>2.2.1 字符串的表达</h2><ul><li>用””或’’括起来的任意字符</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Python&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Python&#x27;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>Python<br>Python</p></blockquote><ul><li>字符串中有双引号或单引号的情况</li></ul><p><strong>双中有单</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I&#x27;m 18 years old&quot;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>I’m 18 years old</p></blockquote><p><strong>单中有双</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&quot;Python&quot; is good&#x27;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>“Python” is good</p></blockquote><p><strong>双中有双，单中有单</strong>——转义符 \</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\&quot;Python\&quot; is good&quot;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>“Python” is good</p></blockquote><p><strong>转义符可以用来换行继续输入</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-string">&quot;Py\</span><br><span class="hljs-string">thon&quot;</span><br><span class="hljs-built_in">print</span>(a)<br></code></pre></td></tr></table></figure><blockquote><p>Python</p></blockquote><h2 id="2-2-2-字符串的性质"><a href="#2-2-2-字符串的性质" class="headerlink" title="2.2.2 字符串的性质"></a>2.2.2 字符串的性质</h2><h3 id="1-字符串的索引"><a href="#1-字符串的索引" class="headerlink" title="1 字符串的索引"></a>1 字符串的索引</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&quot;My name is Peppa Pig&quot;</span><br></code></pre></td></tr></table></figure><p><strong>变量名[位置编号]</strong></p><ul><li>正向索引——从零开始递增</li><li>位置编号不能超过字符串的长度</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(s[<span class="hljs-number">0</span>])<br><span class="hljs-built_in">print</span>(s[<span class="hljs-number">2</span>])<br><span class="hljs-built_in">print</span>(s[<span class="hljs-number">5</span>])<br></code></pre></td></tr></table></figure><blockquote><p>M<br> <br>m</p></blockquote><ul><li>反向索引——从-1开始递减</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(s[-<span class="hljs-number">1</span>])<br><span class="hljs-built_in">print</span>(s[-<span class="hljs-number">3</span>])<br><span class="hljs-built_in">print</span>(s[-<span class="hljs-number">5</span>])<br></code></pre></td></tr></table></figure><blockquote><p>g<br>P<br>a</p></blockquote><p><strong>索引只能获得一个字符，如何获得多个字符？</strong></p><h3 id="2-字符串的切片"><a href="#2-字符串的切片" class="headerlink" title="2 字符串的切片"></a>2 字符串的切片</h3><p><strong>变量名[开始位置:结束位置:切片间隔]</strong></p><ul><li>切片间隔若不设置默认为1，可省略</li><li>切片范围不包含结束位置</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&quot;Python&quot;</span><br><span class="hljs-built_in">print</span>(s[<span class="hljs-number">0</span>:<span class="hljs-number">3</span>:<span class="hljs-number">1</span>])<br><span class="hljs-built_in">print</span>(s[<span class="hljs-number">0</span>:<span class="hljs-number">3</span>:<span class="hljs-number">2</span>])<br><span class="hljs-built_in">print</span>(s[<span class="hljs-number">0</span>:<span class="hljs-number">3</span>])<br></code></pre></td></tr></table></figure><blockquote><p>Pyt<br>Pt<br>Pyt</p></blockquote><ul><li>起始位置是0，可以省略</li><li>结束位置省略代表可以取到最后一个字符</li><li>可以使用反向索引</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(s[<span class="hljs-number">0</span>:<span class="hljs-number">6</span>])<br><span class="hljs-built_in">print</span>(s[:<span class="hljs-number">6</span>])<br><span class="hljs-built_in">print</span>(s[:])<br><span class="hljs-built_in">print</span>(s[-<span class="hljs-number">6</span>:])<br></code></pre></td></tr></table></figure><blockquote><p>Python<br>Python<br>Python<br>Python</p></blockquote><p><strong>反向切片</strong></p><ul><li>起始位置是-1也可以省略</li><li>结束位置省略，代表可以取到第一个字符</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&quot;123456789&quot;</span><br><span class="hljs-built_in">print</span>(s[-<span class="hljs-number">1</span>:-<span class="hljs-number">10</span>:-<span class="hljs-number">1</span>])<br><span class="hljs-built_in">print</span>(s[:-<span class="hljs-number">10</span>:-<span class="hljs-number">1</span>])<br><span class="hljs-built_in">print</span>(s[::-<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><blockquote><p>987654321<br>987654321<br>987654321</p></blockquote><h2 id="2-2-3-字符串操作符"><a href="#2-2-3-字符串操作符" class="headerlink" title="2.2.3 字符串操作符"></a>2.2.3 字符串操作符</h2><h3 id="1-字符串拼接"><a href="#1-字符串拼接" class="headerlink" title="1 字符串拼接"></a>1 字符串拼接</h3><ul><li>字符串1+字符串2</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-string">&quot;I love &quot;</span><br>b = <span class="hljs-string">&quot;my wife &quot;</span><br><span class="hljs-built_in">print</span>(a+b)<br></code></pre></td></tr></table></figure><blockquote><p>I love my wife </p></blockquote><h3 id="2-字符串的成倍复制"><a href="#2-字符串的成倍复制" class="headerlink" title="2 字符串的成倍复制"></a>2 字符串的成倍复制</h3><ul><li>字符串*n 或 n*字符串</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">c = a + b<br><span class="hljs-built_in">print</span>(c*<span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-number">5</span>*c)<br></code></pre></td></tr></table></figure><blockquote><p>I love my wife I love my wife I love my wife<br>I love my wife I love my wife I love my wife I love my wife I love my wife </p></blockquote><h3 id="3-成员运算"><a href="#3-成员运算" class="headerlink" title="3 成员运算"></a>3 成员运算</h3><ul><li><strong>子集in全集</strong> 任何一个连续的切片都是原字符串的子集</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">folk_singers = <span class="hljs-string">&quot;Peter, Paul and Mary&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Peter&quot;</span> <span class="hljs-keyword">in</span> folk_singers)<br></code></pre></td></tr></table></figure><blockquote><p>True</p></blockquote><ul><li><strong>遍历字符串字符</strong> for 字符 in 字符串</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;Python&quot;</span>:<br>    <span class="hljs-built_in">print</span>(s)<br></code></pre></td></tr></table></figure><blockquote><p>P<br>y<br>t<br>h<br>o<br>n</p></blockquote><h2 id="2-2-4-字符串处理函数"><a href="#2-2-4-字符串处理函数" class="headerlink" title="2.2.4 字符串处理函数"></a>2.2.4 字符串处理函数</h2><h3 id="1-字符串的长度"><a href="#1-字符串的长度" class="headerlink" title="1 字符串的长度"></a>1 字符串的长度</h3><ul><li>所含字符个数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&quot;Python&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(s))<br></code></pre></td></tr></table></figure><blockquote><p>6</p></blockquote><h3 id="2-字符编码"><a href="#2-字符编码" class="headerlink" title="2 字符编码"></a>2 字符编码</h3><p><strong>将中文字库、英文字母、数字、特殊符号等转化成计算机可识别的二进制数</strong></p><ul><li>每个单一字符对应一个唯一的互不重复的二进制编码</li><li>Python中使用的是Unicode编码</li></ul><p><strong>将字符转化为Unicode码</strong>——ord(字符)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">ord</span>(<span class="hljs-string">&quot;1&quot;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">ord</span>(<span class="hljs-string">&quot;a&quot;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">ord</span>(<span class="hljs-string">&quot;*&quot;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">ord</span>(<span class="hljs-string">&quot;中&quot;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">ord</span>(<span class="hljs-string">&quot;国&quot;</span>))<br></code></pre></td></tr></table></figure><blockquote><p>49<br>97<br>42<br>20013<br>22269</p></blockquote><p><strong>将Unicode码转化为字符</strong>——chr(Unicode码)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">chr</span>(<span class="hljs-number">1010</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">chr</span>(<span class="hljs-number">10000</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">chr</span>(<span class="hljs-number">12345</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">chr</span>(<span class="hljs-number">23456</span>))<br></code></pre></td></tr></table></figure><blockquote><p>ϲ<br>✐<br>〹<br>宠</p></blockquote><h2 id="2-2-5-字符串的处理方法"><a href="#2-2-5-字符串的处理方法" class="headerlink" title="2.2.5 字符串的处理方法"></a>2.2.5 字符串的处理方法</h2><h3 id="1-字符串的分割——字符串-split-分割字符"><a href="#1-字符串的分割——字符串-split-分割字符" class="headerlink" title="1 字符串的分割——字符串.split(分割字符)"></a>1 字符串的分割——字符串.split(分割字符)</h3><ul><li>返回一个列表</li><li>原字符串不变</li></ul><p><strong>上述特性适合一下所有字符串处理方法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">languages = <span class="hljs-string">&quot;Python C C++ Java PHP R&quot;</span><br>languages_list = languages.split(<span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-built_in">print</span>(languages_list)<br><span class="hljs-built_in">print</span>(languages)<br></code></pre></td></tr></table></figure><blockquote><p>[‘Python’, ‘C’, ‘C++’, ‘Java’, ‘PHP’, ‘R’]<br>Python C C++ Java PHP R</p></blockquote><h3 id="2-字符串的聚合——“聚合字符”-join-可迭代数据类型"><a href="#2-字符串的聚合——“聚合字符”-join-可迭代数据类型" class="headerlink" title="2 字符串的聚合——“聚合字符”.join(可迭代数据类型)"></a>2 字符串的聚合——“聚合字符”.join(可迭代数据类型)</h3><ul><li>可迭代类型 如：字符串、列表</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&quot;12345&quot;</span><br>s_join = <span class="hljs-string">&quot;,&quot;</span>.join(s)<br><span class="hljs-built_in">print</span>(s_join)<br></code></pre></td></tr></table></figure><blockquote><p>1,2,3,4,5</p></blockquote><ul><li>序列类型元素必须为字符类型</li></ul><h3 id="3-删除两端特定字符——字符串-strip-删除字符"><a href="#3-删除两端特定字符——字符串-strip-删除字符" class="headerlink" title="3 删除两端特定字符——字符串.strip(删除字符)"></a>3 删除两端特定字符——字符串.strip(删除字符)</h3><ul><li>strip从两侧开始搜索，遇到指定字符执行删除，遇到非指定字符，搜索停止</li><li>类似的还有左删除lstrip和右删除rstrip</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&quot;   I have many blanks   &quot;</span><br><span class="hljs-built_in">print</span>(s.strip(<span class="hljs-string">&quot; &quot;</span>))<br><span class="hljs-built_in">print</span>(s.lstrip(<span class="hljs-string">&quot; &quot;</span>))<br><span class="hljs-built_in">print</span>(s.rstrip(<span class="hljs-string">&quot; &quot;</span>))<br></code></pre></td></tr></table></figure><blockquote><p>I have many blanks<br>I have many blanks<br>　I have many blanks</p></blockquote><h3 id="4-字符串的替换——字符串-replace-“被替换”-”替换成”"><a href="#4-字符串的替换——字符串-replace-“被替换”-”替换成”" class="headerlink" title="4 字符串的替换——字符串.replace(“被替换”,”替换成”)"></a>4 字符串的替换——字符串.replace(“被替换”,”替换成”)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&quot;Python is coming&quot;</span><br>s1 = s.replace(<span class="hljs-string">&quot;Python&quot;</span>, <span class="hljs-string">&quot;Py&quot;</span>)<br><span class="hljs-built_in">print</span>(s1)<br></code></pre></td></tr></table></figure><blockquote><p>Py is coming</p></blockquote><h3 id="5-字符串统计——字符串-count-“待统计字符串”"><a href="#5-字符串统计——字符串-count-“待统计字符串”" class="headerlink" title="5 字符串统计——字符串.count(“待统计字符串”)"></a>5 字符串统计——字符串.count(“待统计字符串”)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&quot;Python is an excellent language&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;an:&quot;</span>, s.count(<span class="hljs-string">&quot;an&quot;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;e:&quot;</span>, s.count(<span class="hljs-string">&quot;e&quot;</span>))<br></code></pre></td></tr></table></figure><blockquote><p>an: 2<br>e: 4</p></blockquote><h3 id="6-字符串字母大小写"><a href="#6-字符串字母大小写" class="headerlink" title="6 字符串字母大小写"></a>6 字符串字母大小写</h3><ul><li>字符串.upper()字母全部大写</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&quot;Python&quot;</span><br><span class="hljs-built_in">print</span>(s.upper())<br></code></pre></td></tr></table></figure><blockquote><p>PYTHON</p></blockquote><ul><li>字符串.lower()字母全部小写</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(s.lower())<br></code></pre></td></tr></table></figure><blockquote><p>python</p></blockquote><ul><li>字符串.title()首字母大写</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(s.title())<br></code></pre></td></tr></table></figure><blockquote><p>Python</p></blockquote><h1 id="2-3-布尔类型-True-or-False"><a href="#2-3-布尔类型-True-or-False" class="headerlink" title="2.3 布尔类型 True or False"></a>2.3 布尔类型 True or False</h1><h2 id="2-3-1-逻辑运算的结果"><a href="#2-3-1-逻辑运算的结果" class="headerlink" title="2.3.1 逻辑运算的结果"></a>2.3.1 逻辑运算的结果</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">10</span><br><span class="hljs-built_in">print</span>(a &gt; <span class="hljs-number">8</span>)<br><span class="hljs-built_in">print</span>(a == <span class="hljs-number">12</span>)<br><span class="hljs-built_in">print</span>(a &lt; <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><blockquote><p>True<br>False<br>False</p></blockquote><ul><li>any() all()</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">any</span>([<span class="hljs-literal">False</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">None</span>]))  <span class="hljs-comment"># 0 False None 都是无</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">all</span>([<span class="hljs-literal">False</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">None</span>]))<br></code></pre></td></tr></table></figure><blockquote><p>True<br>False</p></blockquote><h2 id="2-3-2-指示条件"><a href="#2-3-2-指示条件" class="headerlink" title="2.3.2 指示条件"></a>2.3.2 指示条件</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">n = <span class="hljs-number">2800</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    m = <span class="hljs-built_in">eval</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入一个正整数：&quot;</span>))<br>    <span class="hljs-keyword">if</span> m == n:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;你猜对啦&quot;</span>)<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">elif</span> m &gt; n:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;太大了&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;太小了&quot;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>请输入一个正整数：28<br>太小了<br>请输入一个正整数：2800<br>你猜对啦</p></blockquote><h2 id="2-3-3-作为掩码"><a href="#2-3-3-作为掩码" class="headerlink" title="2.3.3 作为掩码"></a>2.3.3 作为掩码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>x = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>]])<br><span class="hljs-built_in">print</span>(x &gt; <span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(x[x &gt; <span class="hljs-number">3</span>])<br></code></pre></td></tr></table></figure><blockquote><p>[[False False False  True  True]]<br>[5 7]</p></blockquote><h1 id="2-4-类型判别及类型转换"><a href="#2-4-类型判别及类型转换" class="headerlink" title="2.4 类型判别及类型转换"></a>2.4 类型判别及类型转换</h1><h2 id="2-4-1-类型判别"><a href="#2-4-1-类型判别" class="headerlink" title="2.4.1 类型判别"></a>2.4.1 类型判别</h2><ul><li>type(变量)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">age = <span class="hljs-number">20</span><br>name = <span class="hljs-string">&quot;Ada&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(age))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(name))<br></code></pre></td></tr></table></figure><blockquote><p>&lt;class ‘int’&gt;<br>&lt;class ‘str’&gt;</p></blockquote><ul><li>isinstance(变量,预判类型) <strong>承认继承</strong><br>变量类型是预判类型的子类型，则为真，否则为假</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(age, <span class="hljs-built_in">int</span>))  <span class="hljs-comment"># 承认继承</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(age, <span class="hljs-built_in">object</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(name, <span class="hljs-built_in">object</span>))  <span class="hljs-comment"># object是老祖宗</span><br></code></pre></td></tr></table></figure><blockquote><p>True<br>True<br>True</p></blockquote><ul><li>字符串检查方法</li></ul><p><strong>字符串.isdigit()字符是否只有数字组成</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">age = <span class="hljs-string">&quot;20&quot;</span><br>name = <span class="hljs-string">&quot;Ada&quot;</span><br><span class="hljs-built_in">print</span>(age.isdigit())<br><span class="hljs-built_in">print</span>(name.isdigit())<br></code></pre></td></tr></table></figure><blockquote><p>True<br>False</p></blockquote><p><strong>字符串.isalpha()字符是否只有字母组成</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(name.isalpha())<br></code></pre></td></tr></table></figure><blockquote><p>True</p></blockquote><p><strong>字符串.isalnum()字符是否只有数字和字母组成</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Ada20&quot;</span>.isalnum())<br></code></pre></td></tr></table></figure><blockquote><p>True</p></blockquote><h2 id="2-4-2-类型转换"><a href="#2-4-2-类型转换" class="headerlink" title="2.4.2 类型转换"></a>2.4.2 类型转换</h2><ul><li>数字类型转字符串 str(数字类型)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">age = <span class="hljs-number">20</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;My age is &quot;</span>+<span class="hljs-built_in">str</span>(age))<br></code></pre></td></tr></table></figure><blockquote><p>My age is 20</p></blockquote><ul><li>仅有数字组成的字符串转数字 int() float() eval()</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">s1 = <span class="hljs-string">&quot;20&quot;</span><br>s2 = <span class="hljs-string">&quot;10.1&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">int</span>(s1))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">float</span>(s1))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">float</span>(s2))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">eval</span>(s1))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">eval</span>(s2))<br></code></pre></td></tr></table></figure><blockquote><p>20<br>20.0<br>10.1<br>20<br>10.1</p></blockquote><p>以上，便是第二节基本数据类型内容。<br>下一节为组合数据类型，深入了解列表、元组、字典和集合。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World!</title>
    <link href="/2022/06/20/hello-world/"/>
    <url>/2022/06/20/hello-world/</url>
    
    <content type="html"><![CDATA[<p><strong>欢迎你来到这个博客！</strong></p><p>我叫<strong>DoubleS</strong>，目前就读于<strong>UESTC</strong>，之前有写文档的习惯，不妨就利用这个假期来搭一个博客作为一次探索的尝试吧！</p><p>相信大多数人建站的初始目的都希望能在网上找到一个发表自己感悟、分享自己生活的平台。一开始我写一些类似于笔记的文档，发表于知乎与CSDN上，在这些平台进行写作是十分方便快捷，只需静心写作，无需关注其他东西，但我更喜欢亲自动手部署的过程，说简单点，就是<strong>爱折腾</strong>。我无法保证我能做到文章的持续输出，仅作为一次尝试，因此我选择了建站成本最低的方式——使用<strong>Hexo框架</strong>，并且使用fluid主题进行了简单美化。</p><p><strong>2022.6.19</strong>，是这个博客诞生的日子。我会陆陆续续完善博客的功能以及发布更多的文章，文章大多是学习的记录与生活中的感悟。当然，不指望知识的传播，而是希望自己的学习生活过程得到记录。我是人工智能专业，以后大多会发布一些人工智能专业的知识点文章以及精彩的大学生活记录。希望你我都能从无论是建站优化还是发文感悟的同时都能收获成长！</p><p align="right">DoubleS2022.6.20</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【Python】1. 基本语法元素</title>
    <link href="/2022/06/19/Python/%E3%80%90Python%E3%80%911.%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%85%83%E7%B4%A0/"/>
    <url>/2022/06/19/Python/%E3%80%90Python%E3%80%911.%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h3><h4 id="1-基本类型：数字、字符串、布尔"><a href="#1-基本类型：数字、字符串、布尔" class="headerlink" title="1. 基本类型：数字、字符串、布尔"></a>1. 基本类型：数字、字符串、布尔</h4><p><strong>1.1 数字类型</strong></p><ul><li><p>int 整型 整数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure></li><li><p>float 浮点型 带小数的数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2.5</span><br><span class="hljs-comment">#2.0虽然数值上与2相等，但其为浮点数，与上一代码段中的2的数据类型不一样</span><br></code></pre></td></tr></table></figure></li><li><p>complex 复数 $a+bj$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">3</span>+<span class="hljs-number">4j</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>1.2 字符串类型</strong></p><blockquote><ol><li>str 字符串 视作文本</li><li><strong>组成</strong>：由数字、字母、空格、其他字符组成</li><li><strong>表达</strong>：用’ ‘或” “</li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;Python-#Double S&quot;</span><br></code></pre></td></tr></table></figure><p><strong>1.3 布尔类型</strong></p><p>bool 布尔类型</p><p>主要用于逻辑运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">y = <span class="hljs-number">2</span> &gt; <span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(y)<br></code></pre></td></tr></table></figure><p><strong>上述数据类型均可定义单个数据，但面对多组数据，需要利用组合类型</strong></p><h4 id="2-组合类型：列表、元组、字典、集合"><a href="#2-组合类型：列表、元组、字典、集合" class="headerlink" title="2. 组合类型：列表、元组、字典、集合"></a>2. 组合类型：列表、元组、字典、集合</h4><p><strong>2.1 列表（有序）</strong></p><p>list 列表 序列类型：数据有位置顺序</p><p>表示方式：[data1,data2…]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>a[<span class="hljs-number">0</span>]<span class="hljs-comment">#读取a列表中第一个元素</span><br>a[-<span class="hljs-number">1</span>]<span class="hljs-comment">#读取a列表中最后一个元素</span><br></code></pre></td></tr></table></figure><p><strong>2.2 元组</strong></p><p>tuple 元组 序列类型</p><p>表示方式：(data1,data2…)</p><p><strong>元素不可修改，即不可变列表</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">b = (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>)<br>b[<span class="hljs-number">0</span>]<span class="hljs-comment">#读取b元组第一个元素</span><br></code></pre></td></tr></table></figure><p><strong>2.3 字典</strong></p><p>dict 字典 映射类型：通过”键”-“值”的映射实现数据的存储和查找</p><p>表示方式：{key1:value1,key2:value2…}</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">student = &#123;0601016:<span class="hljs-string">&quot;小石&quot;</span>, 0601015:<span class="hljs-string">&quot;小刘&quot;</span>, 0601014:<span class="hljs-string">&quot;小卢&quot;</span>&#125;<br>student[0601015]<span class="hljs-comment">#与list和tuple不同，dict通过key读取元素</span><br></code></pre></td></tr></table></figure><p>字典是在内部是无序的</p><p><strong>2.4 集合</strong></p><p>set 集合 一系列互不相等元素的集合，无序的</p><p>表示方式：{data1,data2…}</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">student = &#123;<span class="hljs-string">&quot;小石&quot;</span>,<span class="hljs-string">&quot;小刘&quot;</span>,<span class="hljs-string">&quot;小卢&quot;</span>,<span class="hljs-string">&quot;小刘&quot;</span>&#125;<br><span class="hljs-built_in">print</span>(student)<span class="hljs-comment">#虽然多打了一个小刘，但是set中元素互不相等且无序，故只输出前三者</span><br></code></pre></td></tr></table></figure><p>我们一般通过<strong>变量</strong>来引用这些数据</p><h3 id="二、变量"><a href="#二、变量" class="headerlink" title="二、变量"></a>二、变量</h3><h4 id="1-变量的概念"><a href="#1-变量的概念" class="headerlink" title="1.  变量的概念"></a>1.  变量的概念</h4><p>量：实实在在的对象，如数据、抽象</p><p>变：可变性：增、删、查、改等</p><p><strong>变量定义二要素：变量名，赋值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">x = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="2-变量的命名"><a href="#2-变量的命名" class="headerlink" title="2. 变量的命名"></a>2. 变量的命名</h4><p><strong>2.1 哪些可以做变量名？</strong></p><p>大写字母、小写字母、数字、下划线、汉字及其组合</p><p>严格区分大小写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">Double_S_is_a_小白 = Ture<br>double_s_is_a_小白 = <span class="hljs-literal">False</span><br><span class="hljs-comment">#Python严格区分大小写，上述是两个变量</span><br></code></pre></td></tr></table></figure><p><strong>2.2 哪些情况不允许做变量名？</strong></p><p>首字符不允许为数字</p><p>变量名中间不能有空格</p><p>不能与Python中33个保留字相同</p><p><strong>2.3 变量名定义技巧</strong></p><p>尽量有实际意义，表征数据的某种特性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">age_of_students = [<span class="hljs-number">17</span>,<span class="hljs-number">18</span>,<span class="hljs-number">19</span>]<br><span class="hljs-comment">#比单独字母a = [17,18,19]更加清晰，增强可读性</span><br></code></pre></td></tr></table></figure><p>下划线 （推荐变量和函数名） 变量名由多个单词组成：用_连接多个单词</p><p>驼峰体 （推荐类名）变量名由多个单词组成：单词首字母大写</p><p>尽量避免中文或拼音做变量名</p><p>特殊变量：常量 （不变的量 如：$\pi,e$）变量所有字母均大写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">MAX_ITERATION = <span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure><h4 id="3-变量的赋值"><a href="#3-变量的赋值" class="headerlink" title="3. 变量的赋值"></a>3. 变量的赋值</h4><p><strong>3.1 一般赋值</strong></p><p>通过等号自右向左赋值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">x = <span class="hljs-number">1</span>+<span class="hljs-number">2</span><span class="hljs-comment">#先计算1+2=3,再将结果赋值给x</span><br><span class="hljs-built_in">print</span>(x)<br></code></pre></td></tr></table></figure><p><strong>3.2 增量赋值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">x = <span class="hljs-number">10</span><br>x = x+<span class="hljs-number">10</span><br><span class="hljs-built_in">print</span>(x)<br>x += <span class="hljs-number">10</span><span class="hljs-comment">#x=x+10简写，更常用</span><br></code></pre></td></tr></table></figure><p><strong>3.3 打包赋值</strong></p><p>同时对多个变量赋值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">x, y = <span class="hljs-number">1</span>, <span class="hljs-number">2</span><br><span class="hljs-built_in">print</span>(x, y)<br>x, y = y, x<span class="hljs-comment">#Python一行代码即可实行互换</span><br><span class="hljs-built_in">print</span>(x, y)<br></code></pre></td></tr></table></figure><h3 id="三、控制流程"><a href="#三、控制流程" class="headerlink" title="三、控制流程"></a>三、控制流程</h3><h4 id="1-顺序流程"><a href="#1-顺序流程" class="headerlink" title="1. 顺序流程"></a>1. 顺序流程</h4><p>自上而下依次执行</p><p>【例】实现1到5的整数求和</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#res = 1+2+3+4+5</span><br>res = <span class="hljs-number">0</span>    <span class="hljs-comment">#赋初值</span><br>res += <span class="hljs-number">1</span><br>res += <span class="hljs-number">2</span><br>res += <span class="hljs-number">3</span><br>res += <span class="hljs-number">4</span><br>res += <span class="hljs-number">5</span><br><span class="hljs-built_in">print</span>(res)    <span class="hljs-comment">#显示结果</span><br></code></pre></td></tr></table></figure><h4 id="2-循环流程——遍历循环-for"><a href="#2-循环流程——遍历循环-for" class="headerlink" title="2. 循环流程——遍历循环(for)"></a>2. 循环流程——遍历循环(for)</h4><p>主要形式：</p><p>for 元素 in 可迭代对象:</p><p>​    执行语句</p><p>执行过程：从可迭代对象中，依次取出每一个元素，并进行相应操作</p><p>【例】实现1到5的整数求和</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">res = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]:    <span class="hljs-comment">#每次迭代，取出1个i</span><br>    res += i    <span class="hljs-comment">#对每次迭代取出的i 进行相应操作</span><br><span class="hljs-built_in">print</span>(res)    <span class="hljs-comment">#遍历结束后，执行后续语句</span><br></code></pre></td></tr></table></figure><h4 id="3-循环流程——无限循环-while"><a href="#3-循环流程——无限循环-while" class="headerlink" title="3. 循环流程——无限循环(while)"></a>3. 循环流程——无限循环(while)</h4><p>主要形式：</p><p>while 判断条件:</p><p>​    条件为真，执行语句</p><p>条件为假，while循环结束</p><p>【例】实现1到5的整数求和</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">i = <span class="hljs-number">1</span><br>res = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> i &lt;= <span class="hljs-number">5</span>:    <span class="hljs-comment">#若i不大于5，则循环继续</span><br>    res += i<br>    i += <span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(res)    <span class="hljs-comment">#若循环条件不成立，循环停止，执行后续语句</span><br></code></pre></td></tr></table></figure><h4 id="4-分支流程-if"><a href="#4-分支流程-if" class="headerlink" title="4.分支流程(if)"></a>4.分支流程(if)</h4><p>最简单形式：</p><p>if 判断条件:</p><p>​    条件为真，执行语句</p><p>else:</p><p>​    条件为假，执行语句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">age = <span class="hljs-number">18</span><br><span class="hljs-keyword">if</span> age &gt; <span class="hljs-number">22</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;可以结婚啦&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;再等等吧&quot;</span>)<br></code></pre></td></tr></table></figure><p>下面，我们了解控制流程后，再回过头看看如何输入输出</p><h3 id="四、输入输出"><a href="#四、输入输出" class="headerlink" title="四、输入输出"></a>四、输入输出</h3><h4 id="1-数据从何而来？"><a href="#1-数据从何而来？" class="headerlink" title="1. 数据从何而来？"></a>1. 数据从何而来？</h4><p><strong>1.1 外部文件导入</strong></p><p>从本地硬盘、网络端读入等</p><p>后续会详细讲解</p><p><strong>1.2 程序中定义</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">age = <span class="hljs-number">18</span><br>name = <span class="hljs-string">&quot;Tom&quot;</span><br></code></pre></td></tr></table></figure><p><strong>1.3 动态交互输入 input</strong></p><p>在程序运行过程中进行输入（此时输入数据为字符串形式）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">x = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入一个数字:&quot;</span>)<span class="hljs-comment">#此时输入数据为字符串形式</span><br><span class="hljs-built_in">print</span>(x)<br></code></pre></td></tr></table></figure><p>eval()去掉引号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">x = <span class="hljs-built_in">eval</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入一个数字:&quot;</span>))<br>y = <span class="hljs-built_in">eval</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入一个数字:&quot;</span>))<br><span class="hljs-built_in">print</span>(x+y)<br></code></pre></td></tr></table></figure><h4 id="2-数据到哪儿去？"><a href="#2-数据到哪儿去？" class="headerlink" title="2. 数据到哪儿去？"></a>2. 数据到哪儿去？</h4><p><strong>2.1 存储到本地硬盘和网络端</strong></p><p>后续详细讲解</p><p><strong>2.2 打印输出print</strong></p><p>直接打印数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我是DoubleS!&quot;</span>)<br></code></pre></td></tr></table></figure><p>打印变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">x = <span class="hljs-number">1024</span><br><span class="hljs-built_in">print</span>(x)<br></code></pre></td></tr></table></figure><p>PS:print默认换行</p><p>若不想换行，换行控制 end&#x3D;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-number">123</span>, end=<span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-number">456</span>)<br></code></pre></td></tr></table></figure><p>有时，我们需要一些复杂输出：比如几个变量一起组合输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">PI = <span class="hljs-number">3.1415926</span><br>E = <span class="hljs-number">2.71828</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;PI = &quot;</span>, PI,<span class="hljs-string">&quot;E = &quot;</span>, E)<br></code></pre></td></tr></table></figure><p><strong>2.3 格式化输出方法 format</strong></p><p>基本格式：”字符{0}字符{1}字符”.format(v0, v1)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">PI = <span class="hljs-number">3.1415926</span><br>E = <span class="hljs-number">2.71828</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;PI = &#123;0&#125;, E = &#123;1&#125;&quot;</span>.<span class="hljs-built_in">format</span>(PI, E))<br><span class="hljs-comment">#&#123;&#125;内数字代表format中对应数据，可自己调整顺序</span><br><span class="hljs-comment">#也可以不填，默认从0开始</span><br></code></pre></td></tr></table></figure><p>填充输入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#_____3.1415926_____    进行填充</span><br>PI = <span class="hljs-number">3.1415926</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;0:_^20&#125;&quot;</span>.<span class="hljs-built_in">format</span>(PI))<br><span class="hljs-comment">#^为数据居中，&lt;为数据左对齐，&gt;为数据右对齐</span><br></code></pre></td></tr></table></figure><p>数字千分位分隔符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#显示1,000,000</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;0:,&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-number">1000000</span>))<br><span class="hljs-comment">#若既要填充输出，又要千分位分隔符</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;0:$&gt;20,&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-number">1000000</span>))<br></code></pre></td></tr></table></figure><p>浮点数简化输出</p><ul><li><p>留2位小数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">PI = <span class="hljs-number">3.1415926</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;0:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(PI))<br></code></pre></td></tr></table></figure></li><li><p>按百分数输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;0:.1%&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-number">0.818727</span>))<br></code></pre></td></tr></table></figure></li><li><p>科学计数法输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;0:.2e&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-number">0.818727</span>))<br></code></pre></td></tr></table></figure></li></ul><p>整数的进制转换输出</p><ul><li><p>十进制整数转二进制、unicode码、十进制、八进制、十六进制输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;二进制&#123;0:b&#125;, Uicode码&#123;0:c&#125;, 十进制&#123;0:d&#125;, 八进制&#123;0:o&#125;, 十六进制&#123;0:x&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-number">450</span>))<br></code></pre></td></tr></table></figure></li></ul><blockquote><p>综上，format用法总结：</p><p>“字符{0:修饰}字符{1:修饰}字符”.format(v1,v2)</p><p>严格按照顺序：</p><p>{x:&lt;填充&gt;&lt;对齐&gt;&lt;宽度&gt;&lt;,&gt;&lt;.精度&gt;&lt;类型&gt;}</p></blockquote><h3 id="五、程序格式"><a href="#五、程序格式" class="headerlink" title="五、程序格式"></a>五、程序格式</h3><p>增强可读性，使大量Python代码风格一致</p><h4 id="1-行最大长度"><a href="#1-行最大长度" class="headerlink" title="1. 行最大长度"></a>1. 行最大长度</h4><p>所有行限制的最大字符数为79</p><h4 id="2-缩进"><a href="#2-缩进" class="headerlink" title="2. 缩进"></a>2. 缩进</h4><ul><li>用缩进来表示语句间逻辑</li><li>在 for while if def class等：之后下一行开始进行缩进，表明后续代码与前句之间的从属关系</li><li>缩进量：4字符</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]:<br>    <span class="hljs-built_in">print</span>(i)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;打印结束&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="3-使用空格"><a href="#3-使用空格" class="headerlink" title="3. 使用空格"></a>3. 使用空格</h4><ul><li><p>二元运算符两边加一个空格</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">x = <span class="hljs-number">2</span>    <span class="hljs-comment">#赋值</span><br>x + = <span class="hljs-number">4</span>    <span class="hljs-comment">#增量</span><br><span class="hljs-number">6</span> &gt; <span class="hljs-number">2</span>    <span class="hljs-comment">#比较</span><br></code></pre></td></tr></table></figure></li><li><p>使用不同优先级的运算符，考虑在最低级的运算符周围添加空格</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">x = x*<span class="hljs-number">2</span> - <span class="hljs-number">1</span><br>z = x*x + y*y<br>c = (a+b) * (a-b)<br></code></pre></td></tr></table></figure></li><li><p>在逗号后使用空格</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">x, y = <span class="hljs-number">1</span>, <span class="hljs-number">2</span><br>ls = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure></li><li><p>不要使用一个以上空格</p></li></ul><h4 id="4-避免使用空格"><a href="#4-避免使用空格" class="headerlink" title="4. 避免使用空格"></a>4. 避免使用空格</h4><ul><li><p>在制定关键字参数或者默认参数值的时候，不要在&#x3D;附近加上空格</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params">n=<span class="hljs-number">1</span>, m=<span class="hljs-number">2</span></span>):<br>    <span class="hljs-built_in">print</span>(n, m)<br></code></pre></td></tr></table></figure></li></ul><h4 id="5-注释"><a href="#5-注释" class="headerlink" title="5. 注释"></a>5. 注释</h4><ul><li>单行注释</li><li>格式： # 注释内容</li><li>多行注释（”””)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">1</span>    <span class="hljs-comment">#我是单行注释</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">我是</span><br><span class="hljs-string">多行</span><br><span class="hljs-string">注释</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><p><strong>以上，便是第一节基本语法元素内容</strong></p><p><strong>下一节内容为基本数据类型，将深入了解数字、字符串、布尔</strong></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理总结</title>
    <link href="/2022/06/13/Computer%20Organization/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/"/>
    <url>/2022/06/13/Computer%20Organization/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="计算机组成原理总结"><a href="#计算机组成原理总结" class="headerlink" title="计算机组成原理总结"></a>计算机组成原理总结</h2><ul><li>本急救包由崔金钟老师所发复习重点进行填充整理</li></ul><p>[TOC]</p><h3 id="第一章-计算机系统概述"><a href="#第一章-计算机系统概述" class="headerlink" title="第一章 计算机系统概述"></a>第一章 计算机系统概述</h3><p><strong>一、计算机发展历史</strong></p><ol><li><p>从第一代到第四代计算机各自的主要特点</p><ul><li>第一代采用电子管元件</li><li>第二代采用晶体管元件，磁芯作内存，磁鼓、磁带作外存等</li><li>第三代采用中小规模集成电路，半导体存储器作内存，出现了微程序控制，Cache，虚拟存<br>储器，流水线等技术<ul><li>IBM公司提出了“兼容机”的概念<br>(兼容机的好处：可以向后兼容；关键：相同或相似的指令集或操作系统) </li><li>DEC公司提出了总线结构</li></ul></li><li>第四代采用大规模&#x2F;超大规模集成电路（LSI&#x2F;VLSI&#x2F;ULSI），出现了半导体存储器、微处理器，出现了共享存储器，分布式存储器及大规模并行处理系统等技术</li></ul></li><li><p>冯诺依曼结构要点；存储程序思想</p><ul><li><p>存储程序思想：任何要计算机完成的工作都要事先被编写成程序，然后将程序和原始数据送入主存并启动执行。一旦程序被启动，计算机应能在不许操作人员的干预下，自动完成逐条取出指令和执行指令的任务</p></li><li><p>普林斯顿高等研究院开始设计“存储程序”计算机，被称为IAS计算机（并非第一台存储程序计算机，最早是1949年英国剑桥大学完成的EDSAC）</p></li><li><p>冯·诺伊曼结构的主要思想</p><ul><li><p>计算机应由运算器、控制器、存储器、输入设备和输出设备五个基本部件组成</p></li><li><p>各部件功能</p><ul><li><strong>存储器</strong>不仅能存放数据，而且能存放指令，形式上二者没有区别，但计算机应能区分数据还是指令</li><li><strong>控制器</strong>应能自动取出并执行指令，对指令译码生成控制信号</li><li><strong>运算器</strong>应能进行加&#x2F;减&#x2F;乘&#x2F;除四种基本算术运算，并且能进行一些逻辑运算和附加运算</li><li>操作人员可以通过<strong>输入设备</strong>、<strong>输出设备</strong>和主机进行通信</li></ul></li><li><p>内部以<strong>二进制表示</strong>指令和数据</p><p>每条指令由操作码和地址码两部分组成，操作码指出操作类型，地址码指出操作数的地址</p><p>由一串指令组成程序</p></li><li><p>采用<strong>“存储程序”</strong>工作方式</p></li></ul></li></ul></li></ol><p><strong>二、计算机系统的基本组成</strong></p><ol><li><p>现代计算机结构模型的基本构成以及执行程序（指令序列）的步骤</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220611223126533.png" alt="image-20220611223126533" style="zoom:50%;" /><ul><li><p>执行程序（指令序列）的步骤</p><ul><li><p>程序在执行前</p><p>数据和指令事先存放在存储器中，每条指令和每个数据都有地址，指令按序存放，指令由OP、ADDR字段组成，程序起始地址置PC</p></li><li><p>开始执行程序</p><p>第一步：根据PC取指令</p><p>第二步：指令译码</p><p>第三步：取操作数</p><p>第四步：指令执行</p><p>第五步：回写结果</p><p>第六步：修改PC的值</p><p>继续执行下一条指令</p></li></ul></li></ul></li><li><p>指令和数据</p><ul><li><p>程序启动前，指令和数据都存放在存储器中，形式上没有差别，都是0&#x2F;1序列</p></li><li><p>采用“存储程序”工作方式：程序由指令组成，程序被启动后，计算机能自动取出一条一条指令执行，在执行过程中无需人的干预</p></li><li><p>指令执行过程中，指令和数据从存储器被取到CPU，存放在CPU内的寄存器中：指令在IR中，数据在GPR中</p></li><li><p>指令中需给出的信息</p><ul><li>操作性质（操作码）</li><li>源操作数1或&#x2F;和操作数2（立即数、寄存器编号、存储地址）</li><li>目的操作数地址（寄存器编号、存储地址）</li></ul><p>存储地址的描述与操作数的数据结构有关</p></li></ul></li><li><p>软件与硬件的接口界面——ISA指令集体系结构</p><p>只有符合ISA规范的机器语言（由指令代码构成）才能被硬件直接执行</p></li><li><p>系统软件与应用软件的概念</p><ul><li><p>System software(系统软件)——简化编程，并使硬件资源被有效利用</p><ul><li><p>操作系统(Operating System)：硬件资源管理，用户接口</p></li><li><p>语言处理系统：翻译程序+Linker,Debug,etc…</p><p>翻译程序有三类</p><ul><li>汇编程序：汇编语言源程序-&gt;机器目标程序</li><li>编译程序：高级语言源程序-&gt;汇编&#x2F;机器目标程序</li><li>解释程序：将高级语言语句逐条翻译成机器指令并立即执行，不生成目标文件</li></ul></li><li><p>其他实用程序：如磁盘碎片整理程序、备份程序等</p></li></ul></li><li><p>Application software(应用软件)——解决具体应用问题&#x2F;完成具体应用</p><ul><li>各类媒体处理程序：Word&#x2F;Image&#x2F;Graphics</li><li>管理信息系统(MIS)</li><li>Game……</li></ul></li></ul></li></ol><p><strong>三、计算机系统的层次结构</strong> </p><ol><li><p>现代计算机系统从硬件、ISA，到操作系统、语言处理系统和应用程序的层次结构</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220611230635419.png" alt="image-20220611230635419" style="zoom:50%;" /></li><li><p>最终用户、应用程序员、系统管理员、系统程序员分别工作的层面</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220611230157632.png" alt="image-20220611230157632" style="zoom:50%;" /></li><li><p>ISA涉及的主要内容（Instruction Set Architecture，指令集体系结构）</p><ul><li>ISA是一种规约，它规定了<strong>如何使用硬件</strong><ul><li>可执行的指令的集合，包括<strong>指令格式</strong>、<strong>操作种类</strong>以及每种操作对应的操作数的响应规定</li><li>指令可以接受的<strong>操作数类型</strong></li><li>操作数所能存放的寄存器组的结构，包括每个<strong>寄存器的名称、编号、长度和用途</strong></li><li>操作数所能存放的<strong>存储空间的大小和编址方式</strong></li><li>操作数在存储空间存放时按照<strong>大端还是小端方式存放</strong></li><li>指令获取操作数的方式，即<strong>寻址方式</strong></li><li>指令执行过程的控制方式，包括<strong>程序计数器、条件码定义</strong>等</li></ul></li></ul></li></ol><p><strong>四、计算机系统性能评价</strong></p><ol><li><p>一些概念</p><ul><li><p>响应时间（执行时间或等待时间）：指从作业提交开始到作业完成所用的时间</p></li><li><p>吞吐率（带宽）：指单位时间内所完成的工作量</p></li><li><p>基本的性能评价标准：CPU执行时间：执行程序中全部指令的时间</p></li><li><p>CPU时间：CPU真正花在程序执行上的时间</p><ul><li>用户CPU时间：用来运行用户代码的时间</li><li>系统CPU时间：为了执行用户程序而需要运行操作系统程序的时间</li></ul></li><li><p>MIPS：指每秒执行多少百万条指令（定点数指令）Million Instruction Per Second</p><p>$MIPS&#x3D;Instruction<del>Count&#x2F;(Second\times 10^6)&#x3D;Clock</del>Rate&#x2F;(CPI\times 10^6)$ </p></li><li><p>MFLOPS：每秒执行的浮点运算有多少百万次，反映机器对浮点数处理的速度</p><p>Million Float-point Operations Per Second</p><p>$MFLOPS&#x3D;FP~Operations&#x2F;(Second\times10^6)$</p><ul><li>GFLOPS（$10^9$次&#x2F;秒）</li><li>TFLOPS（$10^{12}$次&#x2F;秒）</li><li>PFLOPS（$10^{15}$次&#x2F;秒）</li></ul></li></ul></li><li><p>CPI的计算</p><ul><li><p>CPI：Cycle Per Instruction 每条指令执行的时钟周期数</p></li><li><p>对于一条指令而言，其CPI是一个确定的值</p><p>对于某一个程序或一台机器而言，其CPI是一个平均值，表示该程序或该机器指令集中每条指令执行时平均需要多少时钟周期</p></li><li><p>CPI 一般用来衡量指令集体系结构（ISA）及其ISA的具体实现（Organization &amp; Technology）的综合性能</p></li><li><p>$CPI&#x3D;CPU时钟周期数(程序)\div 指令条数(程序)$</p><p>$CPU时钟周期数(程序)&#x3D;指令条数(程序)\times CPI$</p><p>$CPU执行时间&#x3D;CPU时钟周期数(程序)\times 时钟周期&#x3D;CPU时钟周期数(程序)\div 时钟频率&#x3D;指令条数(程序)\times CPI\times 时钟周期$</p></li><li><p>假定$CPI_i$和$C_i$分别为第$i$类指令和指令条数，则程序的总时钟数为$\sum\limits_{i&#x3D;1}^nCPI_i\times C_i$</p><p>因此CPU时间为$时钟周期\times\sum\limits_{i&#x3D;1}^nCPI_i\times C_i$</p></li><li><p>假定$CPI_i$和$F_i$是个指令的CPI和在程序中出现的频率，则程序综合CPI为$\sum\limits_{i&#x3D;1}^nCPI_i\times F_i$</p><p>其中$F_i&#x3D;\frac{C_i}{Instruction_Count}$</p></li><li><p>已知CPU时间、时钟频率、总时钟数、指令条数，则综合程序CPI为：$CPI&#x3D;(CPU时间\times时钟频率)&#x2F;指令条数&#x3D;总时钟周期数&#x2F;指令条数$</p></li></ul><blockquote><p>例题：程序P在机器A上运行需10s，机器A的时钟频率为400MHz。 现在要设计一台机器B，希望该程序在B上运行只需6s。</p><p>机器B时钟频率的提高导致了其CPI的增加，使得程序P在机器B上时钟周期数是在机器A上的1.2倍。机器B的时钟频率达到A的多少倍才能使程序P在B上执行速度是A上的10&#x2F;6&#x3D;1.67倍？</p><blockquote><p>$时钟周期数A&#x3D;CPU时间A\times时钟频率A&#x3D;10s\times 400MHz&#x3D;4000M个$</p><p>$因此时钟周期数B&#x3D;1.2\times 4000M个$</p><p>$时钟频率B&#x3D;时钟周期数B&#x2F;CPU时间B&#x3D;1.2\times4000M&#x2F;6s&#x3D;800MHz$</p><p>$故机器B的时钟频率达到A的2倍$</p></blockquote></blockquote></li><li><p>性能评价的工具——基准程序(Benchmarks)</p><ul><li><p>基准测试程序是专门用来进行性能评价的一组程序<br>不同用户使用的计算机用相同的基准程序<br>基准程序通过运行实际负载来反映计算机的性能<br>最好的基准程序是用户实际使用的程序或典型的简单程序</p></li><li><p>一个公用的基准程序：SPEC</p></li><li><p>综合性能评价</p><ul><li>算术平均</li><li>几何平均</li></ul></li></ul></li></ol><h3 id="第二章-数据的机器级表示"><a href="#第二章-数据的机器级表示" class="headerlink" title="第二章 数据的机器级表示"></a>第二章 数据的机器级表示</h3><p><strong>一、数值数据的表示</strong></p><ol><li><p>定点数的表示</p><ul><li><p>带符号数的表示</p><ul><li><p>原码：一个二进制数，用0-1代码表示符号，数值位不变</p><p>$+1001010\rightarrow01001010$       $-1001010\rightarrow11001010$ </p><p>字长为8的原码，有两种0的表示形式，表示范围-127~+127</p><p>因其0表示不唯一、加减运算不统一、符号位额外处理、a&lt;b时不易实现a-b，故不用原码表示整数</p></li><li><p>补码：定点整数（假定补码有n位）则$[X]_补&#x3D;2^n+X\quad(-2^n\le X&lt;2^n,mod~2^n)$</p><ul><li><p>对于正数（字长8位）$[X]_补&#x3D;[X]_原\quad X\ge0$</p></li><li><p>对于负数（字长8位）符号位仍为1 其余位按位取反，末位加1</p><p>$[X]_补&#x3D;[X]_反+1\quad X&lt;0$</p></li><li><p>字长8位的补码表示范围-128~+127</p></li><li><p>求补（变补），已知$[X]_补$，求$[-X]_补$</p><p>$[X]_补$的代码连同符号位一起变反，末位再加1，即得到$[-X]_补$</p></li></ul></li><li><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220612132839610.png" alt="image-20220612132839610" style="zoom:50%;" /></li><li><p>移码表示：将每一个数值加上一个偏置常数，当编码位数为n时，bias取$2^{n-1}$</p><p>移码和补码仅第一位不同，其余位相同</p><p>移码主要用来表示浮点数阶码：便于浮点数加减运算时的对阶操作</p></li></ul></li><li><p>带符号整数与无符号数比较</p><ul><li><p>扩充操作差别</p><p>无符号数（0拓展）</p><p>带符号数（符号拓展）</p><blockquote><p>例题：在32位机器上输出si, usi, i, ui的十进制（真值）和十六进制值（机器数）是什么？</p><p> short si &#x3D; -32768;</p><p> unsigned short usi &#x3D; si;</p><p> int i &#x3D; si;</p><p> unsingned ui &#x3D; usi;</p><p>提示：$32768&#x3D;2^{15}&#x3D;1000<del>0000</del>0000~0000B$</p><blockquote><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220612135854845.png" alt="image-20220612135854845" style="zoom:50%;" /></blockquote></blockquote></li><li><p>数的比较有差别</p><p>无符号数：MSB为1的数比MSB为0的数大</p><p>带符号整数：MSB为1的数比MSB为0的数小</p></li><li><p>溢出判断有差异：无符号数根据最高位是否有进位判断溢出，通常不判</p></li></ul></li></ul></li><li><p>浮点数表示IEEE754标准</p><ul><li><p>单精度32位和双精度64位的格式与偏置常数的取值</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220612140718846.png" alt="image-20220612140718846" style="zoom:50%;" /><ul><li><p>Sign bit：1表示negative；0表示positive</p></li><li><p>Exponent（阶码&#x2F;指数）</p><p>SP规格化数阶码范围0000 0001(-126)~1111 1110(127)</p><p>偏置bias为$2^7-1&#x3D;127(single)$     $2^10-1&#x3D;1023(double)$</p></li><li><p>Significand（尾数）</p><p>规格化尾数最高位总是1，所以隐含表示，省1位</p><p>$1+23bits(single)$    $1+52bits(double)$</p></li><li><p>SP：$(-1)^S\times(1+Significand)\times2^{(Exponent-127)}$</p><p>DP：$(-1)^S\times(1+Significand)\times2^{(Exponent-1023)}$</p></li></ul></li><li><p>IEEE754浮点数几个特殊数据的表示形式</p><ul><li><p>0</p><p>阶码全0，尾数全0，符号位0&#x2F;1均有效</p></li><li><p>$+\infin&#x2F;-\infin$</p><p>阶码全1，尾数全0，符号位为0为$+\infin$，符号位为1为$-\infin$</p><p>浮点数除0结果是无穷，整数除0为异常</p></li><li><p>非数NaN</p><p>阶码全1，尾数非0</p></li><li><p>非规格化数</p><p>阶码全0，尾数非0    $(-1)^S\times0.aa\ldots a\times2^{-126}$</p></li></ul></li><li><p>十进制数的表示</p><ul><li><p>用ASCII码表示十进制数：前分隔数字串和后嵌入数字串两种格式表示正负号</p><p>0-9分别对应30H-39H，一位十进制数对应8位二进制数</p><ul><li><p>前分隔数字串</p><p>符号位单独用一个字节表示，位于数字串之前</p><p>正号用“+”的ASCII码(2BH)表示；负号用“-”的ASCII码(2DH)表示</p></li><li><p>后嵌入数字串</p><p>符号位嵌入最低为数字的ASCII码高4位中，比前分隔方式省一个字节</p><p>嵌入式方法：正数不变；负数变为0111</p></li><li><p>ASCII码缺点：占用空间大，且需转换成二进制数或BCD码才能计算</p></li></ul></li><li><p>用BCD码表示十进制数：正负数的表示方法，<strong>位数不等于8Bit的整数倍时需补0</strong></p><p>0000~1001表示0~9，4位权值分别为8、4、2、1</p><p>符号位的表示    “+”1100    “-”1101</p></li></ul></li></ul></li></ol><p><strong>二、非数值数据的表示</strong></p><ol><li><p>西文字符常用编码为7位ASCII码</p><p>48为0 65为A 97为a</p></li><li><p>汉字的编码</p><ul><li><p>输入码：对汉字用相应按键进行编码表示，用于输入</p></li><li><p>内码：用于在系统中进行存储、查找、传送等处理（2个字节）</p></li><li><p>字模点阵或轮廓描述：描述汉字字模点阵或轮廓，用于显示&#x2F;打印</p></li></ul></li></ol><p><strong>三、数据的宽度，存储和排列顺序</strong></p><ol><li><p>数据的基本宽度</p><ul><li><p>比特bit是计算机中处理、存储、传输信息的最小单元</p></li><li><p>二进制信息的计量单位是“字节”Byte</p><ul><li>现代计算机中，存储器按字节编址</li><li>字节是最小可寻址单元</li><li>如果以字节为一个排列单位，则LSB表示最低有效字节，MSB表示最高有效字节</li></ul></li><li><p>字：表示被处理信息的单位，用来度量数据类型的宽度</p><p>字长：某特定机器定点运算时数据通路的宽度（CPU总线宽度等）</p><p>IA-32中1个字&#x3D;2个字节，1个字长&#x3D;4个字节</p></li></ul></li><li><p>数据按字节存储时，多字节数据的地址涉及到数据是大端方式还是小端方式</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220612154236274.png" alt="image-20220612154236274" style="zoom: 33%;" /></li><li><p>指令存放时大端和小端只影响指令中的多字节常数，不影响其他字段的存放顺序</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220612154522722.png" alt="image-20220612154522722" style="zoom:33%;" /></li><li><p>数据存储时存在边界对齐和不对齐问题，它们在存储空间和访问速度上存在差异</p><p>对齐：要求数据的地址是相应的边界地址</p><p>不同数据存放时两种处理方式</p><ul><li>按边界对齐（假定存储字的宽度为32位，按字节编址）<ul><li>字地址：4的倍数（低两位为0）</li><li>半字地址：2的倍数（低位为0）</li><li>字节地址：任意</li></ul></li><li>不按边界对齐：可能会增加访存次数</li></ul><p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220612160251989.png" alt="image-20220612160251989" style="zoom: 25%;" /><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220612160342131.png" alt="image-20220612160342131" style="zoom: 25%;" /></p></li></ol><p><strong>四、数据的检错与纠错</strong></p><ol><li>基本原理：大多采用“冗余校验”思想，即除原数据信息外，还增加若干位编码，这些新增的代码被称为校验位。</li><li>常见数据校验编码<ul><li>奇偶校验码（不具有纠错能力）<ul><li>基本思想：增加一位奇（偶）校验位并一起存储或传送，根据终部件得到的相应数据和校验位，再求出新校验位，最后根据新校验位确定是否发生了错误</li><li>若新旧校验位不等，表示终部件有<strong>奇数位错</strong></li><li>若新旧校验位相等，表示终部件<strong>数据正确</strong>或有<strong>偶数位错</strong></li></ul></li><li>海明校验码</li><li>循环冗余校验码</li></ul></li></ol><h3 id="第三章-运算方法和运算部件"><a href="#第三章-运算方法和运算部件" class="headerlink" title="第三章 运算方法和运算部件"></a>第三章 运算方法和运算部件</h3><p><strong>一、串行进位加法器与并行进位加法器</strong></p><ol><li><p>并行进位加法器比串行进位加法器速度快的原因</p><ul><li><p>串行进位加法器</p><p>$CarryOut&#x3D;(B\and CarryIn)\or (A\and CarryIn) \or (A\and B)$</p><p>$Sum&#x3D;A\oplus B\oplus CarryIn$</p><p>缺点：进位按串行方式传递，速度慢</p><p>采用串行逐级传递进位，电路延迟与位数成正比关系</p></li><li><p>并行进位加法器</p><p>采用先行进位方式，令进位生成函数$G_i&#x3D;A_iB_i$，进位传递函数$P_i&#x3D;A_i+B_i$</p><p>全加逻辑方程：$S_i&#x3D;A_i\oplus B_i\oplus C_i$    $C_{i+1}&#x3D;G_i+P_iC_i$</p><p><strong>各进位之间无等待，相互独立并同时产生</strong></p></li></ul></li><li><p>全先行进位加法器、局部先行进位加法器和多级先行进位加法器的区别</p><ul><li><p>全先行进位加法器，把所有进位一同并行计算，成本过高（高位逻辑方程过于复杂）</p></li><li><p>局部先行进位加法器，连接一些N位先行加法器，形成一个大加法器，传递进位，但高位依赖低位传递的进位，仍有较长延迟</p><p>组内并行，组间串行</p></li><li><p>多级先行进位加法器，引入组进位生成&#x2F;传递函数（新G、P，$C_{i+1}&#x3D;G_i^*+P_i^*C_0$）实现”组内并行，组间并行“的进位方式</p></li></ul></li></ol><p><strong>二、ALU的构成</strong></p><ol><li><p>整数加减运算器的基本构成（关键:如何实现减法运算）</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220612165649007.png" alt="image-20220612165649007" style="zoom:50%;" /><p>$[A+B]_补&#x3D;[A]_补+[B]_补(mod<del>2^n)$    $[A-B]_补&#x3D;[A]_补+[-B]_补(mod</del>2^n)$    $[-B]_补&#x3D;\overline{[B]}_补+1$</p><p>Sub为1，做减法；sub为0，做加法</p></li><li><p>ALU如何控制实现加、减、与、或等等各种功能</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220612170122513.png" alt="image-20220612170122513" style="zoom: 50%;" /><p>算术逻辑部件ALU</p><ul><li><p>进行基本算术运算与逻辑运算</p><ul><li>无符号整数加、减</li><li>带符号整数加、减</li><li>与、或、非、异或等逻辑运算</li></ul></li><li><p>输出除和&#x2F;差等，还有标志信息</p></li><li><p>有一个操作控制端（ALUop）来决定ALU所执行的处理功能</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220612170830900.png" alt="image-20220612170830900" style="zoom:50%;" /></li></ul></li><li><p>ALU的OF、SF、CF和ZF等标志信息如何产生</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220612171813605.png" alt="image-20220612171813605" style="zoom:50%;" /><ul><li>溢出标志OF：$OF&#x3D;C_n\oplus C_{n-1}$或A与B’同号但与Sum不同号，则OF&#x3D;1</li><li>符号标志SF：$SF&#x3D;F_{n-1}$</li><li>零标志ZF：$ZF&#x3D;1当且仅当F&#x3D;0$</li><li>进位&#x2F;借位标志CF：$CF&#x3D;Cout\oplus Cin(sub)$</li></ul></li><li><p>如何判断无符号数和带符号数加减运算时发生溢出</p><ul><li><p>加法</p><ul><li>无符号数加溢出条件：$CF&#x3D;1$</li><li>有符号数加溢出条件：$OF&#x3D;1$或A与B’同号但与Sum不同号</li></ul><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220612173014025.png" alt="image-20220612173014025" style="zoom:33%;" /></li><li><p>减法</p><ul><li><p>无符号数减溢出：差为负数，即借位$CF&#x3D;1$</p></li><li><p>带符号数减溢出：$OF&#x3D;1$或A与B’同号但与Sum不同号</p></li><li><p>比较大小规则</p><ul><li>无符号数：$CF&#x3D;0\and ZF&#x3D;0$，大于</li><li>有符号数：$OF&#x3D;SF\and ZF&#x3D;0$，大于</li><li>$ZF&#x3D;1$，等于</li></ul></li></ul></li></ul></li></ol><p><strong>三、定点数的加减乘法运算方法</strong></p><ol><li><p>补码、原码、移码的加减运算方法</p><ul><li><p>原码加&#x2F;减运算：用于浮点数尾数运算，符号位和数值部分分开处理</p><ul><li><p>比较两数符号，对加法执行”同号求和，异号求差“，对减法进行”异号求和，同号求差“</p></li><li><p>求和：数值位相加，和的符号取被加数（或被减数）的符号</p><p>若最高位产生进位，则结果溢出</p></li><li><p>求差：加数（或减数）求补后与被加数（被减数）相加</p><ul><li><p>最高位产生进位（Cout&#x3D;1）则无借位（CF&#x3D;0），表示够减结果为正，该结果即为差的数值位的原码</p></li><li><p>最高位无进位（Cout&#x3D;0）则CF&#x3D;1，结果为负，它是差的数值位的补码形式，需对结果求补，还原为原码形式的数值位</p></li><li><p>差的符号位：对于第一种情况，符号位取被加数（被减数）的符号</p><p>对于第二种情况，符号位取相反符号</p></li></ul></li></ul><blockquote><p>例题：已知$[X]_原&#x3D;1.0011,[Y]_原&#x3D;1.1010,计算[X+Y]_原与[X-Y]_原$</p><blockquote><p>(1)同号相加，则求和</p><p>和的数值位：0011+1010&#x3D;1101</p><p>和的符号位：1</p><p>$[X+Y]_原&#x3D;1.1101$</p><p>(2)同号相减，则求差</p><p>差的数值位：0011+0110&#x3D;1001</p><p>无进位，加法结果为负，需对1001求补为0111</p><p>差的符号位为被减数X取反后的符号为0</p><p>$[X-Y]_原&#x3D;0.0111$</p></blockquote></blockquote></li><li><p>移码加&#x2F;减运算：用于浮点数阶码运算，符号位和数值位可以一起处理</p><ul><li>加法：直接将$[E1]_移$与$[E2]_移$进行模$2^n$加，对结果符号取反</li><li>减法：先将减数$[E2]_移$求补，然后与被减数$[E1]_移$进行模$2^n$相加，最后对结果的符号取反</li><li>溢出判断，若模$2^n$相加时，两个加数符号相同并且与和数的符号也相同，则发生溢出</li></ul><blockquote><p>例题：用四位移码计算-3+6与-3-5的值</p><blockquote><p>(1)$[-3]_移+[6]_移&#x3D;0101+1110&#x3D;1011(符号取反后)$，故真值为+3</p><p>(2)$[-3]_移-[5]_移&#x3D;0101+0011&#x3D;0000(符号取反后)$，故真值为-8</p></blockquote></blockquote></li></ul></li><li><p>无符号数乘法的机器实现基本步骤</p><p>递推公式：$P_{i+1}&#x3D;2^{-1}(x\cdot y_{n-i}+P_{i})$，其中$Y&#x3D;y_1y_2\ldots y_n$</p><p>思想：$P_0&#x3D;0$，部分积右移后与$x\cdot y_i$相加</p><p>对乘数中为“1”的位执行加法和右移，对为“0”的位只执行右移，而不执行加法运算</p></li><li><p>无符号数乘法的硬件逻辑结构</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220612202424634.png" alt="image-20220612202424634" style="zoom:33%;" /><ul><li>快速乘法器可考虑流水线方式或硬件叠加方式</li></ul></li><li><p>原码一位乘法机器实现的基本原理</p><p>用于浮点数尾数乘运算，符号与数值分开处理：积符由异或得到，数值用无符号乘法运算</p><blockquote><p>例题：设$[x]_原&#x3D;0.1110，[y]_原&#x3D;1.110$，计算$[x\times y]_原$</p><blockquote><p>数值部分用无符号乘法算法计算：$1110\times 1101&#x3D;1011~0110$</p><p>符号位：$0\oplus 1&#x3D;1$，故$[x\times y]_原&#x3D;1.10110110$</p></blockquote></blockquote></li></ol><p><strong>四、浮点数运算</strong></p><ol><li><p>浮点数加减运算（假定$M_x、M_y$分别是X和Y的尾数，$E_x、E_y$分别是X和Y的阶码）</p><ul><li><p><strong>对阶操作</strong>：目的是使两数阶码相等，小阶向大阶看齐，右移位数等于两个阶码差的绝对值</p><p>IEEE 754尾数右移时，要将隐含的“1”移到小数部分，高位补0，移出的低位保留到特定的“附加位”上</p><ul><li><p>求阶差</p><p>$[\Delta E]_补&#x3D;[E_x-E_y]_补&#x3D;[E_x]_移+[-[E_y]_移]_补(mod~2^n)$</p><p>通过符号可判断$\Delta E&gt;0$还是$\Delta E\le 0$</p></li><li><p>对阶</p><ul><li>若$\Delta E\le0$，则$E_x\leftarrow E_y，M_x\leftarrow M_x\times 2^{E_x-E_y}，E_b\leftarrow E_y$</li><li>若$\Delta E&gt;0$，则$E_y\leftarrow E_x，M_y\leftarrow M_y\times 2^{E_y-E_x}，E_b\leftarrow E_x$</li></ul></li></ul></li><li><p><strong>尾数相减</strong>：使用原码加减法，计算包含隐含位与右移附加位</p></li><li><p><strong>尾数规格化</strong></p><ul><li>±1x .xx……x形式时，则右规：尾数右移1位，阶码加1</li><li>±0.0…01x…x 形式时，则左规：尾数左移k位，阶码减k</li></ul></li><li><p><strong>尾数舍入处理</strong>：去除附加位</p><ul><li><p>就近舍入：舍入为最近可表示的数</p><p>若为非中间值：0舍1入；</p><p>若为中间值：强迫结果为偶数</p></li><li><p>朝$+\infin$方向舍入：舍入为右边最近可表示数(正向舍入)</p></li><li><p>朝$-\infin$方向舍入：舍入为左边最近可表示数 (负向舍入)</p></li><li><p>朝0方向舍入：直接截取所需位，后面的位丢弃</p></li></ul></li><li><p><strong>溢出判断</strong>：若上溢，置无穷；若下溢，置零</p><ul><li>左规（阶码 - 1）时：先判断阶码是否为全0，若是，则直接置阶码下溢；否则，阶码减1后判断阶码是否为全0，若是，则阶码下溢</li><li>右规（阶码 +1）时：先判断阶码是否为全1，若是，则直接置阶码上溢；否则，阶码加1后判断阶码是否为全1，若是，则阶码上溢</li></ul></li><li><p>![image-20220612231600791](C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220612231600791.png)</p></li><li><blockquote><p>例题：已知x&#x3D;0.5，y&#x3D;-0.4375，求x+y&#x3D;?(用IEEE754标准单精度格式计算)</p><blockquote><p>$x&#x3D;0.5&#x3D;1&#x2F;2&#x3D;(0.100\ldots0)_2&#x3D;(1.00\ldots0)_2\times2^{-1}$</p><p>$y&#x3D;-0.4325&#x3D;(-0.01110\ldots0)_2&#x3D;(-1.110\ldots0)_2\times2^{-2}$</p><p>$[x]_浮&#x3D;0~01111110,00\ldots0$</p><p>$[y]_浮&#x3D;1~01111101，110\ldots0$</p><p>对阶：$[\Delta E]_补&#x3D;01111110+10000011&#x3D;00000001$    $\Delta E&#x3D;1$</p><p>对y进行对阶$[y]_浮&#x3D;1~01111110，1110\ldots0$（高位补隐藏位1）</p><p>尾数相加：$01.0000\ldots0+(10.1110\ldots0)&#x3D;00.0010\ldots0$</p><p>（原码加法，最左边一位为符号位，符号位单独处理）</p><p>需要左归：$+(0.0010\ldots)_2\times2^{-1}&#x3D;+(1.0\ldots0)_2\times2^{-4}$，无溢出</p><p>故$[x+y]_浮&#x3D;0~011111011,0\ldots0$</p><p>故$x+y&#x3D;(1.0)_2\times2^{-4}&#x3D;\frac{1}{16}&#x3D;0.0625$</p></blockquote></blockquote></li></ul></li><li><p>求阶码的和、差</p><ul><li>阶码加法公式$[E_x+E_y]_移&#x3D;E_b&#x3D;E_x+E_y+129(mod~2^8)$</li><li>阶码减法公式$[E_x-E_y]_移&#x3D;E_b&#x3D;E_x+[-E_y]_补+127(mod~2^8)$</li></ul></li></ol><h3 id="第四章-指令系统"><a href="#第四章-指令系统" class="headerlink" title="第四章 指令系统"></a>第四章 指令系统</h3><p><strong>一、指令系统设计</strong></p><ol><li><p>指令中应该包括哪些字段？提供操作数或操作数地址有哪些方式？</p><ul><li><p>指令包含信息</p><ul><li>操作码：指定操作类型（长度：固定&#x2F;可变）</li><li>源操作数及其地址：一个或多个源操作数所在的地址（操作数来源：主存&#x2F;寄存器&#x2F;I&#x2F;O端口）</li><li>结果的地址：产生的结果存放何处（目的操作数）（结果地址：主存&#x2F;寄存器&#x2F;I&#x2F;O端口）</li><li>下一条指令的地址：下条指令存放何处（主存，正常情况下隐含在PC中，改变顺序由指令给出）</li></ul></li><li><p>指令提供操作数方式</p><ul><li><p>零地址指令</p><table><thead><tr><th>OP</th></tr></thead></table><ul><li>无需操作数，如：空操作&#x2F;停机等</li><li>所需操作数为默认位置，如：堆栈&#x2F;累加器等</li></ul></li><li><p>一地址指令</p><p>其地址既是操作数的地址，也是结果的地址</p><table><thead><tr><th>OP</th><th>A1</th></tr></thead></table><ul><li>单目运算，如：取反&#x2F;取负等</li><li>双目运算：另一操作数是默认的，如：累加器等</li></ul></li><li><p>二地址指令（CISC中最常用）</p><p>分别存放双目运算中两个操作数，并将其中一个地址作为结果的地址</p><table><thead><tr><th>OP</th><th>A1</th><th>A2</th></tr></thead></table></li><li><p>三地址指令（RISC风格）</p><p>分别作为双目运算中两个源操作数的地址和一个结果的地址</p><table><thead><tr><th>OP</th><th>A1</th><th>A2</th><th>A3</th></tr></thead></table></li><li><p>多地址指令</p><p>用于成批数据处理的指令，如：向量&#x2F;矩阵等运算的SIMD指令</p></li></ul></li></ul></li><li><p>明白指令格式设计的几个基本原则</p><ul><li>应尽量短</li><li>要有足够的操作码位数</li><li>指令编码必须有唯一的解释，否则是不合法的指令</li><li>指令字长应是字节的整数倍</li><li>合理地选择地址字段的个数</li><li>指令尽量规整</li></ul></li><li><p>掌握一般计算机中8种基本寻址方式产生操作数的过程</p><p>假设 A：地址字段值，R：寄存器编号，EA：有效地址，(X)：X中的内容</p><table><thead><tr><th>方式</th><th>算法</th><th>主要优点</th><th>主要缺点</th></tr></thead><tbody><tr><td>立即</td><td>操作数&#x3D;A</td><td>指令执行速度快</td><td>操作数幅值有限</td></tr><tr><td>直接</td><td>EA&#x3D;A</td><td>有效地址计算简单</td><td>地址范围有限</td></tr><tr><td>间接</td><td>EA&#x3D;(A)</td><td>有效地址范围大</td><td>多次存储器访问</td></tr><tr><td>寄存器</td><td>操作数&#x3D;(R)</td><td>指令执行快，指令短</td><td>地址范围有限</td></tr><tr><td>寄存器间接</td><td>EA&#x3D;(R)</td><td>地址范围大</td><td>额外存储器访问</td></tr><tr><td>偏移</td><td>EA&#x3D;A+(R)</td><td>灵活</td><td>复杂</td></tr><tr><td>堆栈</td><td>EA&#x3D;栈顶</td><td>指令短</td><td>应用有限</td></tr></tbody></table><ul><li>偏移方式有相对&#x2F;基址&#x2F;变址三种<ul><li>相对寻址：EA&#x3D;A+(PC) Beq</li><li>基址寻址：EA&#x3D;A+(B) lw&#x2F;sw</li><li>变址寻址：EA&#x3D;A+(I)</li></ul></li></ul></li><li><p>掌握变长操作码编码方法的基本原理</p><ul><li><p>基本思想：将操作码的编码长度分成几种固定长的格式</p></li><li><p>种类</p><ul><li>等长拓展法：4-8-12；3-6-9……</li><li>不等长拓展法</li></ul></li><li><blockquote><p>例题：设某指令系统指令字是16位，每个地址码为6位。若二地址指令15条，一地址指令34条，则剩下零地址指令最多有多少条？</p><blockquote><p>操作码由短到长进行拓展编码</p><p>二地址指令：操作码4位(0000~1110：15条)</p><p>一地址指令：操作码10位11110(00000~11111：32条)；11111(00000~00001：2条)</p><p>零地址指令：操作码16位11111(00010~11111：30)(000000~111111：64)</p><p>故零地址指令最多由$30\times64&#x3D;1920条$</p></blockquote></blockquote></li></ul></li><li><p>条件码的产生；条件码的应用：无符号数的大小比较方法和带符号数的比较方法</p><ul><li><p>条件转移指令通常根据Condition Codes (条件码CC&#x2F;状态位&#x2F;标志位)转移</p></li><li><p>常用标志（条件码）</p><ul><li>SF-negative</li><li>OF-overflow</li><li>CF-进位&#x2F;借位</li><li>ZF-zero</li></ul></li><li><p>标志可存放于标志寄存器&#x2F;条件码寄存器&#x2F;状态寄存器&#x2F;程序状态寄存器</p></li><li><p>例如sub r1, r2, r3;r2和r3相减,结果在r1中，并生成标志位ZF、CF等</p><p>bz label;标志位ZF&#x3D;1时转到label处执行；否则顺序执行</p></li><li><p>无符号数：$CF&#x3D;0\and ZF&#x3D;0$，大于</p><p>有符号数：$OF&#x3D;SF\and ZF&#x3D;0$​，大于</p></li></ul></li><li><p>了解堆栈型、累加器型、通用寄存器型和装入&#x2F;存储型四种指令格式风格操作过程和特点</p><p>掌握CISC和RISC两类指令的特点</p><p>了解CISC指令系统的2&#x2F;8规律</p><ul><li><p>四种指令格式风格</p><ul><li><p>累加器型</p><p>特点：其中一个操作数（源操作数1）和目的操作数总在累加器中</p><table><thead><tr><th>1 address</th><th>add A</th><th>acc$\leftarrow$acc+mem[A]</th></tr></thead><tbody><tr><td>1(+x) address</td><td>add x A</td><td>acc$\leftarrow$acc+mem[A+x]</td></tr></tbody></table></li><li><p>堆栈型</p><p>特点：总是将栈顶两个操作数进行运算，指令无需指定操作数地址</p><table><thead><tr><th>0 address</th><th>add</th><th>tos$\leftarrow$tos+next</th></tr></thead></table></li><li><p>通用寄存器型</p><p>特点：操作数可以是寄存器或存储器数据（即A、B和C可以是寄存器或存储单元）</p><table><thead><tr><th>2 address</th><th>add A B</th><th>EA(A)$\leftarrow$EA(A)+EA(B)</th></tr></thead><tbody><tr><td>3 address</td><td>add A B C</td><td>EA(A)$\leftarrow$EA(B)+EA(C)</td></tr></tbody></table></li><li><p>装入&#x2F;存储型</p><p>特点：运算指令的操作数只能是寄存器数据，只有load&#x2F;store能访问存储器</p><table><thead><tr><th>3 address</th><th>add Ra Rb Rc</th><th>Ra$\leftarrow$Rb+Rc</th></tr></thead><tbody><tr><td>2 address</td><td>load Ra Rb</td><td>Ra$\leftarrow$mem[Rb]</td></tr><tr><td>2 address</td><td>store Ra Rb</td><td>mem[Rb]$\leftarrow$Ra</td></tr></tbody></table></li></ul></li><li><p>指令格式复杂度</p><ul><li>复杂指令集计算机CISC<ul><li>指令系统复杂：变长操作码&#x2F;变长指令字&#x2F;指令多&#x2F;寻址方式多&#x2F;指令格式多</li><li>指令周期长：绝大多数指令需要多个时钟周期才能完成</li><li>各种指令都能访问存储器：除了专门的存储器读写指令外，运算指令也能访问存储器</li><li>采用微程序控制</li><li>有专用寄存器</li><li>难以进行编译优化来生成高校目标代码</li></ul></li><li>精简指令集计算机RISC（MIPS）<ul><li>简化的指令系统：指令少&#x2F;寻址方式少&#x2F;指令格式少&#x2F;指令长度一般</li><li>以RR方式工作：除Load&#x2F;Store指令可访问存储器外，其余指令只能访问寄存器</li><li>指令周期短：以流水线方式工作，因而除Load&#x2F;Store指令外，其他简单指令都只需一个或一个不到时钟周期</li><li>采用大量通用寄存器，减少访存次数</li><li>采用硬连线控制器控制，不用或少用微程序控制</li><li>采用优化的编译系统，力求有效地支持高级语言程序</li></ul></li></ul></li><li><p>CISC指令系统的2&#x2F;8规律</p><p>在程序中各种指令出现的频率悬殊很大，最常使用的是一些简单指令，这些指令占程序的80%，但只占指令系统的20%</p><p>在微程序控制的计算机中，占指令总数20%的复杂指令占用了控制存储器容量的80%</p></li></ul></li></ol><p><strong>二、程序的机器级表示</strong></p><ol><li><p>MIPS指令有哪些寻址方式？有哪些特有的寻址方式？掌握MIPS的基本汇编指令表示</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220613145631942.png" alt="image-20220613145631942" style="zoom:33%;" /><ul><li><p>汇编形式</p><ul><li><p>R型：指令(sub)    rd, rs, rt</p></li><li><p>I型</p><p>运算指令：指令(ori)    rt, rs, imm16</p><p>Load&#x2F;Store：指令(lw&#x2F;sw)    rt, rs, imm16</p><p>条件分支指令：指令(beq)    rs, rt, imm16</p></li><li><p>J型：指令(j)    target</p></li></ul></li></ul></li><li><p>掌握MIPS计算机的R型、I型和J型三种指令格式</p><ul><li><p>R型指令</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220613150436155.png" alt="image-20220613150436155" style="zoom: 33%;" /><ul><li><p>参与操作的3个操作数都是寄存器操作数</p></li><li><p>R型指令的op全为0，具体功能由func部分决定</p></li><li><p>rs：第一个源操作数</p><p>rt：第二个源操作数</p><p>rd：目的寄存器</p><p>shamt：对非移位指令为00000，移位指令为移位次数</p></li><li><table><thead><tr><th>指令</th><th>[31:26]</th><th>[25:21]</th><th>[20:16]</th><th>[15:11]</th><th>[10:6]</th><th>[5:0]</th><th>功能</th></tr></thead><tbody><tr><td>add</td><td>000000</td><td>rs</td><td>rt</td><td>rd</td><td>00000</td><td>100000</td><td>寄存器加</td></tr><tr><td>sub</td><td>000000</td><td>rs</td><td>rt</td><td>rd</td><td>00000</td><td>100010</td><td>寄存器减</td></tr><tr><td>and</td><td>000000</td><td>rs</td><td>rt</td><td>rd</td><td>00000</td><td>100100</td><td>寄存器与</td></tr><tr><td>or</td><td>000000</td><td>rs</td><td>rt</td><td>rd</td><td>00000</td><td>100101</td><td>寄存器或</td></tr><tr><td>xor</td><td>000000</td><td>rs</td><td>rt</td><td>rd</td><td>00000</td><td>100110</td><td>寄存器异或</td></tr><tr><td>sll</td><td>000000</td><td>00000</td><td>rt</td><td>rd</td><td>sa</td><td>000000</td><td>左移</td></tr><tr><td>srl</td><td>000000</td><td>00000</td><td>rt</td><td>rd</td><td>sa</td><td>000010</td><td>逻辑右移</td></tr><tr><td>sra</td><td>000000</td><td>00000</td><td>rt</td><td>rd</td><td>sa</td><td>000011</td><td>算术右移</td></tr><tr><td>jr</td><td>000000</td><td>rs</td><td>00000</td><td>00000</td><td>00000</td><td>001000</td><td>寄存器跳转</td></tr></tbody></table></li></ul></li><li><p>I型指令</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220613151148160.png" alt="image-20220613151148160" style="zoom:33%;" /><ul><li><p>指令中包含1个立即数，它可能是1个操作数，或存储器的偏移地址</p></li><li><p>op：确定指令功能</p><p>rs：一个源操作数，是寄存器操作数；或者在存取指令中用于偏移寻址方式中的基地址寄存器</p><p>rt：目的寄存器</p><p>Immediate：立即数，可以是第2个源操作数，或者是偏移寻址中的偏移量</p></li><li><table><thead><tr><th>指令</th><th>[31:26]</th><th>[25:21]</th><th>[20:16]</th><th>[15:0]</th><th>功能</th></tr></thead><tbody><tr><td>addi</td><td>001000</td><td>rs</td><td>rt</td><td>immediate</td><td>立即数加</td></tr><tr><td>andi</td><td>001100</td><td>rs</td><td>rt</td><td>immediate</td><td>立即数与</td></tr><tr><td>ori</td><td>001101</td><td>rs</td><td>rt</td><td>immediate</td><td>立即数或</td></tr><tr><td>xori</td><td>001110</td><td>rs</td><td>rt</td><td>immediate</td><td>立即数异或</td></tr><tr><td>lw</td><td>100011</td><td>rs</td><td>rt</td><td>immediate</td><td>取字数据</td></tr><tr><td>sw</td><td>101011</td><td>rs</td><td>rt</td><td>immediate</td><td>存字数据</td></tr><tr><td>beq</td><td>000100</td><td>rs</td><td>rt</td><td>immediate</td><td>相等转移</td></tr><tr><td>bne</td><td>000101</td><td>rs</td><td>rt</td><td>immediate</td><td>不等转移</td></tr><tr><td>lui</td><td>001111</td><td>00000</td><td>rt</td><td>immediate</td><td>设置高位</td></tr></tbody></table></li></ul></li><li><p>J型指令</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220613151509451.png" alt="image-20220613151509451" style="zoom:33%;" /><ul><li><p>op：确定指令功能</p><p>address：转移地址</p></li><li><p>PC高4位不变，将target左移两位，送入PC的低28位</p></li><li><table><thead><tr><th>指令</th><th>[31:26]</th><th>[25:0]</th><th>功能</th></tr></thead><tbody><tr><td>j</td><td>000010</td><td>address</td><td>跳转</td></tr><tr><td>jal</td><td>001100</td><td>address</td><td>调用</td></tr></tbody></table></li></ul></li></ul></li><li><p>高级语言与汇编指令之间的转换：掌握基本的高级语言中的运算表达式 ，If语句，循环，数组访问的汇编语言实现<strong>（理解即可）</strong></p><ul><li><p>算术运算</p><blockquote><p>E.g.  f&#x3D; (g+h) - (i+j)</p><p>assuming f, g, h, i, j be assigned to $1, $2, $3, $4, $5</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220613152833736.png" alt="image-20220613152833736" style="zoom: 50%;" /></blockquote></li><li><p>if语句</p><blockquote><p>if (i&#x3D; &#x3D; j) </p><p>​    f &#x3D; g+h ; </p><p>else </p><p>​    f &#x3D; g-h ;</p><p>Assuming variables i, j, f, g, h, ~ $1, $2, $3, $4, $5</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220613153249758.png" alt="image-20220613153249758" style="zoom:33%;" /></blockquote></li><li><p>循环</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220613153545524.png" alt="image-20220613153545524" style="zoom:33%;" /></li></ul></li></ol><h3 id="第五章-中央处理器"><a href="#第五章-中央处理器" class="headerlink" title="第五章 中央处理器"></a>第五章 中央处理器</h3><p><strong>一、单周期数据通路的设计</strong></p><ul><li>数据通路：由“操作元件”和“存储元件”通过总线方式或分散方式连接而成，进行数据传送、处理和存储</li></ul><ol><li><p>操作元件和存储元件的概念</p><ul><li><p>每条指令功能可由以下四种基本操作实现</p><ul><li>读取某一主存单元的内容，并将其装入某个寄存器（取指， 取数）</li><li>把一个数据从某个寄存器存入给定的主存单元中（存结果）</li><li>把一个数据从某个寄存器送到另一个寄存器或者ALU（取数，存结果）</li><li>进行算术或逻辑运算（PC+1，计算地址，运算）</li></ul></li><li><p>操作元件（组合逻辑元件）</p><ul><li><p>特点：其输出只取决于当前的输入且无时钟信号定时</p></li><li><p>加法器Adder</p><p>多路选择器MUX</p><p>算术逻辑单元ALU</p><p>译码器Decoder</p></li></ul></li><li><p>存储元件（时序逻辑元件）</p><ul><li><p>特点：具有存储功能，在时钟控制下输入被写到电路中，直到下个时钟到达</p><p>输入端状态由时钟决定何时被写入，输出端状态随时可以读出</p></li><li><p>定时方式：规定信号何时写入状态元件或何时从状态元件读出</p><ul><li>边沿触发方式：上升沿&#x2F;下降沿</li></ul></li><li><p>寄存器和寄存器组</p></li><li><p>理想存储器</p></li></ul></li></ul></li><li><p>寄存器和寄存器组、理想存储器的读过程和写过程，以及它们的区别</p><ul><li><p>寄存器</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220613162014659.png" alt="image-20220613162014659" style="zoom:33%;" /><ul><li>有一个写使能（WE）信号<ul><li>WE&#x3D;0：时钟边沿到来时，输出不变</li><li>WE&#x3D;1：时钟边沿到来时，输出变为输入</li></ul></li><li>若每个时钟边沿都写入，则不需WE信号</li></ul></li><li><p>寄存器组：32个寄存器</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220613162027991.png" alt="image-20220613162027991" style="zoom:33%;" /><ul><li><p>两个读口（组合逻辑操作）：busA和busB分别由RA和RB给出地址</p><p>地址RA或RB有效后，经一个取数时间（AccessTime），busA和busB有效</p></li><li><p>一个写口（时序逻辑操作）：写使能为1的情况下，时钟边沿到来时，busW上的值开始被写入RW指定的寄存器中</p></li></ul></li><li><p>理想存储器</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220613163639128.png" alt="image-20220613163639128" style="zoom:33%;" /><ul><li><p>Data Out：32位读出数据</p></li><li><p>Data In：32位写入数据</p></li><li><p>Address：读写公用一个32位地址</p></li><li><p>读操作（组合逻辑操作）</p><p>地址Address有效后，经一个”取数时间AccessTime”，Data Out上数据有效</p></li><li><p>写操作（时序逻辑操作）</p><p>写使能为1的情况下，时钟Clk边沿到来时，Data In传来的值开始被写入Address指定的存储单元中</p></li></ul></li></ul></li><li><p>熟练掌握课件中的最基本的7条指令执行时数据通路中信息的流动过程，以及在取指令部件中的信息处理，包括元件的连接和所需要的各种控制信号的取值等</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220613165100857.png" alt="image-20220613165100857" style="zoom:50%;" /><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220613165952869.png" alt="image-20220613165952869" style="zoom:50%;" /><ul><li><p>PS：其中lw与sw的运算方式为addu，不需要判断溢出</p><p>R型指令需要判断溢出，故overflow与RegWr控制信号经过与门后决定是否写入寄存器</p></li><li><p>R型指令：$R[rd]\leftarrow R[rs]+&#x2F;-R[rt]$</p><p>ori指令：$R[rt]\leftarrow R[rs]<del>or</del>ZeroExt[imm16]$</p><p>lw指令：$R[rt]\leftarrow Data~Memory{R[rs]+SignExt[imm16]}$</p><p>sw指令：$M{R[rs]+SignExt[imm16]}\leftarrow R[rt]$</p><p>beq指令：if  $(R[rs]-R[rt]&#x3D;&#x3D;0)$  then $Zero\leftarrow 1$；else  $Zero\leftarrow 0$</p></li></ul></li></ol><p><strong>二、单周期控制器的设计</strong></p><ol><li><p>运算器的功能是如何控制的？掌握指令译码的基本原理，OP和func字段如何与指令功能对应（参考上图布尔式）</p><ul><li><p>ALU的设计</p><ul><li><p>add：有溢出判断的加法</p><p>sub：有溢出判断的减法</p><p>addu：无溢出判断的加法，即加法器的溢出标志位不输出</p><p>subu：无溢出判断的减法，即加法器的溢出标志位不输出</p><p>or：按位逻辑或运算</p><p>slt：带符号数的大小比较，用两数相减的符合和溢出标志来判断（PPT未考虑）</p><p>sltu：无符号数的大小比较，用两数相减的借位标志来判断（PPT未考虑）</p></li><li><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220613173331388.png" alt="image-20220613173331388" style="zoom:33%;" /></li><li><p>ALUop的编码</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220613173438979.png" alt="image-20220613173438979" style="zoom: 50%;" /></li><li><p>ALU局部控制器</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220613173721774.png" alt="image-20220613173721774" style="zoom:50%;" /></li></ul></li></ul></li><li><p>单周期CPU的周期长度是由什么指令、哪些因素决定的</p><ul><li><p>关键路径时长&#x3D;PC的Clk-to-Q时间+指令存储器的取数时间+寄存器组的取数时间+ALU加法延时+数据存储器的取数时间+写寄存器的建立时间+时钟偏移</p></li><li><p>lw指令的执行时间最长,它所花时间作为时钟周期</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220613171233031.png" alt="image-20220613171233031" style="zoom:33%;" /></li></ul></li></ol><p><strong>三、微程序控制原理</strong></p><ol><li><p>微程序控制器的基本思想</p><ul><li>仿照程序设计的方法，编制每条指令对应的微程序</li><li>每个微程序由若干条微指令构成，各微指令包含若干条微命令</li><li>所有指令对应的微程序放在只读存储器中，执行某条指令就是取出对应微程序中的各条微指令，对微指令译码产生对应的微命令(即控制信号)</li><li>这个只读存储器称为控制存储器（Control Storage），简称控存CS</li></ul></li><li><p>比较硬连线控制器和微程序控制器的优缺点</p><ul><li><p>硬连线控制器</p><ul><li><p>优点：速度快，适合于简单或规整的指令系统，例如，MIPS指令集</p></li><li><p>缺点：它是一个多输入&#x2F;多输出的巨大逻辑网络</p><p>对于复杂指令系统来说，结构庞杂，实现困难；修改、维护不易；灵活性差，甚至无法用有限状态机描述</p></li></ul></li><li><p>微程序控制器</p><p>具有规整性、可维护性和灵活性，但速度慢</p></li></ul></li><li><p>指令、微程序、微指令、微命令、微操作它们之间的关系</p><ul><li><p>将指令的执行转换为微程序的执行</p><p>微程序是一个微指令序列</p><p>每条微指令是一个0&#x2F;1序列，其中包含若干个微命令（即：控制信号）</p><p>微命令控制数据通路的执行</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220613191830028.png" alt="image-20220613191830028" style="zoom:33%;" /></li></ul></li><li><p>了解水平型微指令和垂直型微指令的概念</p><ul><li>水平型微指令<ul><li>基本思想：相容微命令尽量多地安排在一条微指令中</li><li>优点：微程序短，并行性高，适合于较高速度的场合</li><li>缺点：微指令长，编码空间利用率较低，并且编制困难</li></ul></li><li>垂直型微指令<ul><li>基本思想：一条微指令只控制一、二个微命令</li><li>优点：微指令短，编码效率高，格式与机器指令类似，故编制容易</li><li>缺点：微程序长，一条指令只能控制一、二个操作，无并行，速度慢</li></ul></li></ul></li></ol><p><strong>四、异常和中断处理</strong>（第八章也有说明）</p><ol><li><p>异常和中断（外部）的区别</p><ul><li><p>内部“异常”：在CPU内部发生的意外事件或特殊事件</p><ul><li><p>按发生原因分类</p><ul><li>硬故障中断：如电源掉电，硬件线路故障等</li><li>程序性中断：执行某条指令时发生的”例外“，如溢出、缺页、越界、越权、非法指令、除数为0、堆栈溢出、访问超时、断点设置、单步、系统调用等</li></ul></li><li><p>按处理方式分类</p><ul><li><p>故障：执行指令引起的异常事件，如溢出、缺页、堆栈溢出、访问超时</p><p>”断点“为发生故障指令的地址</p></li><li><p>自陷：预先安排的事件，如单步跟踪、系统调用，是一种自愿中断</p><p>”断点“为发生下条指令的地址</p></li><li><p>终止：硬故障时间，此时机器将终止，调出中断服务程序来重启操作系统</p><p>”断点“无所谓</p></li></ul></li></ul></li><li><p>外部”中断“：在CPU外部发生的特殊事件，通过”中断请求“信号向CPU请求处理</p><p>如实时钟、控制台、打印机缺纸、外设准备好、采样计时到、DMA传输结束等</p></li></ul></li><li><p>掌握计算机中对异常&#x2F;中断的软件识别（MIPS计算机）和硬件识别这两种不同方式的基本过程</p><ul><li><p>检测到异常时，处理器必须进行如下处理：</p><ul><li><p>关中断（”中断&#x2F;异常允许“状态位清0）：使处理器处于”禁止中断“状态，以防止新异常（或中断）破坏断点、程序状态和现场（现场指通用寄存器的值）</p></li><li><p>保护断点和程序状态：将断点和程序状态保存到堆栈或特殊寄存器中</p><p>PC$\rightarrow$堆栈或EPC（专门存放断点的寄存器）</p><p>PSWR$\rightarrow$堆栈或EPSWR（专门保存程序状态的寄存器）</p><p>PSW：程序状态字，包括条件码、中断码、状态位等</p><p>PSWR：用于存放程序状态字的寄存器</p></li><li><p>识别异常事件</p><ul><li><p>软件识别（MIPS采用）</p><p>设置一个异常状态寄存器（MIPS中为Cause寄存器），用于记录异常原因。操作系统使用一个统一的异常处理程序，该程序按优先级顺序查询异常状态寄存器的各位，识别出异常事件</p></li><li><p>硬件识别（向量中断方式）（80x86采用）</p><p>用专门的硬件查询电路按优先级顺序识别异常，得到“中断类型号”，根据此号，到中断向量表中读取对应的中断服务程序的入口地址</p></li></ul></li></ul></li></ul></li></ol><h3 id="第六章-指令流水线"><a href="#第六章-指令流水线" class="headerlink" title="第六章 指令流水线"></a>第六章 指令流水线</h3><p><strong>一、流水线数据通路和控制</strong></p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220613215031120.png" alt="image-20220613215031120" style="zoom: 100%;" /><ul><li>Ifetch（取指）：取指令并计算PC+4，指令存储器、Adder</li><li>Reg&#x2F;Dec（取数和译码）：取数同时译码，寄存器堆读口、指令译码器</li><li>Exec（执行）：计算内存单元地址，扩展器，ALU</li><li>Mem（读存储器）：从数据存储器中读，数据存储器</li><li>Wr（写寄存器）：将数据写到寄存器中，寄存器堆写口</li></ul><ol><li><p>单周期指令模型与流水模型的性能比较</p><ul><li>假定以下每步操作所花时间为<ul><li>取值：2ns</li><li>寄存器读：1ns</li><li>ALU操作：2ns</li><li>存储器读：2ns</li><li>寄存器写：1ns</li><li>Load指令执行时间总计为8ns（假定控制单元、PC访问、信号传递无延迟）</li></ul></li><li>单周期模型<ul><li>每条指令在一个时钟周期完成</li><li>时钟周期等于最长的lw指令的执行时间，即8ns</li><li>串行执行时，N条指令的执行时间为8Nns</li></ul></li><li>流水线性能<ul><li>时钟周期等于最长阶段所花时间2ns</li><li>每条指令执行时间为2ns×5&#x3D;10ns</li><li>N条指令执行时间为(4+N)×2ns</li><li>在N很大时，比串行方式提高至4倍</li><li>若各阶段操作均衡（例如均为2ns），则提高至5倍</li></ul></li><li>流水线方式下，单条指令执行时间不能缩短，但能大大提高指令吞吐率</li></ul></li><li><p>具有哪些特征的指令集有利于流水线执行（四个特征）</p><ul><li><p>长度尽量一致，有利于简化取指令和指令译码操作</p><p>MIPS指令32位，下址计算方便：PC+4</p></li><li><p>格式少，且源寄存器位置相同，有利于在指令未知时就可取操作数</p><p>MIPS指令的rs与rt位置一定，在指令译码时可读rs和rt的值</p></li><li><p>Load&#x2F;Store指令才能访问存储器，有利于减少操作步骤，规整流水线</p></li><li><p>内存中“对齐”存放，有利于减少访存次数和流水线的规整</p></li></ul></li><li><p>能对常见的7条指令的各个流水阶段的划分及其所使用的功能部件情况进行分析</p><ul><li><p>R-type</p><p>若含Load指令，4个阶段的R-type会发生结构冒险（同时使用写口）</p><p>改进R-type，使其每条指令有相同多个阶段</p><p>![image-20220613222311688](C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220613222311688.png)</p><p>加一个NOP阶段以延迟“写”操作</p></li><li><p>Store</p><p>![image-20220613222354290](C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220613222354290.png)</p><ul><li>Ifetch：取指令并计算PC+4</li><li>Reg&#x2F;Dec：从寄存器取数，同时指令在译码器进行译码</li><li>Exec：16位立即数符号拓展后与寄存器值相加，计算主存地址</li><li>Mem：将寄存器读出的数据写到主存</li><li>Wr：加一个空的写阶段，使流水线更规整</li></ul></li><li><p>Beq</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220613222618197.png" alt="image-20220613222618197" style="zoom: 80%;" /><ul><li><p>Ifetch：取指令并计算PC+4</p></li><li><p>Reg&#x2F;Dec：从寄存器取数，同时指令在译码器进行译码</p></li><li><p>Exec：执行阶段</p><p>ALU中比较两个寄存器的大小（做减法）</p><p>Adder中计算转移地址</p></li><li><p>Mem：如果比较相等，则转移目标地址写到PC</p></li><li><p>Wrap：加一个空写阶段，使流水线更规整</p></li></ul></li></ul></li><li><p>对于五阶段流水线数据通路，能分析7条指令执行时的各流水段寄存器存储了哪些信息</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220613223102575.png" alt="image-20220613223102575" style="zoom:67%;" /><ul><li>IF&#x2F;ID：PC+4，指令</li><li>ID&#x2F;Ex：R[Rs]，R[Rt]，Rt，Rd，imm16，func，PC+4</li><li>Ex&#x2F;Mem：转移目标地址、Zero、Over、ALUout、Rw</li><li>Mem&#x2F;Wr：ReadData、ALUout、Rw</li></ul></li></ol><p><strong>二、流水线冒险处理</strong></p><ol><li><p>什么是流水线冒险，它分为哪些类型</p><ul><li>流水线冒险：在指令流水线中，当遇到某些情况使得流水线无法正确执行后续指令，而引起流水线阻塞或停顿</li><li>冒险原因不同<ul><li>结构冒险</li><li>数据冒险</li><li>控制冒险</li></ul></li></ul></li><li><p>结构冒险的现象是什么？如何处理结构冒险</p><ul><li>现象：同一个部件同时被不同指令所用，即使用硬件资源时发生了冲突</li><li>解决方法<ul><li>每个部件安排在特定阶段使用</li><li>将Instruction Memory和Data Memory分开</li><li>将寄存器读口与写口独立开来</li></ul></li></ul></li><li><p>数据冒险的现象是什么？分析何时数据冒险，并给出解决方法</p><ul><li><p>现象：后面指令用到前面指令结果时，前面指令的结果还没产生</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220613234228378.png" alt="image-20220613234228378" style="zoom:50%;" /></li><li><p>解决方法</p><ul><li>硬件阻塞（stall）</li><li>软件插入”Nop“指令（浪费空间和时间，无需改数据通路）</li><li>合理实现寄存器组的读&#x2F;写操作：前半时钟周期写，后半时钟周期读</li><li>转发技术：把数据从流水段寄存器中直接取到ALU的输入端，称为转发或旁路</li><li>编译优化——调整指令顺序（不能解决所有数据冒险）</li></ul></li><li><p>Load-use数据冒险：DM读出内容不能直接转发，需要被阻塞一个时钟或加NOP指令</p></li></ul></li><li><p>控制冒险的现象是什么？了解常见的四种处理方法</p><p>PPT省去了对于异常或中断控制冒险的处理，仅考虑分支指令的控制冒险</p><ul><li><p>现象：当遇到改变指令执行顺序的转移指令（调用、返回等）、异常和中断情况时，在形成转移目的地址之前，流水线中已取了后续指令并在执行，这时就需要清除流水线中的部分指令的执行</p></li><li><p>延迟损失时间片C：发生转移时，给流水线带来的延迟损失</p></li><li><p>处理方法</p><ul><li><p>硬件上阻塞（stall）分支指令后续若干指令的执行</p><p>指令清0或操作信号清0，即插入气泡</p></li><li><p>软件上插入“NOP”指令</p></li><li><p>分支预测（Predict）</p><ul><li><p>简单（静态）预测：</p><ul><li><p>总是预测条件不满足，即继续执行分支指令后续指令</p></li><li><p>可加启发式规则：在特定情况下总是预测满足，其他情况总是预测不满足</p><p>如：循环顶部分总是预测为不满足，则能达65%-85%的预测准确率</p></li></ul></li><li><p>动态预测：根据程序执行的历史情况进行动态预测调整，能达90%预测准确率</p></li></ul></li><li><p>延迟分支：把分支指令前面与分支指令无关的指令调到分支指令后进行</p></li></ul></li></ul></li></ol><h3 id="第七章-存储器分层体系结构"><a href="#第七章-存储器分层体系结构" class="headerlink" title="第七章 存储器分层体系结构"></a>第七章 存储器分层体系结构</h3><p><strong>一、存储器概述和存储器芯片</strong></p><ol><li><p>熟悉随机存取存储器、顺序存取存储器、直接存取存储器、相联存储器、只读存储器、读写存储器、非易失（不挥发）性存储器、易失（挥发）性存储器、静态存储器、动态存储器这些名称的含义</p><ul><li><p>按工作方式&#x2F;存取方式分类</p><ul><li><p>随机存取存储器 RAM</p><p>每个单元读写时间一样，且与各单元所在位置无关，如：内存</p><p>（目前的DRAM芯片采用行缓冲，可能因位置不同而使访问时间有所差别）</p></li><li><p>顺序存取存储器 SAM</p><p>数据按顺序从存储载体的始端读出或写入，因而存取时间的长短与信息所在位置有关，如：磁带</p></li><li><p>直接存取存储器 DAM</p><p>直接定位到读写读写数据块，在读写数据块时按顺序进行，如：磁盘</p></li><li><p>相联存储器 AM或CAM</p><p>按内容检索到存储位置进行读写，如：快表</p></li></ul></li><li><p>按信息的可更改性分类</p><ul><li><p>读写存储器（Read&#x2F;Write Memory）：可读可写</p><ul><li>静态存储器SRAM（用作Cache）<ul><li>每个存储单元由6个晶体管组成</li><li>只要加上电源，信息就能一直保持</li><li>对电器干扰相对不敏感</li><li>比DRAM更快，也更贵</li></ul></li><li>动态存储器DRAM（用作主存储器）<ul><li>每个存储单元由1个电容和1个晶体管组成</li><li>每隔一段时间必须刷新一次</li><li>对电器干扰比较敏感</li><li>比SRAM慢，但便宜</li></ul></li></ul></li><li><p>只读存储器（Read Only Memory）：只能读不能写</p><ul><li>不可改写内容的ROM</li><li>闪存（Flash Rom）（用作BIOS）</li></ul></li></ul></li><li><p>按断电后信息的可保存性分类</p><ul><li><p>非易失（不挥发）性存储器</p><p>信息可一直保留，不需电源维持，如：ROM、磁表面存储器、光存储器等</p></li><li><p>易失（挥发）性存储器</p><p>电源关闭时信息自动丢失，如：RAM、Cache</p></li></ul></li></ul></li><li><p>层次结构存储系统中的寄存器、高速缓存、内存(主存)、外存它们所在的位置、工作速度、存储容量、成本等的相对大小和大致的数量级以及这些存储器和前述各类存储器之间的对应关DRAM的集中刷新、分散刷新和异步刷新的刷新操作与正常访存分别是如何安排的</p><ul><li><p>按功能&#x2F;容量&#x2F;速度&#x2F;所在位置分类</p><ul><li><p>寄存器（Register）</p><ul><li><p>封装在CPU内，用于存放当前执行的指令和使用的数据</p></li><li><p>用触发器实现，速度快，容量小（几~几十个KB）</p></li></ul></li><li><p>高速缓存（Cache）</p><ul><li>位于CPU内部或附近，用来存放当前要执行的局部程序段或数据</li><li>用SRAM实现，速度可与CPU匹配，容量小（几MB）</li></ul></li><li><p>内存储器MM（主存储器，Main Memory）</p><ul><li>位于CPU之外，用来存放已被启动的程序及所用的数据</li><li>用DRAM实现，速度较快，容量较大（几GB）</li></ul></li><li><p>外存储器AM （辅助存储器，Auxiliary Storage）</p><ul><li>位于主机之外，用来存放暂不运行的程序、数据或存档文件</li><li>用磁表面或光存储器实现，容量大而速度慢</li></ul></li></ul></li><li><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614094034974.png" alt="image-20220614094034974" style="zoom:50%;" /></li></ul></li><li><p>静态存储器和动态存储器的基本工作机制；动态存储器刷新的概念，按行刷新的含义。最大刷新周期的确定的依据是什么</p><ul><li><p>六管静态MOS管电路</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614094536313.png" alt="image-20220614094536313" style="zoom: 50%;" /></li><li><p>动态单管记忆单元电路</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614094615872.png" alt="image-20220614094615872" style="zoom:50%;" /></li><li><p>SRAM：字片式存储体阵列组织</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614094859172.png" alt="image-20220614094859172" style="zoom:50%;" /><ul><li>单方向译码，一维地址驱动</li><li>存储体每一行构成多位的一个存储字，一起被读写</li><li>每列由相同位构成，共用一个读写电路，有多个读写电路</li><li>在位方向上便于扩充</li></ul></li><li><p>DRAM：位片式存储体阵列组织</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614095118548.png" alt="image-20220614095118548" style="zoom:50%;" /><ul><li>双方向译码，二维地址驱动</li><li>芯片阵列由行和列排列而成，每次只能读写行、列交叉处的一位数据</li><li>每个芯片只有一位读写电路</li><li>在字和位上都能扩充，但需有片选信号</li></ul></li><li><p>DRAM芯片的刷新</p><ul><li><p>原因：动态存储器依靠电容电荷存储信息，无电源供电，时间一长电容电荷会泄漏，需定期向电容补充电荷，以保持信息不变</p></li><li><p>含义：定期向电容补充电荷，即刷新</p></li><li><p>刷新周期：从上次对整个存储器刷新结束到下次对整个存储器全部刷新一遍为止的时间间隔，也就是相邻两次对某个特定行进行刷新的时间间隔</p><p>刷新周期取电容上数据有效保存时间的上限，一般为10ms～100ms，目前多数情况下是64ms</p></li></ul></li><li><p>DRAM的刷新方式</p><ul><li><p>集中刷新：在刷新周期内集中安排所有行的刷新</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614100806017.png" alt="image-20220614100806017" style="zoom:50%;" /></li><li><p>分散刷新：各行的刷新分散安排在每个存取周期中</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614100926907.png" alt="image-20220614100926907" style="zoom:50%;" /></li><li><p>异步刷新：各行刷新分散安排在一个刷新周期内，每隔一段时间刷新一行</p><p>例如：64ms&#x2F;4096行≈15.6微秒，平均15.6us提一次刷新请求刷新1行，64ms内刷新完片内所有行</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614101148667.png" alt="image-20220614101148667" style="zoom:50%;" /></li></ul></li><li><p>CPU与存储器之间的通信方式</p><ul><li>异步方式过程（需握手信号）（读操作为例，写操作类似）<ul><li>CPU送地址到地址线，主存进行地址译码</li><li>CPU发读命令，然后等待存储器发回“完成”信号</li><li>主存收到读命令后开始读数，完成后发“完成”信号给CPU</li><li>CPU接收到“完成”信号，从数据线取数</li></ul></li><li>同步方式<ul><li>CPU和主存由统一时钟信号控制，无需应答信号（如“完成”）</li><li>主存总是在确定的时间内准备好数据</li><li>CPU送出地址和读命令后，总是在确定的时间取数据</li><li>存储器芯片必须支持同步方式，如<strong>SDRAM</strong>芯片</li></ul></li></ul></li></ul></li><li><p>了解SDRAM芯片中的突发传输方式</p><ul><li><p>SDRAM芯片技术</p><ul><li><p>SDRAM芯片是同步存储芯片</p></li><li><p>每步操作都在系统时钟控制下进行</p></li><li><p>有确定的等待时间（读命令开始到数据线的有效时间）CL</p><p>例如CL&#x3D;2clks</p></li><li><p>利用总线时钟上升沿与下降沿同步传送</p></li><li><p>多体（缓冲器）交叉存取</p></li><li><p>一个时钟连续传送多个数据（突发传输方式）</p><p>可为1，2，4，8个，分别对应SDRAM、DDR SDRAM、DDR2 SDRAM和DDR3 SDRAM</p></li></ul></li></ul></li></ol><p><strong>二、存储器容量的扩展及其与CPU的连接</strong></p><ol><li><p>位扩展、字扩展、字位扩展方式，系统存储容量的计算，芯片数的计算；这几种扩展方式下的芯片(组)与片选信号的地址线分配；各芯片(组)的地址范围的计算、划分。片选信号用地址信号表示的逻辑表达式。</p><ul><li><p>字扩展（位数不变，扩充容量）</p><blockquote><p>例题：用16K×8位芯片扩成64K×8位存储器需几个芯片？地址范围各为什么？</p><blockquote><p>字方向拓展4倍，需4个芯片，每个芯片有14位地址</p><p>$64KB&#x3D;2^{16}$，故地址共需16位</p><p>地址范围分别为：0000-3FFFFH，4000-7FFFH，8000-BFFFH，C000-FFFFH</p><p>地址高两位由外部译码器译码生成4个输出，分别连到4个芯片的片选信号端</p><p>地址的低14位连到各芯片作为片内地址</p><p>地址线、读&#x2F;写控制线等对应相接，片选信号连译码输出</p></blockquote></blockquote></li><li><p>位扩展（字数不变，位数扩展）（位扩展无需片选信号）</p><blockquote><p>例题：用4096×1位芯片构成4K×8位存储器需几个芯片？地址范围各是多少？</p><blockquote><p>位方向扩展8倍，字方向无需扩展</p><p>需要8个芯片，地址范围都一样：000-FFFH，地址共12位，全部作为片内地址</p><p>芯片的地址线及读&#x2F;写控制线对应相接，而数据线单独引出</p></blockquote></blockquote></li><li><p>字位同时扩展（字和位同时扩展）</p><blockquote><p>例题：16K×4位芯片构成64K×8位存储器需几个芯片，地址范围各是多少？</p><blockquote><p>字向4倍，位向2倍，8个芯片</p><p>各芯片地址范围：0000-3FFFFH，4000-7FFFFH，8000-BFFFFH，C000-FFFFH</p></blockquote></blockquote></li><li><p>存储器芯片扩展例题</p><blockquote><p>例题：用1K×4的芯片组成容量为4K×8的存储器。系统地址总线A15～A0（低）,双向数据总线D7～D0（低）,读&#x2F;写信号线R&#x2F;W。给出芯片内部地址分配与片选逻辑,并画出存储器框图。</p><ol><li><p>计算芯片数</p><p>先扩展位再扩展字</p><p>先扩展字再扩展位</p><p>均需8片</p></li><li><p>地址分配与片选逻辑</p><p>存储空间分配：4KB存储器可以在16位地址空间（64KB）中占据任意4KB的连续区间</p><p>$4KB&#x3D;2^{12}$，需12位地址，其中A11、A10为片选信号</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614104935448.png" alt="image-20220614104935448" style="zoom:50%;" /><p>低位分配给芯片，高位地址形成片选逻辑</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614105024291.png" alt="image-20220614105024291" style="zoom:67%;" /></li><li><p>线路连接</p><ul><li>扩展位数</li><li>扩展字数</li><li>连接控制线</li><li>片选逻辑电路</li></ul><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614110111824.png" alt="image-20220614110111824" style="zoom:50%;" /></li></ol></blockquote></li></ul></li></ol><p><strong>三、高速缓冲存储器(Cache)</strong>(空间局部性、时间局部性)</p><ol><li><p>直接映射、全相联映射、组相联映射三种方式的映射关系；三种方式下的主存地址与cache的行、内容之间的对应关系；cache容量的计算方法，注意区分数据区、标记、有效位</p><ul><li><p>直接映射（模映射）</p><ul><li><p>把主存的每一块映射到一个固定的Cache行</p><p>Cache行号&#x3D;主存行号 mod Cache行数（块与行均从0开始编号）</p><p>例如4&#x3D;100 mod 16，即主存第100块应映射到Cache的第4行中</p></li><li><p>特点</p><ul><li>容易实现，命中时间短</li><li>无需考虑淘汰替换问题</li><li>但不够灵活，Cache存储空间得不到充分利用，命中率低</li></ul></li><li><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614112535466.png" alt="image-20220614112535466" style="zoom: 67%;" /><p><strong>tag为块群号</strong></p></li><li><p>Cache有效位</p><ul><li>1表示信息有效，0表示信息无效</li><li>开机或复位时，使所有行的有效位V&#x3D;0</li><li>某行被替换后使其V&#x3D;1</li><li>某行装入新块时使其V&#x3D;1</li><li>通过使V&#x3D;0来冲刷Cache</li><li>通常为操作系统设置“cache冲刷”指令，因此cache对操作系统程序员不是透明的</li></ul></li><li><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614113655358.png" alt="image-20220614113655358" style="zoom:67%;" /></li><li><p>映射行计算</p><ul><li>地址&#x2F;块大小得到块数后mod行数</li><li>由地址，最后是块内地址，中间是Cache行数，前面是主存标记（所在主存块）</li></ul></li><li><p>Cache容量计算</p><p>容量&#x3D;行数×(1+块群数)+数据</p><p>​        &#x3D;行数×(1+块群数+块大小)</p><p>块群数&#x3D;主存地址数&#x2F;块大小&#x2F;行数（取商）</p></li></ul></li><li><p>全相联映射</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614132504643.png" alt="image-20220614132504643" style="zoom:67%;" /><p><strong>tag为主存块号</strong></p><p>同时比较所有Cache行的标志</p><p>没有冲突缺失，只要有空闲的Cache行都不会发生冲突</p></li><li><p>组相联映射</p><p>将Cache所有行分组，每个主存块只能映射到Cache的某固定组，但可映射该组的任一行</p><p><strong>组间模映射，组内全映射</strong></p><p>Cache组号&#x3D;主存块号 mod Cache组数</p><p>每组的行数称为路，有2路组相连映射等</p><ul><li>特点<ul><li>结合直接映射和全相联映射的优点，当Cache组数为1时是全相联映射，当每组只有一行时，就是直接映射</li><li>每组2或4行较常用</li></ul></li></ul><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614172401604.png" alt="image-20220614172401604" style="zoom: 33%;" /><p><strong>tag为主存组群号</strong></p><ul><li><p>对于N路相联映射：N个全相联映射的行并行操作</p></li><li><p>Cache索引选择其中一个Cache组</p><p>对这个组的N个Cache行的Tag并行进行比较</p><p>根据比较结果确定信息在哪个行，或不在Cache中</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614174103535.png" alt="image-20220614174103535" style="zoom: 33%;" /></li><li><blockquote><p>例题：某计算机的Cache共有16块，采用2路组相联映射方式(即每组包括2块)，存储器按字节编址，每个主存块大小为32字节，那么129号主存单元所在的主存块应装入到的Cache组号是</p><blockquote><p>法一</p><p>129&#x2F;32&#x3D;4</p><p>4 mod 8 &#x3D; 4</p><p>法二（地址法）</p><p>129&#x3D;10000001&#x3D;0…0<strong>10000001</strong>(Cache索引为100)</p></blockquote></blockquote></li></ul></li></ul></li><li><p>CPU对cache的访问时，直接映射采用的是按地址进行查找的方法，而全相联映射采用的是用多个比较器进行同时比对查找到cache的行；组相联映射则结合了上述两种方法，即由地址查找到组，再对组内的各行“标记”用多个比较器进行同时比对。和相联存储器的概念有什么关系？</p></li><li><p>三种映射方式中哪些需要替换算法？了解“先进先出FIFO”和“最近最少用LRU”替换算法。了解写策略中的命中和未命中的处理方式。</p><ul><li><p><strong>组相联映射</strong>与<strong>全相联映射</strong>需考虑替换算法</p></li><li><p><strong>先进先出FIFO</strong></p><p>总是把最先进入的那一块淘汰掉</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614175950535.png" alt="image-20220614175950535" style="zoom:33%;" /></li><li><p><strong>最近最少用LRU</strong></p><p>总是把最近最少用的那一块淘汰掉</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614180530921.png" alt="image-20220614180530921" style="zoom:33%;" /><ul><li><p>具体实现：给每个Cache行设定一个计数器，根据计数值来记录这些主存块的使用情况，LRU位</p></li><li><p>计数器变化规则</p><ul><li>每组4行时，计数器有2位，计数值越小说明越常被使用</li><li>命中时，被访问行的计数器置0，比其原值小的计数器加1，其余不变</li><li>未命中且该组未满时，新行计数器置0，其余全加1</li><li>未命中且该组已满时，计数值为3的那一行中的主存块被替换，该行计数器置为0，其余加1</li></ul><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614180926538.png" alt="image-20220614180926538" style="zoom:33%;" /></li></ul></li><li><p>写策略（Cache与主存一致性问题）</p><ul><li>写命中：要写的单元已经在Cache中<ul><li>Write Through（通过式写、写直达、直写）<ul><li>同时写Cache和主存单元</li><li>大大增加了写的开销</li><li>10%的存储指令使CPI增加得到1.0+100×10%&#x3D;11</li><li>采用写缓存法（Write Buffer），Cache和主存间加缓存</li></ul></li><li>Write Back（一次性写、写回、回写）<ul><li>只写Cache不写主存，缺失时一次写回，每行有个修改位（脏位），大大降低主存带宽需求，控制可能很复杂</li></ul></li></ul></li><li>写不命中：要写的单元不在Cache中<ul><li>Write Allocate（写分配）<ul><li>将主存块装入Cache，然后更新相应单元</li><li>视图利用空间局部性，但每次都要从主存读一个块</li></ul></li><li>Not Write Allocate（非写分配）<ul><li>直接写主存单元，不把主存块装入Cache</li></ul></li></ul></li></ul></li></ul></li></ol><p><strong>四、虚拟存储器</strong></p><ol><li><p>虚拟存储器的基本思想—分页的基本思想（还有分段式、段页式，考试不考）</p><ul><li><p>页（虚页、逻辑页）与页框（实页、物理页）的概念</p><ul><li>页、虚页、逻辑页：每个进程被划分为固定长的程序块</li><li>页框、实页、物理页：内存被分成固定长且比较小的存储块</li><li>程序块可装到内存中可用的存储块中</li><li>无需用连续页框来存放一个进程</li><li>操作系统为每个进程生成一个页表</li><li>通过页表实现逻辑地址向物理地址的转换</li></ul></li><li><p>逻辑地址（虚拟地址）与物理地址（实地址、主存地址）的概念</p><ul><li>逻辑地址：程序中指令所用的地址（进程所在地址空间），也称为虚拟地址（VA）</li><li>物理地址：存放指令或数据的之际内存地址</li></ul></li><li><p>虚拟存储器机制由硬件与操作系统共同协作实现</p><ul><li>逻辑地址转换为物理地址是由硬件(CPU中的存储管理部件)完成，其中虚页号到页框号的转换是通过查表（页表或快表）实现</li><li>当发生程序或数据访问缺页时，由操作系统在主存和磁盘之间进行信息交换</li><li>页表由操作系统管理维护</li></ul></li><li><p>页框与虚拟页之间采用全相联映射，为什么不采用其他映射方式，另外为什么页大小（2KB~64KB）比Cache中的块大小大得多</p><p>因为缺页的开销比Cache缺失开销大得多！缺页时需要访问磁盘（约几百万个时钟周期），而cache缺失时，访问主存仅需几十到几百个时钟周期！因此，页命中率比cache命中率更重要！<strong>“大页面”和“全相联”可提高页命中率</strong></p></li><li><p>在处理页框与虚拟页的一致性问题时采用回写（write back）方式，为什么不采用全写方式</p><p><strong>避免频繁的慢速磁盘访问操作</strong></p></li></ul></li><li><p>页表的基本结构</p><ul><li><p>页表项中的装入位、修改位、存放位置的含义。为什么页表项中没有虚页号</p><ul><li>装入位：用于指示该页是否已调入内存，供程序访问时参考</li><li>修改位：表示该页在调入内存后是否被修改过，供置换页面时参考</li><li>存放位置：用于指出该页在<strong>内存上的地址</strong>，通常是物理页号，供调入该页时参考</li></ul></li><li><p>如何区分未分配页、已分配的缓存页和已分配的未缓存页</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614191145355.png" alt="image-20220614191145355" style="zoom:33%;" /></li></ul></li><li><p>快表——TLB</p><ul><li>快表存储在什么地方？采用快表的目的是什么？<ul><li>快表存储在Cache中</li><li>快表目的：减少到内存查页表次数</li><li><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614192543008.png" alt="image-20220614192543008" style="zoom:33%;" /></li></ul></li><li>快表与页表之间一般采用组相联或全相联映射<ul><li>TLB全相联时，没有index，只有Tag，虚页号需与每个Tag比较</li><li>TLB组相联时，则虚页号高位为Tag，低位为index，用作组索引</li></ul></li><li>快表的表项由页表表项内容+标记(tag)，在全相联和组相联映射方式下标记字段分别是什么内容</li></ul></li><li><p>理解根据虚拟地址，通过TLB、页表、cache的访问过程</p><p>![image-20220614194349906](C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614194349906.png)</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614194719675.png" alt="image-20220614194719675" style="zoom:33%;" /><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614200251576.png" alt="image-20220614200251576" style="zoom:50%;" /><blockquote><p>例题：某计算机存储器按字节编址，虚拟(逻辑)地址空间大小为16MB，主存(物理)地址空间大小为1MB，页面大小为4KB;Cache采用直接映射方式，共8行;主存与Cache之间交换的块大小为32B。系统运行到某一时刻时，页表的部分内容和Cache的部分内容分别如图所示，图中页框号及标记字段的内容为十六进制形式。</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220614195001314.png" alt="image-20220614195001314" style="zoom:67%;" /><p>请回答下列问题。</p><p>(1)虚拟地址共有几位，哪几位表示虚页号?物理地址共有几位，哪几位表示页框号(物理页号)?</p><p>(2)使用物理地址访问Cache时，物理地址应划分成哪几个字段?要求说明每个字段的位数及在物理地址中的位置。</p><p>(3)虚拟地址001C60H所在的页面是否在主存中?若在主存中，则该虚拟地址对应的物理地址是什么?访问该地址时是否Cache命中?要求说明理由。</p><p>(4)假定为该机配置一个4路组相联的TLB，该TLB共可存放8个页表项，若其当前内容(十六进制)如题44-c图所示，则此时虚拟地址024BACH所在的页面是否在主存中?要求说明理由。</p><ul><li><p>虚拟空间16MB，因此虚拟地址有24位</p><p>物理地址1MB，因此物理地址有20位</p><p>页面4KB，因此页内地址有12位</p><p>因此在虚拟地址中，高12位为虚页号，低12位为页内地址</p><p>在物理地址中，高8位为页框号，低12位为页内地址</p></li><li><p>因为是直接映射方式，20位物理地址被划分为高12位为主存标记（块群号）后3位为Cache行号低5位为块内地址</p></li><li><p>虚拟地址001C60H&#x3D;0000 0000 0001 1100 0110 0000B，故虚页号0000 0000 0001B，查看001H处的页表项，其对应有效位为1，故其所在的页面在主存</p><p>页框号为04H，故其物理地址为0000 0100 1100 <strong>011</strong>0 0000B&#x3D;04C60H，所在主存块只能映射到第3行，由于该行有效位为1，标记值为105H≠04CH，故访问该地址Cache不命中</p></li><li><p>虚拟地址024BACH&#x3D;0000 0010 0100 1011 1010 1100B，故虚页号为0000 00100100B;由于TLB只有8&#x2F;4&#x3D;2个组，故虚页号中高11位为TLB标记，最低1位为TLB组号，它们的值分别为0000 0010 010B(即012H)和0B，因此，该虚拟地址所对应物理页面只可能映射到TLB的第0组，由于组0中存在有效位为1、标记为012H的项，所以访问TLB命中，即虚拟地址024BACH所在的页面在主存中</p></li></ul></blockquote></li></ol><h3 id="第八章-互连及输入输出组织"><a href="#第八章-互连及输入输出组织" class="headerlink" title="第八章 互连及输入输出组织"></a>第八章 互连及输入输出组织</h3><p><strong>一、I&#x2F;O系统与I&#x2F;O设备</strong></p><ol><li><p>I&#x2F;O系统性能能指标</p><ul><li>吞吐率(I&#x2F;O带宽)：单位时间从系统输入&#x2F;输出多少数据（或单位时间实现多少次输入&#x2F;输出操作）</li><li>响应时间：在多长时间内完成请求的任务</li></ul></li><li><p>外设的通用模型以及各部分作用</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220610130907749.png" alt="image-20220610130907749" style="zoom: 50%;" /><ul><li>通过<strong>电缆</strong>与计算机内部I&#x2F;O接口进行数据、状态和控制信息的传送</li><li><strong>控制逻辑</strong>根据控制信息控制设备的操作，并检测设备状态</li><li><strong>缓冲器</strong>用于保存交换的数据信息</li><li><strong>变换器</strong>用于实现电信号形式（内部数据）与其他形式的设备数据之间的转换</li><li>电缆线中三种控制信号：<strong>控制信号、状态信号、数据信号</strong></li></ul></li><li><p>磁盘上的数据定位（地址）：磁道号、磁头号、扇区号</p><p>磁盘数据的存取以块（扇区）为单位</p><p>磁盘操作：所有磁头同步寻道（磁道号）、选择磁头（磁头号）、旋转等待（扇区号）、读写</p><ul><li><p>磁道：磁盘表面被分为许多同心圆，每个同心圆称为一个磁道</p><p>每个磁道都有一个编号，最外面的是0磁道</p></li><li><p>扇区：每个磁道被划分为若干段（段又叫扇区）</p><p>每个扇区的存储容量为512字节，每个扇区都有一个编号（近几年有4096字节扇区）</p></li></ul></li><li><p>磁盘信息记录密度（高密度磁盘比低密度磁盘容量大很多）</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220610140146676.png" alt="image-20220610140146676" style="zoom:50%;" /><ul><li><p>低密度磁盘：</p><p>各个磁道上的扇区数相同</p><p>每个磁道存储的数据量相同</p><p>内磁道的位密度比外磁道高</p></li><li><p>高密度磁盘：</p><p>各个磁道上的位密度相同</p><p>各磁道存储的数据量不同</p><p>外磁道的扇区数比内磁道多</p></li></ul></li><li><p>磁盘容量的计算（低密度存储方式）</p><ul><li><p>未格式化容量计算</p><p>$磁盘总容量&#x3D;记录面数\times 理论柱面数\times 内圆周长\times 位密度$</p><ul><li>$理论柱面数&#x3D;(有效记录区外径-有效记录区内径)\div2\times道密度$</li></ul></li><li><p>格式化容量计算</p><p>$磁盘实际数据容量&#x3D;2\times盘片数\times 磁道数&#x2F;面\times扇区数&#x2F;磁道\times512B&#x2F;扇区$</p><p>(根据实际记录面数）</p></li><li><blockquote><p>例题：假设一个有3个盘片的硬盘，共有4个记录面，转速为7200&#x2F;分钟，盘面有效记录区域的外直径为30cm，内直径为10cm，记录位密度为250bit&#x2F;mm，磁道密度为8道&#x2F;mm，每个磁道分16扇区，每扇区512字节。</p><blockquote><p>$总磁道数&#x3D;4*(30-10)<em>10&#x2F;2</em>8&#x3D;3200$<br>$非格式化容量&#x3D;3200*(3.14<em>10</em>10)<em>(250&#x2F;8)B&#x3D;29.95MB$<br>$格式化容量&#x3D;3200</em>16*512B&#x3D;25MB$</p></blockquote></blockquote></li></ul></li><li><p>硬盘的主要技术指标：平均存储时间$T$及其计算</p><ul><li><p>$T&#x3D;平均寻道时间+平均旋转等待时间+数据传输时间$</p></li><li><p>$磁盘响应时间&#x3D;平均存储时间T+磁盘控制器开销+排队时间$</p></li><li><blockquote><p>例题：假定每个扇区512字节，磁盘转速位5400RPM，声称寻道时间（最大寻道时间的一半）为12ms，数据传输率为4MB&#x2F;s，磁盘控制器开销为1ms，不考虑排队时间，则磁盘响应时间为多少？</p><blockquote><p>$磁盘相应时间&#x3D;12ms+0.5&#x2F;5400RPM*60+0.5KB&#x2F;(4MB&#x2F;s)+1ms+0ms&#x3D;18.6ms$</p></blockquote></blockquote></li></ul></li><li><p>冗余磁盘阵列RAID</p><ul><li><p>基本思想</p><ul><li>将多个独立操作的磁盘按照某种方式组织成磁盘阵列(Disk Array)，以<strong>增加容量</strong></li><li>利用类似于主存中的多体交叉技术，将数据存储在多个盘体上</li><li>通过这些盘并行工作来<strong>提高数据传输速度</strong></li><li>用冗余磁盘技术来进行错误恢复以<strong>提高系统可靠性</strong></li></ul></li><li><p>3个特性</p><ul><li>RAID是一组物理磁盘驱动器，在操作系统下被视为一个单逻辑驱动器</li><li>数据分布在一组物理磁盘上</li><li>冗余磁盘用于存储校验信息，保证磁盘万一损坏时能恢复数据</li></ul></li><li><p>冗余磁盘不同级别的含义</p><p>0-7级，并非简单地表示层次关系，而是表示具有上述3个共同特性的不同设计结构</p></li></ul></li></ol><p><strong>二、总线及系统互连、I&#x2F;O接口</strong></p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220610155402568.png" alt="image-20220610155402568" style="zoom:50%;" /><ol><li><p>总线概述</p><ul><li><p><strong>总线</strong>：在各种层次上提供部件之间的连接和交换信息的通路（点对点、异步、串行）</p><ul><li><p>芯片内总线：在芯片内部各元件之间提供连接</p></li><li><p><strong>系统总线</strong>：在系统主要功能部件（CPU、MM和各种I&#x2F;O控制器）间提供连接</p><p>含处理器总线、存储器总线、I&#x2F;O总线</p><ul><li><p>单总线结构</p><p>将CPU、MM和各种I&#x2F;O适配卡通过底板总线互连，底板总线为标准总线</p></li><li><p>多总线结构</p><p>将CPU、Cache、MM和各种I&#x2F;O适配卡用局部总线、处理器-主存总线、高速I&#x2F;O总线、扩充I&#x2F;O总线等互连</p><ul><li>Processor-Memory Bus：短而快，仅需与内存匹配，使CPU-MM之间达最大带宽</li><li>I&#x2F;O Bus：长而慢，需适应多种设备，一侧连接到Processor-Memory Bus或Backplane Bus，另一侧连到I&#x2F;O控制器</li></ul></li><li><p><strong>系统总线</strong>通常由一组<strong>控制线</strong>、一组<strong>数据线</strong>和一组<strong>地址线</strong>构成</p><p>也有些总线没有单独的地址线，地址信息通过数据线来传送，这种情况称为<strong>数据&#x2F;地址复用</strong></p><ul><li><p>数据线（Data Bus）：承载在源和目的部件之间传输的信息。数据线的宽度反映一次能传送的数据的位数。</p></li><li><p>地址线（Address Bus）：给出源数据或目的数据所在的主存单元或I&#x2F;O端口的地址。地址线的宽度反映最大的寻址空间</p></li><li><p>控制线（Control Bus） ：控制对数据线和地址线的访问和使用。用来传输定时信号和命令信息。典型的控制信号包括：</p><blockquote><p>时钟（Clock）：用于总线同步</p><p>复位（Reset）：初始化所有设备</p><p>总线请求（Bus Request）：表明发出该请求信号的设备要使用总线</p><p>总线允许（Bus Grant）：表明接收到该允许信号的设备可以使用总线</p><p>中断请求（Interrupt Request）：表明某个中断正在请求</p><p>中断回答（Interrupt Acknowledge） ：表明某个中断请求已被接受</p><p>存储器读（memory read）：从指定的主存单元中读数据到数据总线上</p><p>存储器写（memory read）：将数据总线上的数据写到指定的主存单元中</p><p>I&#x2F;O读（I&#x2F;O read）：从指定的I&#x2F;O端口中读数据到数据总线上</p><p>I&#x2F;O写（I&#x2F;O Write） ：将数据总线上的数据写到指定的I&#x2F;O端口中</p><p>传输确认（transmission Acknowledge） ：表示数据已被接收或已送总线</p></blockquote></li></ul></li></ul></li><li><p>通信总线：在主机和I&#x2F;O设备之间或计算机系统之间提供连接（含IDE接口）</p></li><li><p>处理器总线</p><ul><li><p>前端总线FSB</p><blockquote><p>并行传输、同步定时方式</p><p>位于CPU与北桥芯片之间互连</p><p>quad pumped技术：每个总线时钟周期传送4次数据</p><p>即工作频率为实际时钟频率的4倍</p><p>后续随着QPI总线出现不再使用</p><p>例题：若工作频率为1333MHz（实际单位应是MT&#x2F;s，表示每秒传送1333M次数据，实际时钟工作频率为333MHz），总线宽度为64位，求总线带宽</p><blockquote><p>$总线带宽&#x3D;1333MT&#x2F;s\times8B&#x3D;10.5GB&#x2F;s$</p></blockquote></blockquote></li><li><p>QPI总线（目前使用）</p><blockquote><p>主存控制器集成到芯片，主存不需要通过北桥，直接与CPU相连</p><p>基于包交换的串行、高速点对点连接，每个QPI数据包长80位</p><p>发送方和接收方有各自时钟信号，总线有20条数据线</p><p>每条数据线为一个双向的串行传输通道，因此双方都有20个传输通道</p><p>一个时钟周期传两次，故一个方向每次可传20位，其中16位数据，4位校验位</p><p>$QPI总线带宽&#x3D;每秒传送次数\times 2B\times 2$(方向)</p><p>工作频率GT&#x2F;s，表示每秒传送G次</p><p>例题：时钟频率为2.4GHz，求QPI带宽</p><blockquote><p>$QPI带宽&#x3D;2.4GHz\times 2\times 2B\times2&#x3D;4.8GT&#x2F;s\times2B\times2&#x3D;19.2GB&#x2F;s$</p></blockquote></blockquote></li></ul></li><li><p>存储器总线：Core i7开始主存直接与CPU相连，3个存控</p><p>总线宽64位，速度为1333MT&#x2F;s</p><p>总带宽为$3\times8B\times1333M&#x3D;32GB&#x2F;s$</p></li><li><p>I&#x2F;O总线：用于为系统中的各种I&#x2F;O设备提供输入输出通道</p><p>在物理上可以是主板上的I&#x2F;O扩展槽，如PCI-Express</p><ul><li><p>PCI-Express</p><p>串行总线，主流总线</p><p>两个PCI-Express设备之间以一个链路（link）相连</p><p>每个链路包含多条通路（lane），可以是1,2,4,8,16或32条</p><p>PCI-Express×n表示一个具有n条通路的PCI-Express链路</p><p>每条通路可同时发送和接受，每个数据字节被转换为10位信息被传输</p><p>PCI-Express1.0下，每条通路的发送和接受速率都是2.5Gb&#x2F;s，故PCI-Express×n的带宽为：$2.5Gb&#x2F;s×2×n&#x2F;10&#x3D;0.5GB&#x2F;s×n$</p></li><li><p>I&#x2F;O设备通常是物理上相互独立的设备，一般通过通信总线与I&#x2F;O控制器相连</p><p>I&#x2F;O控制器（I&#x2F;O接口）通过扩充卡或者南桥芯片与I&#x2F;O总线连接</p><p>I&#x2F;O总线经过北桥芯片与内存、CPU相连</p></li></ul></li></ul></li><li><p>总线的性能指标</p><ul><li><p>总线宽度：总线中数据线的条数，决定了每次能同时传输的信息位数</p></li><li><p>总线的工作频率：现在的总线一个时钟周期可以传送2次或4次数据</p></li><li><p>总线带宽：总线的最大数据传输率</p><p>同步总线，总线带宽计算公式： $B&#x3D;W\times F\div N$</p><p>$W$-总线宽度，$F$-总线时钟频率，$N$-完成一次数据传送所用的时钟周期数</p><p>$F\div N$实际就是总线工作频率</p></li></ul></li></ul></li><li><p>I&#x2F;O接口：I&#x2F;O设备控制器及其插座（如网卡、显卡、键盘适配器、磁盘控制器）</p><ul><li><p>5大功能</p><ul><li><p>数据缓冲</p><p>提供数据缓冲寄存器，以达到主机和外设工作速度的匹配</p></li><li><p>错误或状态检测</p><p>提供状态寄存器，以保存各种错误或状态信息供CPU查用</p></li><li><p>控制和定时</p><p>提供控制和定时逻辑，以接收从系统总线来的控制定时信号</p></li><li><p>数据格式转换</p><p>提供数据格式转换部件，使通过外部接口得到的数据转换为内部接口需要的格式，或在相反的方向进行数据格式转换</p></li><li><p>与主机和设备通信</p><p>上述功能通过I&#x2F;O接口与主机之间、I&#x2F;O接口与设备之间的通信来完成</p></li></ul></li><li><p>通用结构</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220610172526467.png" alt="image-20220610172526467" style="zoom:50%;" /><p>通过发送命令字到I&#x2F;O控制寄存器来向设备发送命令</p><p>通过从状态寄存器读取状态字来获取外设或I&#x2F;O控制器的状态信息</p><p>通过向I&#x2F;O控制器发送或读取数据来和外设进行数据交换</p><p>将I&#x2F;O控制器中CPU能够访问的各类寄存器称为I&#x2F;O端口</p><p>对外设的访问通过向I&#x2F;O端口发命令、读状态、读&#x2F;写数据来进行</p></li></ul></li><li><p>I&#x2F;O端口的编址方式</p><ul><li><p>统一编址方式（内存映射方式）</p><p>与主存空间统一编址，将主存空间分出一部分地址给I&#x2F;O端口进行编号</p><ul><li><p>CPU不直接通过读写控制信号$\overline{IOR}、\overline{IOW}$对I&#x2F;O端口读写，而是地址译码实现</p></li><li><p>地址线高位参与片选控制逻辑</p></li><li><p>无需设置专门I&#x2F;O指令，访存指令即可存取I&#x2F;O端口</p></li></ul></li><li><p>独立编址方式（使用专门I&#x2F;O指令方式）</p><p>不和主存单元一起编号，而是独立编号，成为一个独立的I&#x2F;O地址空间</p><ul><li><p>通过不同的读写控制信号$\overline{IOR}、\overline{IOW}$对I&#x2F;O端口读写</p></li><li><p>一般I&#x2F;O端口比存储器单元少，所以选择I&#x2F;O端口只需要少量地址线</p></li><li><p>指令系统必须设计专门的I&#x2F;O指令</p></li></ul></li></ul></li></ol><p><strong>三、I&#x2F;O数据传送控制方式</strong></p><ol><li><p>程序直接控制方式</p><ul><li><p>无条件传送：对简单外设定时（同步）进行数据传送</p></li><li><p>条件传送：Polling（轮询，查询），程序查询方式</p><p>I&#x2F;O设备将自己的状态放到一个状态寄存器</p><p>OS阶段性地查询状态寄存器中的特定状态，以决定下一步动作</p></li></ul><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220610191339605.png" alt="image-20220610191339605" style="zoom:50%;" /><ul><li>特点<ul><li>简单、易控制、外围接口控制逻辑少</li><li>CPU与外设串行工作，效率低，速度慢，适用于慢速设备</li><li>查询开销极大（CPU在等待外设完成）</li></ul></li><li>工作方式：完全串行工作方式或部分串行，CPU用100%的时间为I&#x2F;O服务</li></ul></li><li><p>中断I&#x2F;O方式</p><ul><li>基本思想：当外设准备好时，便向CPU发中断请求，CPU响应后，中止现行程序的执行，转入一个“中断服务程序”进行输入&#x2F;出操作，实现主机和外设接口之间的数据传送，并启动外设工作。 “中断服务程序”执行完后，返回原被中止的程序断点处继续执行。此时，外设和CPU并行工作</li></ul><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220610192255974.png" alt="image-20220610192255974" style="zoom:50%;" /><ul><li><p>外部“中断“：在CPU外部发生的特殊事件，通过“中断请求”信号向CPU请求处理</p><ul><li><p>与异常的区别</p><ul><li><p>产生源不相同，<strong>异常是由CPU产生的</strong>（非法指令，地址越界）</p><p><strong>中断是由硬件设备产生的</strong>（磁盘中断，打印机中断）</p></li><li><p>异常是CPU产生的，所以是时钟同步的</p><p>中断是异步的，这意味着中断可能随时到来</p></li><li><p>异常是由于执行了现行指令所引起的，由于系统调用引起的中断属于异常</p><p>中断则是由于系统中某事件引起的，该事件与现行指令无关，但在指令结束后响应</p></li></ul></li><li><p>中断过程：中断检测、中断响应和中断处理</p><ul><li><p>中断响应：调出相应的中断服务程序（处在禁止中断状态）</p><p>主机发现外部中断请求，中止现行程序的执行，到调出中断服务程序这一过程</p><ul><li><p>条件</p><p>① CPU处于开中断状态</p><p>② 在一条指令执行完</p><p>③至少要有一个未被屏蔽的中断请求</p></li><li><p>响应过程：执行一条隐指令，需完成一次总线操作，从总线上取中断类型号</p><p>①关中断（0–&gt;中断允许触发器）</p><p>②保护断点（PC、PSW–&gt;堆栈)</p><p>③识别中断源（中断服务程序首地址–&gt;PC，初始PSW–&gt;PSWR）</p><ul><li><p>中断向量表：从总线的数据线上取得中断类型号后得到中断服务程序首址（向量中断）</p><p>$向量地址&#x3D;中断类型号×4$</p><p>中断类型号由中断控制器中的“<strong>中断优先权编码器</strong>” 专门用来进行中断源识别</p></li><li><p>或直接转中断查询程序（软件查询）</p></li></ul></li></ul></li><li><p>中断处理：执行相应中断服务程序的过程</p><ul><li><p>不同的中断源其对应的中断服务程序不同</p></li><li><p>单重中断：不允许在中断处理时被新的中断打断，因而直到中断返回前才会开中断</p><p>单重中断系统无需设置中断屏蔽字</p></li><li><p>多重中断：在一个中断处理（执行中断服务程序）过程中，若有新的中断请求发生， 且新中断优先级高于正在执行的中断，则中止正在执行的中断服务程序，转去处理新的中断。这种情况为多重中断，也称中断嵌套。 </p><ul><li>差别：一个允许被打断、一个不允许被打断；一个无屏蔽字，一个有屏蔽字</li></ul></li><li><p>中断处理过程：三个阶段</p><ul><li><p>先行段（准备阶段）（“禁止中断”状态）</p><p>保护现场及旧屏蔽字</p><p>查明原因（软件识别中断时）</p><p>设置新屏蔽字</p><p>开中断</p></li><li><p>本体段（具体的中断处理阶段）（处在“允许中断“状态，可被处理优先级更高的中断打断）</p></li><li><p>结束段（恢复阶段）</p><p>关中断</p><p>恢复现场及旧屏蔽字</p><p>清”中断请求“</p><p>开中断</p><p>中断返回</p></li></ul></li></ul></li></ul></li></ul></li><li><p>中断优先级</p><ul><li><p>中断响应优先级</p><p>由查询程序或硬联排队线路决定的优先权，反映多个中断同时请求时选择哪个响应</p></li><li><p>中断处理优先级</p><p>由各自的中断屏蔽字来动态设定，反应本中断与其他中断间的关系</p></li><li><p>中断优先权的动态分配</p><blockquote><p>例题：假定某中断系统有四个中断源，其响应优先级为1&gt;2&gt;3&gt;4。假定在用户程序时同时发生1、3和4级中断请求，执行3级中断服务程序时发生2级中断请求。分别写出处理优先级为1&gt;2&gt;3&gt;4和1&gt;4&gt;3&gt;2时各中断的屏蔽字及CPU完成中断处理的过程</p><blockquote><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220611105929919.png" alt="image-20220611105929919" style="zoom:50%;" /><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220611105952996.png" alt="image-20220611105952996" style="zoom:50%;" /></blockquote></blockquote></li></ul></li></ul></li><li><p>DMA方式：直接存储器存取（Direct Memory Access)</p><ul><li><p>引入DMA方式原因</p><p>程序直接控制方式受”踏步“现象限制，效率低下</p><p>中断控制方式对I&#x2F;O请求响应慢，数据传送速度慢</p></li><li><p>DMA方式的基本要点</p><ul><li><p>基本思想</p><p>在高速外设和主存间直接传送数据</p><p>由专门硬件（即DMA接口）控制总线进行传输</p></li><li><p>DMA方式适用场合</p><p>高速设备（磁盘光盘等）</p><p>成批数据交换，且数据间的间隔时间短，一旦启动数据连续读写</p></li><li><p>采用”请求-响应“方式</p><p>每当高速设备准备好数据，就进行一次”DMA请求“，DMA控制器接收到DMA请求后，申请总线使用权</p><p>DMA控制器总线使用优先级比CPU高（高速设备可能发生数据丢失）</p></li><li><p>与中断控制方式结合使用</p><p>DMA传送前，寻到旋转等操作结束时，通过中断告知CPU</p><p>在DMA控制器控制总线进行数据传送时，CPU执行其他程序</p><p>DMA传送结束后，要通过”DMA结束中断“告知CPU</p></li></ul></li><li><p>DMA数据传送方式</p><ul><li><p>CPU停止法（成组传送）</p><p>DMA传输时，CPU脱离总线，停止访问主存，直到DMA传完一块数据</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220611113837252.png" alt="image-20220611113837252" style="zoom:50%;" /><ul><li><p>优点：控制简单、适用于传输率很高的外设实现成组数据传送</p></li><li><p>缺点：CPU工作受影响，DMA访问时CPU基本处于停止状态</p><p>主存周期没有被充分利用，即使I&#x2F;O设备高速运行，但两个数据之间准备间隔时间总大于一个周期</p></li><li><p>改进</p><ul><li><p>在DMA接口中引入缓冲器：设置一个小容量高速缓存，I&#x2F;O设备先和缓存交换数据，绕后缓存再使用总线与主存快速交换数据</p></li><li><p>采用周期挪用（窃取）法：DMA传输时，CPU让出一个总线事务周期，由DMA控制器控制总线来访问主存，传送完一个数据后立即释放总线</p><p>挪用一个存储周期进行外设和主存交换一个数据</p></li><li><p>采用时间交替法：每个存储周期分为两个时间片，一个给CPU，一个给DMA</p></li></ul></li></ul></li><li><p>周期挪用（窃取）法（单字传送）</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220611115057767.png" alt="image-20220611115057767" style="zoom:50%;" /><ul><li><p>优点：既能及时响应 I&#x2F;O 请求，又能较好地发挥 CPU 和主存的效率</p><p>这种方式下，在下一数据的准备阶段，主存周期被 CPU 充分利用</p><p>因此适合于 I&#x2F;O 设备的读写周期大于主存周期的情况</p></li><li><p>缺点：每次 DMA 访存都要申请总线控制权、占用总线进行传送、释放总线，增加传输开销</p></li></ul></li><li><p>交替分时访问法</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220611114950237.png" alt="image-20220611114950237" style="zoom: 67%;" /><ul><li><p>特点：适用于 CPU 工作周期比主存存取周期更长的情况</p><p>不需要总线使用权的申请和释放</p></li></ul></li></ul></li><li><p>DMA控制器（DMA接口）的功能</p><ul><li>请求：能接收外设发来的”DMA请求“信号，并能向CPU发“总线请求”信号</li><li>响应：当CPU发出“总线响应“信号后，能接管对总线的控制</li><li>发主存地址并修改：能在地址线给出主存地址，并自动修改主存地址</li><li>识别传送方向：能识别传送方向以在控制线上给出正确的读写控制信息</li><li>确定传送数据个数</li><li>能发出DMA结束信号：引起一次DMA中断，进行数据校验等一些后处理</li></ul></li><li><p>DMA控制器的操作步骤</p><ul><li>DMA控制器的预置（初始化）——软件实现<ul><li>准备内存</li><li>设置参数</li><li>启动外设</li></ul></li><li>DMA数据传送——硬件实现<ul><li>DMA请求：选通-&gt;DMA请求-&gt;总线请求</li><li>DMA响应：总线响应（CPU让出总线）-&gt;DMA响应</li><li>DMA传送：DMA控制总线进行数据传送</li></ul></li><li>DMA结束处理——软件实现</li></ul><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220611131554004.png" alt="image-20220611131554004" style="zoom:50%;" /><ul><li><p>传输过程总览</p><p>(1)当外设准备好数据(或准备好接收数据)时，发“<strong>选通</strong>”信号，使数据送数据缓冲寄存器，同时DMA请求触发器置“1”</p><p>(2)DMA请求触发器向控制&#x2F;状态端口发“<strong>Ready</strong>”信号，同时向DMA控制器发“<strong>DMA请求</strong>”信号</p><p>(3)DMA控制器向CPU发“<strong>总线请求</strong>”信号</p><p>(4)CPU完成现行机器周期后，发出”<strong>总线响应</strong>”信号</p><p>(5)DMA控制器向I&#x2F;O接口发“<strong>DMA响应</strong>”信号，使DMA请求触发器复位。此时，CPU浮动它的总线，让出总线控制权，由DMA控制器控制总线</p><p>(6)DMA控制器给出<strong>内存地址</strong>，并在其读&#x2F;写线上发出“<strong>读</strong>”或“<strong>写</strong>”命令，随后在数据总线上给出数据</p><p>(7)根据读写命令，将数据总线上的数据写入存储器中，或写入数据端口，并进行主存地址增量，计数值减1</p><p>若采用“CPU停止法”，则循环第6~7步，直到计数值为“0”</p><p>若采用“周期挪用法”，则释放总线（下次数据传送时再按过程(1)到(6)进行）</p></li></ul></li><li><p>DMA方式与中断方式区别</p><p>(1)DMA方式下数据传送由<strong>硬件</strong>(DMA控制器)完成；中断方式下，数据传送由<strong>软件</strong>（CPU执行中断服务程序）完成</p><p>(2)DMA请求的是<strong>对存储器访问</strong>，也即对总线控制权的请求，没有中止现行程序的必要；而中断请求要处理器转去执行中断服务程序，因此要<strong>中止现行程序</strong>，保存断点、现场等</p><p>(3)中断除了能完成外设和主机的数据交换，还能<strong>处理异常事件</strong>；而DMA方式下<strong>不能处理异常事件</strong></p><p>(4)中断响应在一个<strong>指令周期结束后</strong>；而DMA响应是在一个<strong>总线周期后</strong></p><p>(5)DMA方式用于<strong>高速设备</strong>；而中断方式用于<strong>慢速设备</strong></p><p>(6) DMA方式下，外设与CPU<strong>并行度高</strong>；而中断方式下，外设与CPU<strong>并行度低</strong>（体现在数据传送时的并行性）</p><blockquote><p>例题：设处理器按500MHz的速度执行，硬盘控制器中有一个16B的数据缓存器，磁盘传输速率为4MB&#x2F;Sec，在磁盘传输数据过程中，要求没有任何数据被错过，并假定CPU访存和DMA访存没有冲突</p><p>（1）若用中断驱动I&#x2F;O，每次传送的开销（包括用于中断响应和处理的时间）是500个时钟周期。如果硬盘仅用5%的时间进行传送，那么处理器用在硬盘I&#x2F;O操作上所花的时间百分比（主机占用率）为多少？</p><p>（2）若用DMA方式，处理器花1000个时钟进行DMA传送的初始化设置，并且在DMA完成后的中断处理需要500个时钟。如果每次DMA传送8000B的数据块，那么当硬盘进行传送的时间占100%（即：硬盘一直进行读写，并传输数据）时，处理器用在硬盘I&#x2F;O操作上的时间百分比（主机占用率）为多少？</p><blockquote><p>中断传送：</p><ul><li><p>硬盘每次中断，可以以16字节为单位进行传送，为保证没有任何数据被错过，应达到每秒$4MB &#x2F;16B&#x3D;250K$次中断的速度</p></li><li><p>每秒钟用于中断的时钟周期数为$250K\times500&#x3D;125\times10^6$</p></li><li><p>在一次数据传输中，处理器花费在I&#x2F;O上的时间的百分比为$125\times 10^6&#x2F;(500\times10^6)&#x3D;25%$</p></li><li><p>假定硬盘仅用其中$5%$的时间来传送数据，则处理器花费在硬盘I&#x2F;O方面的百分比为$25%\times 5%&#x3D;1.25%$</p></li></ul></blockquote><blockquote><p>DMA传送：</p><ul><li><p>每次DMA传送将花费$8000B&#x2F;(4MB&#x2F;s)≈2\times10^{-3}$秒</p></li><li><p>一秒钟内有$1&#x2F;(2\times10^{-3} )&#x3D;500$次DMA传送</p></li><li><p>如果硬盘一直在传送数据的话，处理器必须每秒钟花$(1000+500)\times500&#x3D;750\times10^3$个时钟周期来为硬盘I&#x2F;O操作服务</p></li><li><p>在硬盘I&#x2F;O操作上处理器花费的时间占$750\times10^3&#x2F;(500\times10^6)&#x3D;1.5\times10^{-3}&#x3D;0.15%$</p></li></ul></blockquote></blockquote></li></ul></li></ol><h3 id="祝君考试顺利"><a href="#祝君考试顺利" class="headerlink" title="祝君考试顺利"></a>祝君考试顺利</h3><p><strong>Double S 2022.6.14</strong></p>]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库总结</title>
    <link href="/2022/05/25/Database/%E5%A4%87%E8%80%83%E9%80%9F%E8%AE%B0/"/>
    <url>/2022/05/25/Database/%E5%A4%87%E8%80%83%E9%80%9F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="计算机组成原理总结"><a href="#计算机组成原理总结" class="headerlink" title="计算机组成原理总结"></a>计算机组成原理总结</h2><h1 id="数据库急救包（Double-S）"><a href="#数据库急救包（Double-S）" class="headerlink" title="数据库急救包（Double S）"></a>数据库急救包（Double S）</h1><h3 id="数据库基本概念"><a href="#数据库基本概念" class="headerlink" title="数据库基本概念"></a>数据库基本概念</h3><ul><li><p>数据库（Database，简称DB）是长期<strong>存储在计算机内的</strong>、有组织的、可共享的大量<strong>数据的集合</strong>。</p></li><li><p>数据库的特征</p><p>  （1）数据按一定的数据模型组织、描述和存储—数据模型!</p><p>  （2）可为各种用户共享</p><p>  （3）冗余度较小</p><p>  （4）<strong>数据独立性</strong>较高（数据独立于应用程序） </p><p>  （5）易扩展</p></li><li><p>数据库系统组成部分</p><ul><li><p>硬件系统</p><p>数据库集合</p><p>数据库管理系统及相关软件</p><p>数据库管理员</p><p>用户</p></li></ul></li><li><p>元数据：元数据即描述数据的数据，相当于数据字典。主要是<strong>描述数据属性（property）的信息</strong>，如数据的类型，格式，存储大小等。</p></li></ul><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p><strong>对现实世界数据特征的抽象</strong>和<strong>对现实世界的模拟</strong>。</p><ul><li><p>组成要素：数据结构、数据操作、数据完整性</p></li><li><p>概念数据模型：E-R图，与具体的DBMS无关</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220524145850769.png" alt="image-20220524145850769" style="zoom:50%;" /></li><li><p>逻辑数据模型：是具体的DBMS所支持的数据模型。有层次模型，网状模型，<strong>关系模型，面向对象模型</strong>。</p></li><li><p>物理数据模型：<strong>面向具体的DBMS</strong>，描述数据在存储介质上的组织结构</p></li></ul><h3 id="数据管理技术"><a href="#数据管理技术" class="headerlink" title="数据管理技术"></a>数据管理技术</h3><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220524150324065.png" alt="image-20220524150324065" style="zoom:50%;" /><h3 id="数据库管理系统"><a href="#数据库管理系统" class="headerlink" title="数据库管理系统"></a>数据库管理系统</h3><ul><li><p>功能：<img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220524150435162.png" alt="image-20220524150435162" style="zoom:50%;" /></p></li><li><p>特点：</p><ul><li>数据结构化</li><li>数据的共享性高、冗余度低，易扩充</li><li>数据独立性高</li><li>数据由DBMS统一管理和控制</li></ul></li></ul><h3 id="数据库系统结构（三层模式）"><a href="#数据库系统结构（三层模式）" class="headerlink" title="数据库系统结构（三层模式）"></a>数据库系统结构（三层模式）</h3><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220524150619528.png" alt="image-20220524150619528" style="zoom:50%;" /><ul><li>外模式<ul><li>外模式也称子模式或用户模式，它是数据库用户看见和使用的局部数据的<strong>逻辑结构和特征的描述</strong>，是数据库用户的数据视图，是与某一应用程序有关的数据的逻辑表示。</li><li>外模式通常是模式的子集，<strong>一个数据库可以有多个外模式。</strong></li></ul></li><li>模式<ul><li><strong>模式也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。</strong></li><li>它是数据库系统模式结构的中间层，既不涉及数据的物理存储细节和硬件环境，也与具体的应用程序、所使用的应用开发工具及高级程序设计语言无关。</li><li><strong>一个数据库只有一个模式。</strong></li></ul></li><li>内模式<ul><li><strong>内模式也称存储模式，一个数据库只有一个内模式。</strong></li><li>它使用一个物理数据模型，<strong>全面描述了数据库中数据存储的全部细节和存取路径，是数据在数据库内部的表示方式。</strong></li></ul></li><li>外模式&#x2F;模式映射<ul><li>模式表达了数据的全局逻辑结构，外模式表达了数据的局部逻辑结构。对于每一个外模式，数据库系统都有一个外模式&#x2F;模式映像。对应于同一个模式可以有任意多个外模式。当模式改变时，由DBA对各个外模式&#x2F;模式映像作相应改变，可以使外模式&#x2F;模式保持不变，从而应用程序不必改变，保证了数据的逻辑独立性。</li></ul></li><li>模式&#x2F;内模式映射<ul><li>数据库只有一个模式和一个内模式，所以模式&#x2F;内模式映像是唯一的。</li><li>它定义了数据全局逻辑结构和存储结构之间的对应关系。</li><li>当数据库的存储结构改变了，由DBA对模式&#x2F;内模式作相应改变，可以使模式保持不变，从而保证了数据的物理独立性。</li></ul></li><li>目的：保证数据独立性<ul><li>逻辑独立性：指外部模式不受模式变化影响。</li><li>物理独立性：指模式不受内部模式变化的影响。</li></ul></li></ul><h3 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h3><ul><li><p>除                   关系代数  $\pi_XR-\pi_X((\pi_XR\times \pi_YS)-R)$</p><p>设关系模式为$R(A_1， A_2 ，…， A_n)$。它的一个关系设为$R$，$t[A_i]$则表示元组t中相应于属性A_i的一个<strong>分量</strong>。</p><p>给定一个关系R(X，Z)，X和Z为属性组。当$t[X] &#x3D; x$时，x在R中的<strong>象集</strong>（Images Set）为：</p><p>$$Z_x&#x3D;{t[Z]|t\in R,t[X]&#x3D;x}$$</p><p>给定关系R(X，Y)和S(Y，Z)，其中X，Y，Z为属性组。R中的Y与S中的Y可以有不同的属性名，但必须出自相同的域集，Z可以为空。R与S的除运算得到一个新的关系P(X)，P是R中满足下列条件的元组在X属性列上的投影：元组在X上分量值x的象集Y_X包含S在Y上投影的集合。记为：</p><p>$$R\div S&#x3D;{t_r[X]|t_r\in R\and\pi_Y(S)\subseteq Y_x}$$</p></li><li><p>广义投影 $\pi_{F_1,F_2,\ldots,F_n}(R)$ F为关系R属性上的函数，并可能含有常量</p></li><li><p>聚集函数 $\mathcal{G}_{count-distinct(职称)}(医生)$</p><p>分组形式 $(职称)\mathcal{G}_{count(医生编号)}(医生)$</p></li></ul><h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><ul><li><p>数据库开发生命周期(DDLC)</p><ul><li><p>（1）可行性研究和需求分析：了解企业或组织的运营状况，分析信息系统如何帮助解决经营过程中存在的问题，然后确定系统需求，完成功能规格说明书(FSD)。</p><p>（2）数据库设计：确定符合组织需求的数据库模型（数据库的概念模型）。</p><p>（3）数据库实现：根据选定的DBMS，将详细的概念模型转化为DBMS的实现模型。</p><p>（4）数据和应用程序转化：加载应用数据，将旧系统切换到新系统。</p><p>（5）测试和验证：测试新的数据库，验证预期结果。</p><p>（6）监控和维护：监控数据内容和应用程序的发展和扩充，并可能实施数据库模式的修改或重组。</p></li></ul></li><li><p>数据库设计</p><ul><li><p>需求分析阶段</p><p>概念设计阶段</p><p>逻辑设计阶段</p><p>物理设计阶段</p><p>实现阶段</p><p>运行与维护阶段</p></li><li><p>逻辑设计</p><ul><li><p>实体转换规则</p><p>一个实体集转换为关系模型中的一个关系，实体的属性就是关系的属性，实体的码就是关系的码，关系的结构是关系模式。</p></li><li><p>联系转换规则</p><ul><li><p>1：1联系：可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并。</p><p>当转换为独立的关系模式时，与之相连的每个实体的键均成为此关系模式的候选键，联系具有的属性成为关系的属性。如果采用与其中一端实体对应的关系模式合并方式，则合并后的关系模式属性应该加入另一端未合并的实体键和联系本身所具有的属性。</p></li><li><p>1：n联系：可以转换为一个独立的关系模式，也可以与n端所对应的关系模式合并。</p><p>如果采用转换为一个独立的关系模式，则与此联系相连接的各个实体的键，以及联系本身的属性均被转换为关系的属性，<strong>关系的键为n端实体的键</strong>。如果与n段对应关系合并，新属性包含1端实体集的码与联系自身属性，新增属性后原关系码不变。</p></li><li><p>m：n联系：转换为一个关系模式。</p><p>与此联系相连的各个实体的键及联系本身的属性均转换为关系的属性，<strong>各个相连实体的键的组合成为关系的键。</strong></p></li></ul></li></ul></li></ul></li></ul><h3 id="E-R图"><a href="#E-R图" class="headerlink" title="E-R图"></a>E-R图</h3><ul><li><p>实体集</p><ul><li>强实体集指不依赖于其他实体集存在的实体集。强实体集的特点是：每个实例都能被实体集的主键唯一标识。</li><li>弱实体集指依赖于其他实体集存在的实体集。弱实体集的特点是：每个实例不能用实体集的属性唯一标识。</li></ul></li><li><p>三个概念</p><ul><li>实体用方框表示，方框内注明实体的名称；</li><li>属性用椭圆形框表示，并用无向边将属性与对应的实体连接起来；</li><li>联系用菱形框表示，并用无向边将其与相关的实体连接起来。</li></ul></li><li><p>属性还是实体集</p><ul><li><p>（1）作为属性，不能再具有需要描述的性质。属性必须是不可分的数据项，不能包含其他属性。</p><p>（2）属性不能与其他实体具有联系，即E-R图中所表示的联系是实体之间的联系。</p></li></ul></li></ul><h3 id="无损分解与保持依赖"><a href="#无损分解与保持依赖" class="headerlink" title="无损分解与保持依赖"></a>无损分解与保持依赖</h3><ul><li><p>无损分解：一个关系表被分解成两个或两个以上的小表，通过<strong>连接</strong>被分解后的小表可以获得原始表的内容，则称为<strong>无损连接分解</strong>。</p><ul><li>充分必要条件：$(U_1\cap U_2)\rightarrow(U_1-U_2)$或$(U_1\cap U_2)\rightarrow(U_2-U_1)$</li></ul></li><li><p>保持依赖：设$\rho&#x3D;{R_1,\ldots,R_k}$是$R$的一个分解，$F$是$R$上的FD集，如果有$\mathop{\cup}\limits_{i&#x3D;1}^k\prod R_i(F)\models F$</p></li></ul><h3 id="最小依赖集"><a href="#最小依赖集" class="headerlink" title="最小依赖集"></a>最小依赖集</h3><p>![image-20220517204339967](C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220517204339967.png)</p><h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><ul><li><p>1NF：在关系模式R的每个关系r中，每个属性值都是不可再分的<strong>原子值</strong>。</p></li><li><p>2NF：关系模式R∈1NF，且每个<strong>非主属性</strong>（不是组成候选码的属性）<strong>完全函数依赖</strong>于候选码。</p><blockquote><p>设有关系模式R(U)，主键是W，R上还存在函数依赖X→Z，其中Z是非主属性和$X\subset W$，则$W→Z$就是一个局部依赖。此时应该把R分解成两个模式：</p><p>① R1（XZ），主键是X；</p><p>② R2（U-Z），主键仍为W，外键是X（参考R1）。</p><p>利用外键和主键的连接可以从R1和R2重新得到R。</p><p>如果R1和R2还不是2NF，则重复上述过程，一直到数据库模式中每一个关系模式都是2NF为止。</p></blockquote><p>![image-20220517205959809](C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220517205959809.png)</p></li><li><p>3NF:关系模式R∈1NF，且每个<strong>非主属性</strong>都<strong>不传递依赖</strong>于R的候选码。</p><p>（1）R中的非主属性相互独立；</p><p>（2）R中的非主属性函数依赖于主键。</p><blockquote><p>设关系模式R（U），<strong>主键是W</strong>，R上还存在FD X→Z，其中Z是非主属性，$Z\not\subseteq X$ 且X不是候选键，这样<strong>W→Z就是一个传递依赖</strong>。此时应把R分解成两个模式：</p><p>① R1（XZ），主键是X；</p><p>② R2（U-Z），主键仍是W，外键是X（参考R1）。</p><p>利用外键和主键相匹配机制，R1和R2通过连接可以重新得到R。</p><p>如果R1和R2还不是3NF，则重复上述过程，一直到数据库模式中每一个关系模式都是3NF为止。</p></blockquote><p>![image-20220517210319574](C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220517210319574.png)</p></li><li><p>BCNF:关系模式R∈1NF，且 (包含主属性和非主属性)都<strong>不传递依赖</strong>于R的候选码。</p><p>所有非主属性对每一个码都是完全函数依赖。</p><p>所有的主属性对每一个不包含它的码，也是完全函数依赖。</p><p>没有任何属性完全函数依赖于非码的任何一组属性。</p></li></ul><h3 id="SQL一些内容，语法见PPT"><a href="#SQL一些内容，语法见PPT" class="headerlink" title="SQL一些内容，语法见PPT"></a>SQL一些内容，语法见PPT</h3><ul><li><p>概述</p><ul><li><p>数据定义功能，DDL（Data Definition Language）</p><p>提供命令定义关系模式、索引、视图，包括创建CREATE，修改ALTER以及删除DROP等命令。</p></li><li><p>数据操纵功能，DML（Data Manipulation Language）</p><p>提供命令对存储在数据库中的数据进行查询和修改操作，包括查询数据SELECT、插入数据INSERT、更新数据UPDATE、删除数据DELETE等命令。</p></li><li><p>数据控制命令，DCL（Data Control Language）</p><p>提供对关系和视图的授权命令、事务的控制命令以及并发控制中的加锁操作等。</p></li></ul></li><li><p>视图：虚表，只存储视图定义，不存储视图数据</p><ul><li><p>优点</p><p>视图能简化用户的操作</p><p>提高数据的安全性</p><p>保证数据的完整性</p></li><li><p>定义视图语法</p><p>CREATE VIEW &lt;视图名&gt; [(视图列表)]</p><p>AS &lt;子查询&gt;</p><p>[ WITH CHECK OPTION ] </p></li><li><p>查询视图语法</p><p>SELECT * FROM DiagView</p></li><li><p>更新视图原则</p><ul><li><p>所定义的视图必须有一个单一表源</p></li><li><p>创建视图语法中不能用DISTINCT，不能含有GROUP BY、HAVING子句</p></li><li><p>每一个选择条目必须是一个简单的字段引用，选择列表中不能包含表达式、计算字段或者字段函数等</p></li><li><p>必须包含表源的所有NOT NULL列</p></li></ul></li><li><p>删除视图语法</p><p>DROP VIEW 要删除的视图名</p></li></ul></li><li><p>完整性约束（实体完整性、参照完整性、用户自定义完整性）</p><ul><li><p>主键约束</p><ul><li>在一个属性的类型定义完毕后，直接在后面加上PRIMARY KEY。</li><li>在所有属性定义完毕后，增加一个PRIMARY KEY的声明，指出主键包含哪些属性。</li></ul></li><li><p>UNIQUE约束：指明某一列或多个列的组合上的取值必须唯一</p><ul><li>在一个关系中，PRIMARY KEY只有一个，而UNIQUE可以声明多个</li><li>PRIMARY KEY要求属性取值不能为NULL，而UNIQUE允许属性取空值，允许多个空值同时存在</li><li>UNIQUE约束定义和PRIMARY KEY约束定义不能在同一属性上</li><li>PRIMARY KEY子句中的每个属性的取值都必须是NOT NULL</li><li>UNIQUE 约束唯一标识数据库表中的每条记录</li><li>可使用 UNIQUE 约束确保在非主键列中不输入重复值。</li></ul></li><li><p>NOT NULL约束</p></li><li><p>CHECK约束：保证属性值满足指定的条件</p></li><li><p>约束命名： CONSTRAINT 约束名称</p></li><li><p>约束创建</p><p>Create table RecipeDeteail(</p><p>​    Rno varchar(10) Constraint pk_rd primary key,</p><p>​    Pno varchar(20),</p><p>​    Dno varchar(20),</p><p>​    Constraint un_pname_pm unique(Pno,Dno))</p></li><li><p>约束添加</p><p>ALTER TABLE RecipeDetail </p><p>​    ADD CONSTRAINT rno_mnokey PRIMARY KEY(Rno,Mno);</p></li><li><p>约束删除</p><p>ALTER TABLE RecipeDetail DROP CONSTRAINT rno_mnokey;</p></li><li><p>Foreign Key约束</p><p>lR中每个元组在F上的值必须为：①或者取空值；②或者等于S中某个元组的主码值。</p><ul><li>REFERENCES &lt;被参照表表名&gt;（&lt;属性名&gt;）</li><li>FOREIGN KEY（&lt;属性名&gt;）REFERENCES &lt;被参照表表名&gt;（&lt;属性名&gt;）</li></ul></li><li><p>破坏参照完整性对策</p><ul><li><p>受限策略（RESTRICTED）（默认）</p><p>当出现违背参照完整性规则的更新操作请求时，系统拒绝执行该操作。</p></li><li><p>置空策略（SET-NULL）</p><p>依照参照完整性规则，外码是可以取空值的。</p><p>Ddeptno VARCHAR(10) REFERENCES Dept(DeptNo) <strong>ON DELETE SET NULL</strong></p></li><li><p>级联策略（CASCADE）不用拒绝用户操作请求的处理方式，连带处理参照数据。</p><p>Ddeptno VARCHAR(10) REFERENCES Dept(DeptNo) <strong>ON DELETE CASCADE</strong></p></li></ul></li><li><p>断言：SQL中的断言可以解决多张关系表关联的约束定义。</p><p>CREATE ASSERTION &lt;断言名&gt; CHECK&lt;谓词&gt;</p><p>Create assertion salarycheck check(</p><p>Not exists(</p><p>Select  from Doctor x</p><p>Where Dsalary &gt;&#x3D; some ( select Dsalary from Doctor y</p><p>Where x.Deptno&#x3D;y.Deptno and y.Dno &#x3D;(</p><p>Select Manager from Dept</p><p>Where x.Deptno &#x3D;Dept.Deptno)</p></li></ul></li><li><p>索引：避免全表扫描，耗时，提高查询性能的主要手段，属于<strong>内模式</strong></p><ul><li><p>常采用B树、B+树结构</p></li><li><p>聚簇索引</p><ul><li><p>建立聚簇索引后，基表中数据也需要按指定的聚簇属性值的升序或降序存放。也即聚簇索引的索引项顺序与表中记录的物理顺序一致</p></li><li><p>一个基本表上最多只能建立一个聚簇索引</p></li><li><p>对于某些类型(范围查找)的查询，可以提高查询效率</p></li><li><p>适用于：很少对基表进行增删操作</p><p>很少对其中的变长列进行修改操作</p></li><li><p>CREATE CLUSTER INDEX Stusname ON Student(Sname)；</p></li></ul></li><li><p>非聚簇索引</p><ul><li>数据存储在一个地方，索引存储在另一个地方，索引带有指针指向数据的存储位置。</li><li>在搜索数据值时，先对非聚集索引进行搜索，找到数据值在表中的位置，然后从该位置直接检索数据。</li><li>由于索引包含描述查询所搜索的数据值在表中的精确位置的条目，这使非聚集索引成为<strong>精确匹配查询</strong>的最佳方法。</li></ul></li><li><p>唯一值索引</p><ul><li>唯一索引确保索引列不包含重复的值。</li><li>创建PRIMARY KEY或UNIQUE约束会在表中指定的列上自动创建唯一索引。</li></ul></li><li><p>索引建立方法</p><ul><li>选择数据量较大的表建立索引</li><li>建立索引的数量要适量（需要付出代价）<ul><li>最好不超过3个</li><li>占用磁盘空间</li><li>建立索引会减慢插入、修改、删除的执行速度</li><li>在加快查询速度和降低更新速度之间作出权衡</li></ul></li><li>选择合适的时机建立索引<ul><li>建立索引应选择在表中装入数据之后（如果要保证装入数据的唯一性，则只能以牺牲系统性能为代价，而在装入数据前建立唯一性索引）</li></ul></li><li>优先考虑主键列建立索引</li></ul></li><li><p>索引相关语法</p><ul><li><p>创建索引</p><p>CREATE [ UNIQUE ] [ CLUSTERED | NONCLUSTERED ] INDEX &lt;索引名&gt;</p><p>ON &lt; 基表名 | 视图名&gt; ( 列名[ ASC | DESC ] [ ,…n ] )</p></li><li><p>删除索引</p><p>DROP INDEX 索引名</p></li></ul></li></ul></li></ul><h3 id="是否冲突"><a href="#是否冲突" class="headerlink" title="是否冲突"></a>是否冲突</h3><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220518192919157.png" alt="image-20220518192919157" style="zoom: 67%;" /><ul><li><p>若调度S中属于不同事务的两条操作指令是不冲突的，则可以交换两条指令的执行顺序，得到一个新的调度S′。称调度S与调度S′冲突等价的（conflict equivalent）。</p><p>若一个调度冲突等价于一个串行调度，则该调度是冲突可串行化的。</p><p><strong>冲突可串行化$\Rightarrow$可串行性</strong></p></li><li><p>对同一事务集，如果两个调度S1和S2在任何时候都保证<strong>每个事务读取相同的值，写入数据库的最终状态也是一样的</strong>，则称调度S1和S2视图等价。</p><p><strong>如果某个调度视图等价于一个串行调度，则称这个调度是视图可串行化的</strong></p><p><strong>如果调度是冲突可串行化的，则该调度一定是视图可串行化的。但反过来未必成立。</strong></p></li><li><p>可串行化判定：<strong>前驱图</strong></p><p>若前驱图中存在环，则表示调度S是不可串行化的；否则，表示调度S是冲突可串行化的，可用拓扑排序得到调度S 的一个等价的串行调度</p></li><li><p>数据库系统要求所有调度<strong>可恢复</strong>，可恢复条件：<strong>调度S中，事务Ti如果读取了事务Tj修改过的数据，则事务Ti必须等事务Tj提交后才能提交</strong></p></li><li><p>无级联回滚条件:调度S中的每对事务Ti和Tj，事务Ti如果读取了事务Tj修改过的数据，则事务Tj必须在Ti读取前提交</p></li></ul><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220518204134043.png" alt="image-20220518204134043" style="zoom: 67%;" /><h3 id="封锁"><a href="#封锁" class="headerlink" title="封锁"></a>封锁</h3><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220518210258085.png" alt="image-20220518210258085" style="zoom:67%;" /><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220518211052998.png" alt="image-20220518211052998" style="zoom:67%;" /><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220518211114878.png" alt="image-20220518211114878" style="zoom:67%;" /><h3 id="后像后写"><a href="#后像后写" class="headerlink" title="后像后写"></a>后像后写</h3><ul><li><p>后像在事务提交后才写入数据库 </p></li><li><p>事务T的日志写入步骤</p><ol><li><p>在T开始执行前，向日志中写入记录<T START>;</p></li><li><p>T的一次write（X）操作导致向日志中写入一条新记录;</p></li><li><p>最后，当T全部操作结束，向日志中写入记录<T COMMIT></p></li></ol></li><li><p>事务恢复</p><ol><li><p>忽略未完成的事务；</p></li><li><p>重复(Redo(Ti))已提交事务的影响：将事务Ｔi更新的所有数据项的值设为新值</p></li></ol></li><li><p>简化日志内容结构</p><p>由于忽略未完成的事务，只需要数据项的新值，前面介绍的更新日志记录结构可以简化，省去旧值字段。</p><p>日志记录&lt;T，X，V1&gt;：事务Ｔ对数据项Ｘ执行写操作，写入新值V1 </p></li><li><p>恢复处理步骤</p><ol><li><p>从后向前扫描日志，将提交的事务放入队列redo-list（找提交操作命令）</p></li><li><p>从前往后扫描日志。对遇到的每一&lt;T,X,V1&gt;记录:</p><p>如果T不是redo-list中的事务，则什么也不做。</p><p>如果T是redo-list中的事务，则为数据项X写入值V1</p></li><li><p>对每个未完成的事务，在日志中写入一个&lt;T,ABORT&gt;记录并刷新日志</p></li></ol></li></ul><h3 id="后像前写"><a href="#后像前写" class="headerlink" title="后像前写"></a>后像前写</h3><ul><li><p>后像在事务提交前完全写入数据库</p></li><li><p>事务T的日志写入执行步骤</p><ol><li><p>在T开始执行前，向日志中写入记录<T START>;</p></li><li><p>T的一次write（X）操作导致向日志中写入一条新记录;</p></li><li><p>最后，被改变的所有数据项已写入磁盘后向日志中写入记录&lt;T, COMMIT&gt;</p></li></ol></li><li><p>事务恢复</p><p>撤销(Undo($\rm{T}_i$))未完成的事务:将事务$\rm{T_i}$更新的所有数据项的值设为旧值。</p></li><li><p>简化日志内容结构</p><p>日志记录&lt;T，X，V1 &gt;表示：事务Ｔ对数据项Ｘ执行写操作，写前的旧值为V1。</p><p>前面介绍的更新日志记录结构可以简化，省去新值字段。</p></li><li><p>恢复处理步骤</p><ol><li><p>首先对日志文件从后向前进行扫描，将有&lt;T，COMMIT&gt;记录的事务放入redo-list队列;</p></li><li><p>然后对日志文件从后向前进行扫描;</p><p>对遇到的每一个&lt;T，X，V1&gt;记录，若事务T在redo-list队列中，则恢复管理器什么都不做；</p><p>对遇到的每一个&lt;T，X，V1&gt;记录，若事务T不在redo-list队列中，则恢复管理器将数据项X在数据库中的值改为旧值V1。</p></li><li><p>对每个未完成的事务，在日志中写入一个&lt;T,ABORT&gt;记录并刷新日志。</p></li></ol></li></ul><h3 id="后像前后写"><a href="#后像前后写" class="headerlink" title="后像前后写"></a>后像前后写</h3><ul><li><p>后像在事务提交<strong>前后</strong>写入数据库</p></li><li><p>事务T的日志写入执行步骤</p><ol><li><p>在T开始执行前，向日志中写入记录<T START>；</p></li><li><p>T的一次write（X）操作导致向日志中写入一条新记录；</p></li><li><p>最后，被改变的所有数据项已写入磁盘后向日志中写入记录&lt;T, COMMIT&gt;。</p></li></ol></li><li><p>事务恢复</p><p>Undo (Ti)：将未提交事务Ti更新的所有数据项的值设为旧值。</p><p>Redo (Ti)：将已提交事务Ti更新的所有数据项的值设为新值。</p></li><li><p>日志内容结构</p><p>日志记录&lt;T，X，V1，V2&gt;表示：事务Ｔ对数据项Ｘ执行写操作，写前的旧值为V1，写后的新值为V2</p></li><li><p>恢复处理步骤</p><ol><li><p>首先对日志文件从后向前进行扫描，将有&lt;T，COMMIT&gt;记录和没有&lt;T，COMMIT&gt;记录的事务分别放入两个队列：redo-list队列，undo-list队列；</p></li><li><p>从前向后再次扫描日志记录，重新执行redo-list队列中的事务；</p></li><li><p>从后向前再次扫描日志记录，撤销undo-list队列中的事务。</p></li></ol></li></ul><h3 id="缓冲区管理"><a href="#缓冲区管理" class="headerlink" title="缓冲区管理"></a>缓冲区管理</h3><ul><li><p>最近最少使用LRU：最久无访问</p></li><li><p>先进先出FIFO：最早进入缓冲区</p></li><li><p>最近最少使⽤算法LFU ：最小访问频率</p></li><li><p>先写日志规则：</p><ol><li><p>在日志记录【Ti commit】写入磁盘之后，才允许事务Ti进入提交状态(写入磁盘);</p></li><li><p>在日志记录【Ti commit】写入磁盘之前，要保证commit之前的日志记录已经写入磁盘；</p></li><li><p>主存中的数据块写入磁盘之前，所有与该数据块相关的日志记录必须已写入磁盘；</p></li></ol></li></ul><h3 id="检查点"><a href="#检查点" class="headerlink" title="检查点"></a>检查点</h3><ul><li><p><strong>提交一致性检查点</strong>：所有检查点前执行的事务将已经完成，并且其更新也已经写入磁盘。因此，恢复时这些事务都不需要撤销。在恢复时，系统从日志尾部（上面图的最下面）开始向前扫描，确定未完成的事务，当发现<checkpoint>记录时，表明已找完所有未完成的事务。由于只有检查点结束后事务才能开始，因此没有必要扫描<checkpoint>记录以前的部分。这样，可以大大减少进行恢复操作所需要的时间。</p><ul><li>提交一致性检查点需要等到所有活动事务提交后才能建立，等待时间可能会很长</li></ul></li><li><p><strong>高速缓存一致性检查点</strong>：所做的任何数据库修改都必然在检查点前或作为检查点的一部分写入数据库</p></li></ul><h3 id="数据转储"><a href="#数据转储" class="headerlink" title="数据转储"></a>数据转储</h3><ul><li>静态转储<ul><li>在系统无运行事务时进行转储</li><li>转储开始时数据库处于一致性状态</li><li>转储期间不允许对数据库的任何存取、修改活动</li><li>优点：实现简单</li><li>缺点：降低了数据库的可用性<ul><li>转储必须等用户事务结束</li><li>新的事物必须等转储结束</li></ul></li></ul></li><li>动态转储<ul><li>转储操作与用户事务并发进行</li><li>转储期间允许对数据库进行存取或修改</li><li>优点<ul><li>不用等待正在运行的用户事务结束</li><li>不会影响新事务的运行</li></ul></li><li>缺点<ul><li>不能保证副本中的数据正确有效</li></ul></li><li>利用动态转储得到的副本进行故障恢复<ul><li>需要把动态转储期间各事务对数据库的修改活动登记下来，建立日志文件</li><li>后备副本加上日志文件才能把数据库恢复到某一时刻的正确状态</li></ul></li></ul></li><li>完全转储: 每次转储全部数据库</li><li>增量转储: 只转储上次转储后更新过的数据</li><li>完全转储与增量转储比较<ul><li>从恢复角度看，使用完全转储得到的后备副本进行恢复往往更方便</li><li>但如果数据库很大，事务处理又十分频繁，则增量转储方式更实用更有效</li></ul></li></ul><h3 id="恢复处理"><a href="#恢复处理" class="headerlink" title="恢复处理"></a>恢复处理</h3><ul><li><p>事务故障（含逻辑错误与系统错误）</p><ul><li>恢复策略：利用日志文件撤销此事务对数据库已经进行做过的修改</li><li>恢复处理<ul><li>后像后写：恢复管理器忽略这些未完成的事务</li><li>后像前写与后像前后写：使用日志文件撤销此事务对数据库的修改</li></ul></li></ul></li><li><p>系统故障</p><ul><li>恢复策略：利用日志文件撤销未完成事务，重做已提交事务</li><li>恢复处理<ul><li>当系统崩溃重新启动时，它构造两个队列：undo-list存放需要撤销的事务标识符，redo-list存放需要重做得事务标识符。</li><li>这两个队列刚开始时都是空的。</li><li>队列构造步骤如下<ul><li>系统反向扫描日志，直到发现第一个<checkpoint>记录。</li><li>对每一个&lt;Ti，COMMIT&gt;记录，将Ti加入redo-list。</li><li>对每一个&lt;Ti，START&gt;记录，如果Ti不属于redo-list，则将Ti加入undo-list。</li></ul></li><li>后像后写<ul><li>对undo-list中的事务，在日志中写入一个&lt;Ti，ABORT&gt;记录并刷新日志。</li><li>对redo-list中的事务执行REDO操作：从前面发现的<checkpoint>记录开始，正向扫描日志文件，对遇到的每一个&lt;Ti，X，V1&gt;记录，将数据库中的X数据项更新为新值V1。</li></ul></li><li>后像前写<ul><li>反向扫描undo-list日志文件，对遇到的每一个&lt;Ti，X，V1&gt;记录，将数据库中的X数据项更新为旧值V1，扫描到&lt;Ti，START&gt;记录时，扫描停止。</li><li>在日志中写入一个&lt;Ti，ABORT&gt;记录并刷新日志。</li><li>重复上两个步骤，直到处理完撤销队列中的每一个事务。</li></ul></li><li>后像前后写<ul><li>系统重新反向扫描日志文件，对undo-list中的每一事务执行UNDO操作，即对遇到的每一个&lt;Ti，X，V1，V2&gt;记录，将数据库中的X数据项更新为旧值V1。</li><li>在日志中写入一个&lt;Ti，ABORT&gt;记录并刷新日志。当undo-list中所有事务Ti所对应的&lt;Ti，START&gt;记录都找到时，扫描结束。</li><li>系统找出日志中最后一条<checkpoint>记录。</li><li>系统由最后一条<checkpoint>记录开始，正向扫描日志文件，对redo-list中的事务Ti的每一个日志记录执行redo操作。即对遇到的每一个&lt;Ti，X，V1，V2&gt;记录，将数据库中的X数据项更新为新值V2。</li></ul></li></ul></li></ul></li><li><p>介质故障</p><ul><li><p>恢复处理</p><ol><li><p>如果有后续的增量转储，按照从前往后的顺序，根据增量转储来修改数据库。</p></li><li><p>装入最近的完全转储后备副本，若数据库副本是动态转储的，还需要同时装入转储开始时刻的日志文件副本，利用恢复系统故障的方法将数据库恢复到某个一致性状态。</p></li><li><p>装入转储结束后的日志文件副本，重做已完成的事务。首先反向扫描日志文件，找出故障发生时已经提交的事务，将事务标识符写入redo-list。然后正向扫描日志文件，对redo-list中的所有事务进行redo操作。</p></li></ol></li></ul></li></ul><h3 id="数据库安全概述"><a href="#数据库安全概述" class="headerlink" title="数据库安全概述"></a>数据库安全概述</h3><p>![image-20220524141945777](C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220524141945777.png)</p><ul><li>支持自主存取控制（DAC）的DBMS属于C1级；</li><li>支持审计功能的DBMS属于C2级；</li><li>支持强制存取控制（MAC）的DBMS则可以达到B1级。</li><li>B2以上的系统标准更多地还处于理论研究阶段，<br>产品化以至商品化的程度都不高，<br>其应用也多限于一些特殊的部门如军队等。</li></ul><h3 id="DAC（自主访问控制）C1"><a href="#DAC（自主访问控制）C1" class="headerlink" title="DAC（自主访问控制）C1"></a>DAC（自主访问控制）C1</h3><ul><li><p><strong>访问数据的权限</strong></p><ul><li><p>SELECT（读取权限）：允许读数据，但不能修改数据。</p><p>例：SELECT（Pname，Paddr）表示只授予用户查询关系表中Pname，Paddr 两个属性中数据的权限，关系表中其他属性的数据对用户是屏蔽的。</p><p>lNSERT（插入权限）：允许插入一条新的数据，但不能修改已有数据。</p><p>UPDATE（修改权限）：允许修改数据，但不能删除数据。</p><p>DELETE（删除权限）：允许删除数据。</p></li></ul></li><li><p><strong>修改数据库模式的权限</strong></p><ul><li><p>lndex（索引权限）：允许建立或删除索引。</p><p>Create（创建权限）：允许建立新的关系表。</p><p>Alter（修改权限）：允许对关系表中的属性进行增加、删除。</p><p>Drop（删除权限）：允许删除关系表。</p></li></ul></li><li><p><strong>其它权限</strong></p><ul><li><p>REFERENCE权限：允许用户在建立关系的完整性约束中引用一个参照关系</p><p>USAGE权限：授权用户使用一个指定的域</p><p>TRIGGER权限：授权用户定义关系表中触发器的权利</p><p>EXECUTE权限：授予用户执行一个函数或过程的权利</p><p>UNDER权限：授权用户建立一给定类的子类</p></li></ul></li><li><p><strong>授权</strong></p><ul><li><p>GRANT {all privileges|privilege{. privilege….}}</p><p>ON [TABLE] tablename|viewname</p><p>TO [PUBLIC|user_name{,user_name…}]</p><p>[WITH GRANT OPTION] </p></li><li><p>ALL PRIVILEGES是所有权限的总称</p><p>数据对象可以是基本表，也可以是视图</p><p>用户名可以代表单一用户也可以代表一组用户，当代表一组用户时我们称为角色。PUBLIC是所有数据库用户的总称；</p><p>WITH GRANT OPTION，受权者可以将此权限转授给其他用户；</p><p>一个用户如果是表的创建者，他就自动拥有了对所创建表的所有权利以及将该表权利授予其他用户的权利，而且不能取消。</p></li><li><p>收回权限格式</p><p>REVOKE [GRANT OPTION FOR]{ALL PRIVILEGES|privilege{. Privilege….}}</p><p>ON [TABLE] tablename|viewname</p><p>FROM [PUBLIC|user_name{,user_name…}]</p><p>[RESTRICT|CASCADE]</p></li></ul></li><li><p><strong>基于角色的访问控制</strong>（RBAC）</p><img src="C:\Users\Double S\AppData\Roaming\Typora\typora-user-images\image-20220524143921394.png" alt="image-20220524143921394" style="zoom:50%;" /><ul><li><p>创建角色</p><p>CRETAE ROLE Admin;</p></li><li><p>角色授权</p><p>GRANT SELECT ON RecipeMaster TO Admin;</p></li><li><p>角色授予用户或其他角色</p><p>GRANT Admin TO LiXia;</p><p>CREATE ROLE Manager;</p><p>GRANT Admin to Manager;</p><p>GRANT Manager TO WangHao;</p><p>角色Manager除具有直接赋予它的权限外，还继承了角色Admin具有的权限。</p></li></ul></li></ul><h3 id="MAC（强制访问控制）B1"><a href="#MAC（强制访问控制）B1" class="headerlink" title="MAC（强制访问控制）B1"></a>MAC（强制访问控制）B1</h3><ul><li><p><strong>保密性规则</strong></p><p>仅当主体的许可证级别高于或者等于客体的密级时（只进不出）（Read,Lsubject≥Lobject），该主体才能读取相应的客体。（下读，RD）</p><p>仅当主体的许可证级别低于或者等于客体的密级时（Write,Lsubject≤Lobject），该主体才能写相应的客体。（上写，WU）</p></li><li><p><strong>完整性规则</strong></p><p>仅当主体的许可证级别低于或者等于客体的密级时（Read,Lsubject≤Lobject），该主体才能读取相应的客体。（上读，RU）</p><p>仅当主体的许可证级别高于或者等于客体的密级时（Write,Lsubject≥Lobject），该主体才能写相应的客体。（下写，WD）</p></li><li><p>MAC与DAC结合</p><ul><li>DAC与MAC共同构成DBMS的安全机制</li><li>先进行DAC检查，通过DAC检查的数据对象再由系统进行MAC检查</li><li>只有通过MAC检查的数据对象方可存取。</li></ul></li></ul><h3 id="审计C2"><a href="#审计C2" class="headerlink" title="审计C2"></a>审计C2</h3><p>跟踪审计是一种监视措施，记录了用户对数据库的所有操作。一旦发现问题，系统可自动报警，或根据数据进行事后的分析和调查。</p><ul><li><p>审计操作（ORACLE）</p><p>提供AUDIT语句设置审计功能，NOAUDIT语句取消审计功能。</p><p>通过DBA_AUDIT_TRAIL视图可以查询审计结果。</p></li><li><p>审计示例：跟踪用户scott的表RecipeMaster上的所有更新操作</p><p>SQL&gt; AUDIT UPDATE on scott.RecipeMaster BY ACCESS;</p><p>SQL&gt; NOAUDIT ALL ON RecipeMaster；</p></li></ul><h3 id="完结！SQL详细语法看PPT吧"><a href="#完结！SQL详细语法看PPT吧" class="headerlink" title="完结！SQL详细语法看PPT吧"></a>完结！SQL详细语法看PPT吧</h3><p><strong>祝君考试顺利</strong></p><p><strong>Double S 2022.5.24</strong></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
